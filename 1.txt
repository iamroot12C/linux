Documentation/SAK.txt:What key sequence should you use? Well, CTRL-ALT-DEL is used to reboot
Documentation/isdn/README.hysdn:   rebooted and an boot error occurs. 
Documentation/debugging-via-ohci1394.txt:   host loaded, reboot the debugged machine, booting the kernel which has
Documentation/powerpc/firmware-assisted-dump.txt:   unlike kdump, fadump doesn't need a 2nd reboot to get back
Documentation/powerpc/firmware-assisted-dump.txt:    dump and continue without 2nd reboot.
Documentation/powerpc/hvcs.txt:adapter is not guaranteed to remain the same across system reboots.  Look
Documentation/powerpc/hvcs.txt:after a reboot.  What happened?
Documentation/powerpc/hvcs.txt:partition is rebooted.
Documentation/powerpc/eeh-pci-error-recovery.txt:card to be "rebooted", without also having to reboot the operating
Documentation/powerpc/eeh-pci-error-recovery.txt:the OS the ability to "reboot"/recover individual PCI devices.
Documentation/powerpc/eeh-pci-error-recovery.txt:do not need to know that the PCI card has been "rebooted" in this
Documentation/powerpc/eeh-pci-error-recovery.txt:   card was being rebooted.
Documentation/mic/mic_overview.txt:the card during suspend and reboots the card OS during resume.
Documentation/i2c/writing-clients:or reboots (including kexec) -- like turning something off -- use a
Documentation/device-mapper/snapshot.txt:after reboot).
Documentation/device-mapper/dm-log.txt:logging state survives reboots/crashes.
Documentation/device-mapper/dm-log.txt:will not survive a reboot or crash, but there may be a small boost in
Documentation/arm/SA1100/Assabet:time the Assabet is rebooted.  Therefore it's possible to automatize the boot
Documentation/arm/SA1100/Assabet:Then, rebooting the Assabet is just a matter of waiting for the login prompt.
Documentation/driver-model/driver.txt:driver module is being unloaded, during a reboot sequence, or
Documentation/intel_txt.txt:   attempt to crash the system to gain control on reboot and steal
Documentation/sound/oss/README.modules:  Once you are configured, make zlilo, modules, modules_install; reboot.
Documentation/sound/alsa/CMIPCI.txt:  from front and rear speakers!  But.. after reboot, all was gone.
Documentation/sound/alsa/HD-Audio.txt:`probe_only=1` option (at best after the cold reboot) and run
Documentation/power/s2ram.txt:driver that doesn't resume and recompile and reboot).
Documentation/power/s2ram.txt: - if it doesn't come back up (which is usually the problem), reboot by
Documentation/power/s2ram.txt:survive a reboot.
Documentation/power/s2ram.txt:As the clock keeps ticking it is also essential that the reboot is done
Documentation/power/userland-swsusp.txt:		system MUST be powered off or rebooted after the snapshot
Documentation/power/drivers-testing.txt:b) Load the driver and attempt to hibernate in the "reboot", "shutdown" and
Documentation/power/drivers-testing.txt:   in the "reboot", "shutdown" and "platform" modes.
Documentation/power/interface.txt:(e.g. ACPI or other suspend_ops), powering off the system or rebooting the
Documentation/power/interface.txt:	[shutdown] reboot test testproc
Documentation/power/interface.txt:       'reboot'
Documentation/power/interface.txt:the RTC across reboots, so that you can debug a machine that just hangs
Documentation/power/interface.txt:reboot it and run
Documentation/power/basic-pm-debugging.txt:To check if hibernation works, you can try to hibernate in the "reboot" mode:
Documentation/power/basic-pm-debugging.txt:# echo reboot > /sys/power/disk
Documentation/power/basic-pm-debugging.txt:and the system should create a hibernation image, reboot, resume and get back to
Documentation/power/basic-pm-debugging.txt:resuming the system.]  Moreover, hibernating in the "reboot" and "shutdown"
Documentation/power/basic-pm-debugging.txt:to hibernate or resume in the "reboot" mode, you should try the "platform" mode:
Documentation/power/basic-pm-debugging.txt:(it is similar to the "reboot" mode, but it requires you to press the power
Documentation/power/basic-pm-debugging.txt:(that would probably involve rebooting the system, so always note what drivers
Documentation/power/basic-pm-debugging.txt:"reboot", "shutdown" and "platform" modes.  If that does not work, there
Documentation/power/basic-pm-debugging.txt:unload n/2 of the modules and try again (that would probably involve rebooting
Documentation/power/swsusp.txt:swsusp saves the state of the machine into active swaps and then reboots or
Documentation/watchdog/hpwdt.txt: 2. reboot the sever
Documentation/watchdog/watchdog-api.txt:system (causing a reboot) after the timeout occurs.
Documentation/watchdog/watchdog-api.txt:activates as soon as /dev/watchdog is opened and will reboot unless
Documentation/watchdog/watchdog-api.txt:crashes the system will not reboot.  Because of this, some of the
Documentation/watchdog/watchdog-api.txt:started.  So, if the watchdog daemon crashes, the system will reboot
Documentation/watchdog/watchdog-api.txt:cause a reboot if the watchdog is not re-opened in sufficient time.
Documentation/watchdog/watchdog-api.txt:Get the number of seconds before reboot:
Documentation/watchdog/watchdog-api.txt:before the system will reboot. The WDIOC_GETTIMELEFT is the ioctl
Documentation/watchdog/watchdog-api.txt:that returns the number of seconds before reboot.
Documentation/watchdog/watchdog-api.txt:the reason for the last reboot of the system.  The GETSUPPORT ioctl is
Documentation/watchdog/watchdog-api.txt:The machine was last rebooted by the watchdog because the thermal limit was
Documentation/watchdog/watchdog-api.txt:The last reboot was caused by the watchdog card
Documentation/watchdog/watchdog-api.txt:status, and the status at the last reboot, respectively.  
Documentation/watchdog/wdt.txt:to within a timeout or the machine will reboot. Each write delays the reboot
Documentation/watchdog/wdt.txt:reboot will depend on the state of the machines and interrupts. The hardware
Documentation/watchdog/wdt.txt:will reboot from almost anything.
Documentation/watchdog/watchdog-parameters.txt:testmode: Watchdog test mode (1 = no reboot), default=0
Documentation/watchdog/watchdog-parameters.txt:soft_noboot: Watchdog action, set to 1 to ignore reboots, 0 to reboot
Documentation/watchdog/watchdog-parameters.txt:soft_noboot: Softdog action, set to 1 to ignore reboots, 0 to reboot
Documentation/watchdog/watchdog-parameters.txt:testmode: Watchdog testmode (1 = no reboot), default=0
Documentation/watchdog/watchdog-parameters.txt:testmode: Watchdog testmode (1 = no reboot), default=0
Documentation/00-INDEX:	- how to auto-reboot Linux if it has "fallen and can't get up". ;-)
Documentation/filesystems/ntfs.txt:  run three times in sequence with each driver (after a reboot) on a 1.4GiB
Documentation/filesystems/proc.txt:reboot the machine once an error has been made.
Documentation/filesystems/proc.txt:need to  recompile  the kernel, or even to reboot the system. The files in the
Documentation/filesystems/hpfs.txt:funny thing was that, when rebooted, PmShell tried to reopen this directory
Documentation/filesystems/cifs/CHANGES:(or server rebooted) and the cifs client will reconnect.  
Documentation/filesystems/cifs/README:		unmount or reboot which can confuse some applications,
Documentation/filesystems/nfs/Exporting:server-reboot (among other things, though these tend to be the most
Documentation/filesystems/nfs/nfs-rdma.txt:  - Build, install, reboot
Documentation/filesystems/nfs/nfs.txt:across client reboots.
Documentation/filesystems/nfs/nfs.txt:or loss of state during NFS reboot recovery or transparent state migration.
Documentation/filesystems/nfs/nfs41-server.txt:  persist across client reboots).  Thus we need not implement this for
Documentation/filesystems/ubifs.txt:Similarly to JFFS2, UBIFS is tolerant of unclean reboots and power-cuts.
Documentation/IPMI.txt:gets a pre-action.  During a panic or a reboot, the watchdog will
Documentation/IPMI.txt:start a 120 timer if it is running to make sure the reboot occurs.
Documentation/ldm.txt:partitions and filesystems without the need to reboot.
Documentation/laptops/sony-laptop.txt:				when the laptop will be rebooted
Documentation/laptops/sony-laptop.txt:sets the lowest screen brightness for the next and later reboots,
Documentation/laptops/sony-laptop.txt:sets the highest screen brightness for the next and later reboots,
Documentation/laptops/thinkpad-acpi.txt:so it is kept across reboots and power-off.
Documentation/laptops/thinkpad-acpi.txt:state so that the ThinkPad will retain such settings across reboots.
Documentation/laptops/thinkpad-acpi.txt:shutdown/reboot).
Documentation/laptops/thinkpad-acpi.txt:(so that volume/mute changes are remembered across shutdown/reboot).
Documentation/laptops/thinkpad-acpi.txt:so it is kept across reboots and power-off.
Documentation/PCI/pcieaer-howto.txt:After reboot with new kernel or insert the module, a device file named
Documentation/PCI/pci-error-recovery.txt:>>> and prints an error to syslog.  A reboot is then required to 
Documentation/PCI/pci.txt:	shutdown	Hook into reboot_notifier_list (kernel/sys.c).
Documentation/PCI/pci.txt:			the power state of a device before reboot.
Documentation/hwmon/abituguru-datasheet:after a reboot uGuru will hold 0x00 here, but if the driver is removed and
Documentation/hwmon/abituguru-datasheet:voltages which proprably safed my computer (after a reboot I managed to
Documentation/kernel-parameters.txt:			    until the next reboot
Documentation/kernel-parameters.txt:	nonmi_ipi	[X86] Disable using NMI IPIs during panic/reboot to
Documentation/kernel-parameters.txt:			It's said poweroff/reboot may depend on CPU0 on some
Documentation/kernel-parameters.txt:			Useful together with panic=30 to trigger a reboot.
Documentation/kernel-parameters.txt:			timeout > 0: seconds before rebooting
Documentation/kernel-parameters.txt:			timeout < 0: reboot immediately
Documentation/kernel-parameters.txt:	reboot=		[KNL]
Documentation/kernel-parameters.txt:			Where reboot_mode is one of warm (soft) or cold (hard) or gpio,
Documentation/kernel-parameters.txt:			      reboot_type is one of bios, acpi, kbd, triple, efi, or pci,
Documentation/kernel-parameters.txt:			      reboot_force is either force or not specified,
Documentation/kernel-parameters.txt:			      reboot_cpu is s[mp]#### with #### being the processor
Documentation/kernel-parameters.txt:					to be used for rebooting.
Documentation/kernel-parameters.txt:			where the system hangs or reboots and does not give the
Documentation/devicetree/bindings/powerpc/4xx/reboot.txt:Reboot property to control system reboot on PPC4xx systems:
Documentation/devicetree/bindings/arm/vexpress-sysreg.txt:	"arm,vexpress-reboot"
Documentation/devicetree/bindings/arm/brcm-brcmstb.txt:Lastly, nodes that allow for support of SMP initialization and reboot are
Documentation/devicetree/bindings/arm/brcm-brcmstb.txt:reboot
Documentation/devicetree/bindings/arm/brcm-brcmstb.txt:        The string property "brcm,brcmstb-reboot" for 40nm/28nm chips with
Documentation/devicetree/bindings/arm/brcm-brcmstb.txt:        the new SYS_CTRL interface, or "brcm,bcm7038-reboot" for 65nm
Documentation/devicetree/bindings/arm/brcm-brcmstb.txt:    reboot {
Documentation/devicetree/bindings/arm/brcm-brcmstb.txt:        compatible = "brcm,brcmstb-reboot";
Documentation/devicetree/bindings/arm/hisilicon/hisilicon.txt:- reboot-offset : offset in sysctrl for system reboot
Documentation/devicetree/bindings/arm/hisilicon/hisilicon.txt:		reboot-offset = <0x4>;
Documentation/devicetree/bindings/arm/hisilicon/hisilicon.txt:		reboot-offset = <0x4>;
Documentation/devicetree/bindings/power/reset/syscon-reboot.txt:with the mask defined in the reboot node.
Documentation/devicetree/bindings/power/reset/syscon-reboot.txt:- compatible: should contain "syscon-reboot"
Documentation/devicetree/bindings/power/reset/syscon-reboot.txt:- offset: offset in the register map for the reboot register (in bytes)
Documentation/devicetree/bindings/power/reset/syscon-reboot.txt:- mask: the reset value written to the reboot register (32 bit access)
Documentation/devicetree/bindings/power/reset/syscon-reboot.txt:	reboot {
Documentation/devicetree/bindings/power/reset/syscon-reboot.txt:	   compatible = "syscon-reboot";
Documentation/devicetree/bindings/input/input-reset.txt:generating a sysrq. If omitted the system is rebooted immediately when a valid
Documentation/devicetree/bindings/mmc/mmc-pwrseq-emmc.txt:unknown state), and before performing complete system reboot (also in
Documentation/devicetree/bindings/mmc/mmc-pwrseq-emmc.txt:case of emergency reboot call). The latter is needed on boards, which
Documentation/devicetree/bindings/thermal/imx-thermal.txt:  is higher than panic threshold, system will auto reboot by SRC module.
Documentation/fb/intel810.txt:	The external VGA monitor can then be attached without rebooting.
Documentation/ia64/efirtc.txt:i.e. reboot. This is very different from the alarm provided by the legacy
Documentation/ABI/testing/sysfs-bus-iio:		since the last reboot while activated. Units after application
Documentation/ABI/testing/sysfs-bus-iio:		since the last reboot while activated.
Documentation/ABI/testing/sysfs-firmware-gsmi:			a reboot is required for the configuration to be
Documentation/ABI/testing/sysfs-firmware-gsmi:			Callers should assume that a reboot is needed
Documentation/ABI/testing/sysfs-power:		'reboot' - the memory image will be saved by the kernel and
Documentation/ABI/testing/sysfs-power:		the system will be rebooted.
Documentation/ABI/testing/sysfs-power:		'reboot'
Documentation/ABI/testing/sysfs-power:		last PM event point in the RTC across reboots, so that you can
Documentation/ABI/testing/sysfs-power:		the machine, then reboot it and run
Documentation/ABI/testing/sysfs-power:		across reboots when pm_trace has been used.  More precisely it
Documentation/ABI/testing/sysfs-firmware-efi-runtime-map:		mode once without rebooting. The kexec kernel must maintain
Documentation/ABI/testing/pstore:		across system reboots can register with this driver to
Documentation/ABI/stable/sysfs-class-tpm:		cycle. Whether a warm boot (reboot) will clear a TPM chip
Documentation/x86/x86_64/boot-options.txt:		in a reboot. On Intel systems it is enabled by default.
Documentation/x86/x86_64/boot-options.txt:   reboot=b[ios] | t[riple] | k[bd] | a[cpi] | e[fi] [, [w]arm | [c]old]
Documentation/x86/x86_64/boot-options.txt:   bios	  Use the CPU reboot vector for warm reset
Documentation/x86/x86_64/boot-options.txt:   warm   Don't set the cold reboot flag
Documentation/x86/x86_64/boot-options.txt:   cold   Set the cold reboot flag
Documentation/x86/x86_64/boot-options.txt:          ACPI reset does not work, the reboot path attempts the reset using
Documentation/x86/x86_64/boot-options.txt:          EFI reset does not work, the reboot path attempts the reset using
Documentation/x86/x86_64/boot-options.txt:   on reboot so there may be boot problems on some systems.
Documentation/x86/x86_64/boot-options.txt:   reboot=force
Documentation/x86/x86_64/boot-options.txt:   Don't stop other CPUs on reboot. This can make reboot more reliable
Documentation/x86/x86_64/uefi.txt:	reboot_type=k	turn off EFI reboot runtime service
Documentation/x86/earlyprintk.txt:     each physical port on the system and rebooting.  Or you can try
Documentation/x86/earlyprintk.txt:     must be the side that does not get rebooted.
Documentation/DocBook/kgdb.tmpl:   <sect1 id="kgdbreboot">
Documentation/DocBook/kgdb.tmpl:   <title>Run time parameter: kgdbreboot</title>
Documentation/DocBook/kgdb.tmpl:   <para> The kgdbreboot feature allows you to change how the debugger
Documentation/DocBook/kgdb.tmpl:   deals with the reboot notification.  You have 3 choices for the
Documentation/DocBook/kgdb.tmpl:   <listitem><para>echo -1 > /sys/module/debug_core/parameters/kgdbreboot</para>
Documentation/DocBook/kgdb.tmpl:   <para>Ignore the reboot notification entirely.</para>
Documentation/DocBook/kgdb.tmpl:   <listitem><para>echo 0 > /sys/module/debug_core/parameters/kgdbreboot</para>
Documentation/DocBook/kgdb.tmpl:   <listitem><para>echo 1 > /sys/module/debug_core/parameters/kgdbreboot</para>
Documentation/DocBook/kgdb.tmpl:   <para>Enter the debugger on reboot notify.</para>
Documentation/DocBook/kgdb.tmpl:  <para>When you are done using kdb you need to consider rebooting the
Documentation/DocBook/media/v4l/media-ioc-device-info.xml:    can vary across reboots or device unplug/replug.</para>
Documentation/DocBook/media/v4l/libv4l.xml:(until reboot) by using a persistent shared memory object.</para>
Documentation/initrd.txt:    even without rebooting with the command
Documentation/scsi/tmscsim.txt:  mappings are found, so auto rebooting may fail.
Documentation/scsi/BusLogic.txt:appropriate, and reboot.
Documentation/scsi/dpti.txt: *      Enabled hba reset from ioctls (allows a FW flash to reboot and use the new
Documentation/scsi/dpti.txt: *         FW without having to reboot)
Documentation/scsi/ChangeLog.ips:                 - Hook into the reboot_notifier to flush the controller
Documentation/scsi/lpfc.txt:  being removed, a switch rebooting, or a device reboot), the driver could
Documentation/networking/arcnet-hardware.txt:        rebooting the computer, and attempting to load ARCETHER at various
Documentation/networking/e100.txt:  NOTE: This setting is not saved across reboots.
Documentation/networking/e100.txt:  WoL will be enabled on the system during the next shut down or reboot. For
Documentation/networking/e100.txt:  loaded when shutting down or rebooting the system.
Documentation/networking/ixgb.txt:      only last only until the next system reboot.
Documentation/networking/ixgb.txt:  NOTE: This setting is not saved across reboots.
Documentation/networking/e1000e.txt:  This setting is not saved across reboots.
Documentation/networking/e1000e.txt:  WoL will be enabled on the system during the next shut down or reboot.
Documentation/networking/e1000e.txt:  loaded when shutting down or rebooting the system.
Documentation/networking/iphase.txt:    e. Install the new built kernel and modules and reboot.
Documentation/networking/ipv6.txt:		A reboot is required to enable IPv6.
Documentation/networking/README.sb1000:on subsequent reboots.
Documentation/networking/README.sb1000:If you do this to /proc/sys/net/ipv4/conf/default/rp_filter on each reboot
Documentation/networking/bonding.txt:reboots, edit the appropriate file (/etc/init.d/boot.local or
Documentation/networking/bonding.txt:and eth1), and have it persist across reboots, edit the appropriate
Documentation/networking/arcnet.txt:messages when you reboot into the new Linux kernel.
Documentation/networking/arcnet.txt:with "arcnet:" and has shown up since the last reboot) in your mail.
Documentation/networking/igb.txt:  This setting is not saved across reboots.
Documentation/networking/igb.txt:  WoL will be enabled on the system during the next shut down or reboot.
Documentation/networking/igb.txt:  loaded when shutting down or rebooting the system.
Documentation/networking/de4x5.txt:    reboot sequences).  Loadable module support  under PCI and EISA has been
Documentation/networking/de4x5.txt:    kernel with the de4x5 configuration turned off and reboot.
Documentation/networking/e1000.txt:  This setting is not saved across reboots.  It can be made permanent if
Documentation/networking/e1000.txt:  WoL will be enabled on the system during the next shut down or reboot.
Documentation/networking/e1000.txt:  loaded when shutting down or rebooting the system.
Documentation/networking/cxgb.txt: Making any of the following system changes will only last until you reboot
Documentation/basic_profiling.txt:Configure with CONFIG_PROFILING=y and CONFIG_OPROFILE=y & reboot on new kernel
Documentation/basic_profiling.txt:A reset is needed to clear old statistics, which survive a reboot.
Documentation/input/joystick.txt:  This way, after the next reboot your joystick will remain calibrated. You
Documentation/usb/gadget_serial.txt:controller driver.  This must be done each time you reboot the gadget
Documentation/usb/proc_usb_info.txt:	  to /etc/fstab.  This will mount usbfs at each reboot.
Documentation/DMA-API.txt:Notice that you can not enable it again at runtime. You have to reboot to do
Documentation/kdump/kdump.txt:the reboot and is accessible to the dump-capture kernel.
Documentation/kdump/kdump.txt:region just before rebooting into the dump-capture kernel.
Documentation/kdump/kdump.txt:described, the system will reboot into the dump-capture kernel if a
Documentation/kdump/kdump.txt:Before analyzing the dump image, you should reboot into a stable kernel.
Documentation/timers/NO_HZ.txt:o	A reboot is required to reconfigure both adaptive idle and RCU
Documentation/sysrq.txt:        128 =  0x80 - allow reboot/poweroff
Documentation/sysrq.txt:'b'     - Will immediately reboot the system without syncing or unmounting
Documentation/sysrq.txt:reboot(b) is good when you're unable to shut down. But you should also
Documentation/sysrq.txt:umount(u), then reboot(b) when my system locks. It's saved me many a fsck.
Documentation/dell_rbu.txt:inform the BIOS to enable the update in the next system reboot.
Documentation/dell_rbu.txt:code which sends the BIOS update request to the BIOS. So on the next reboot
Documentation/bcache.txt:This only has to be done once. The next time you reboot, just reregister all
Documentation/console/console.txt:for rebooting the kernel. For regular users who may want to switch from
Documentation/security/SELinux.txt:	   you are, reboot with selinux disabled
Documentation/cdrom/packet-writing.txt:- Compile and install kernel and modules, reboot.
Documentation/m68k/kernel-options.txt:          rebooting, they can be read under AmigaOS with the tool
Documentation/m68k/kernel-options.txt:off before rebooting, so that OverScan is disabled and TOS boots
Documentation/lockup-watchdogs.txt:to cause the system to reboot automatically after a specified amount
Documentation/acpi/method-customizing.txt:rebuild/reboot is not needed and test result can be got in minutes.
Documentation/acpi/initrd_table_override.txt:# reboot with increased acpi debug level, e.g. boot params:
Documentation/ramoops.txt: # reboot -f
Documentation/ramoops.txt: 0 ffffffff811f9876  ffffffff8101a73a  acpi_reboot <- native_machine_emergency_restart+0xaa/0x1e0
Documentation/ramoops.txt: 0 ffffffff8101a514  ffffffff8101a772  mach_reboot_fixups <- native_machine_emergency_restart+0xe2/0x1e0
Documentation/cpu-hotplug.txt:			constant even if the machine gets rebooted.
Documentation/cpu-hotplug.txt:It's said poweroff/reboot may depend on CPU0 on some machines although I haven't
Documentation/cpu-hotplug.txt:seen any poweroff/reboot failure so far after CPU0 is offline on a few tested
Documentation/robust-futexes.txt:In practice, when e.g. yum is kill -9-ed (or segfaults), a system reboot
Documentation/sysctl/kernel.txt:- reboot-cmd                  [ SPARC only ]
Documentation/sysctl/kernel.txt:Nerve Pinch (tm) will be an immediate reboot, without even
Documentation/sysctl/kernel.txt:waits before rebooting on a panic. When you use the software watchdog,
Documentation/sysctl/kernel.txt:   machine will be rebooted.
Documentation/sysctl/kernel.txt:reboot-cmd: (Sparc only)
Documentation/sysctl/kernel.txt:rebooting. ???
Documentation/blockdev/README.DAC960:standard kernel, run lilo if appropriate, and reboot.
Documentation/blockdev/floppy.txt:	fifo values without rebooting the machine for each test. Note
Documentation/blockdev/ramdisk.txt:are erased on reboot.
Documentation/virtual/uml/UserModeLinux-HOWTO.txt:     10.2 halt and reboot
Documentation/virtual/uml/UserModeLinux-HOWTO.txt:  ration is not stored across host reboots.  So, it's probably a good
Documentation/virtual/uml/UserModeLinux-HOWTO.txt:  o  halt or reboot the machine
Documentation/virtual/uml/UserModeLinux-HOWTO.txt:  o  reboot
Documentation/virtual/uml/UserModeLinux-HOWTO.txt:  10.2.  halt and reboot
Documentation/virtual/uml/UserModeLinux-HOWTO.txt:  up doing is up to /etc/inittab.  Normally, it reboots the machine.
Documentation/virtual/uml/UserModeLinux-HOWTO.txt:  *** Dropping you to a shell; the system will reboot
Documentation/virtual/uml/UserModeLinux-HOWTO.txt:  *** Dropping you to a shell; the system will reboot
Documentation/s390/3270.txt:	haven't already.  Define them before you reboot (reipl):
Documentation/s390/3270.txt:	4. Reboot.  The reboot process scans hardware devices, including
Documentation/s390/3270.txt:	3215 console and then reboot the system.
Documentation/s390/config3270.sh:#               3. Issue "telinit q" or reboot, as appropriate.
Documentation/s390/Debugging390.txt:This is particularly useful for syncing disks unmounting & rebooting
Documentation/s390/3270.ChangeLog:Apr 2002:	Fix 3270 console reboot loop
Documentation/s390/3270.ChangeLog:	* (Belated log entry) Fixed reboot loop if 3270 console,
README:   reboot, and enjoy!
README:   After you've rebooted with the new kernel, do "gdb vmlinux /proc/kcore".
sound/isa/sscape.c:	 * the new upload and tell us that it has rebooted OK. We
sound/isa/wavefront/wavefront_synth.c:	   subsequent ISC2115 reboots (say, caused by module
sound/oss/sb_ess.c: * after rebooting 0x7f already was 0x05, the value of my choice: the BIOS
sound/pci/hda/patch_sigmatel.c:	.reboot_notify = stac_shutup,
sound/pci/hda/hda_controller.c:#include <linux/reboot.h>
sound/pci/hda/hda_controller.c: * reboot notifier for hang-up problem at power-down
sound/pci/hda/hda_controller.c:	struct azx *chip = container_of(nb, struct azx, reboot_notifier);
sound/pci/hda/hda_controller.c:	snd_hda_bus_reboot_notify(chip->bus);
sound/pci/hda/hda_controller.c:	chip->reboot_notifier.notifier_call = azx_halt;
sound/pci/hda/hda_controller.c:	register_reboot_notifier(&chip->reboot_notifier);
sound/pci/hda/hda_controller.c:	if (chip->reboot_notifier.notifier_call)
sound/pci/hda/hda_controller.c:		unregister_reboot_notifier(&chip->reboot_notifier);
sound/pci/hda/hda_codec.c: * snd_hda_bus_reboot_notify - call the reboot notifier of each codec
sound/pci/hda/hda_codec.c:void snd_hda_bus_reboot_notify(struct hda_bus *bus)
sound/pci/hda/hda_codec.c:		    codec->patch_ops.reboot_notify)
sound/pci/hda/hda_codec.c:			codec->patch_ops.reboot_notify(codec);
sound/pci/hda/hda_codec.c:EXPORT_SYMBOL_GPL(snd_hda_bus_reboot_notify);
sound/pci/hda/patch_analog.c:	.reboot_notify = ad198x_shutup,
sound/pci/hda/patch_realtek.c:	.reboot_notify = alc_shutup,
sound/pci/hda/hda_priv.h:	/* reboot notifier (for mysterious hangup problem at power-down) */
sound/pci/hda/hda_priv.h:	struct notifier_block reboot_notifier;
sound/pci/hda/hda_codec.h:	void (*reboot_notify)(struct hda_codec *codec);
sound/pci/hda/hda_codec.h:void snd_hda_bus_reboot_notify(struct hda_bus *bus);
sound/pci/korg1212/korg1212.c:   K1212_DB_RebootCard            = 0xA0, // instructs the card to reboot.
sound/pci/korg1212/korg1212.c:                // the reboot command will not give an acknowledgement.
sound/pci/ymfpci/ymfpci_main.c:	 * the chip again unless reboot.  ACPI bug?
sound/soc/intel/sst-baytrail-ipc.c:	dev_dbg(byt->dev, "wait for dsp reboot\n");
sound/soc/intel/sst-baytrail-ipc.c:	dev_dbg(byt->dev, "dsp rebooted\n");
sound/soc/codecs/sgtl5000.c: * followed by a system reset or a 'reboot' command in Linux
fs/dlm/dlm_internal.h:    panic("DLM:  Record message above and reboot.\n"); \
fs/ocfs2/cluster/quorum.c:#include <linux/reboot.h>
fs/ocfs2/dlmglue.c:		 * reboot.
fs/ocfs2/stack_user.c:#include <linux/reboot.h>
fs/nfs/nfs4_fs.h:	const struct nfs4_state_recovery_ops *reboot_recovery_ops;
fs/nfs/nfs4_fs.h:	NFS_STATE_RECLAIM_REBOOT,	/* OPEN stateid server rebooted */
fs/nfs/nfs4file.c:		 * If nfs_file_fsync_commit detected a server reboot, then
fs/nfs/unlink.c: * reboots.  However, we may not assume a server does so.  (RFC 5661
fs/nfs/nfs4proc.c: * 	reclaim state on the server after a reboot.
fs/nfs/nfs4proc.c:	/* Protect against reboot recovery conflicts */
fs/nfs/nfs4proc.c:static const struct nfs4_state_recovery_ops nfs40_reboot_recovery_ops = {
fs/nfs/nfs4proc.c:static const struct nfs4_state_recovery_ops nfs41_reboot_recovery_ops = {
fs/nfs/nfs4proc.c:	.reboot_recovery_ops = &nfs40_reboot_recovery_ops,
fs/nfs/nfs4proc.c:	.reboot_recovery_ops = &nfs41_reboot_recovery_ops,
fs/nfs/nfs4proc.c:	.reboot_recovery_ops = &nfs41_reboot_recovery_ops,
fs/nfs/file.c:		 * If nfs_file_fsync_commit detected a server reboot, then
fs/nfs/nfs4state.c:static int nfs4_state_mark_reclaim_reboot(struct nfs_client *clp, struct nfs4_state *state)
fs/nfs/nfs4state.c:	/* Don't recover state that expired before the reboot */
fs/nfs/nfs4state.c:	 * recovering after a network partition or a reboot from a
fs/nfs/nfs4state.c:static void nfs4_state_start_reclaim_reboot(struct nfs_client *clp)
fs/nfs/nfs4state.c:	nfs4_state_mark_reclaim_helper(clp, nfs4_state_mark_reclaim_reboot);
fs/nfs/nfs4state.c:static int nfs4_state_clear_reclaim_reboot(struct nfs_client *clp)
fs/nfs/nfs4state.c:static void nfs4_state_end_reclaim_reboot(struct nfs_client *clp)
fs/nfs/nfs4state.c:	if (!nfs4_state_clear_reclaim_reboot(clp))
fs/nfs/nfs4state.c:	ops = clp->cl_mvops->reboot_recovery_ops;
fs/nfs/nfs4state.c:			nfs4_state_end_reclaim_reboot(clp);
fs/nfs/nfs4state.c:			nfs4_state_clear_reclaim_reboot(clp);
fs/nfs/nfs4state.c:			nfs4_state_start_reclaim_reboot(clp);
fs/nfs/nfs4state.c:/* Set NFS4CLNT_LEASE_EXPIRED and reclaim reboot state for all v4.0 errors
fs/nfs/nfs4state.c:		nfs4_state_start_reclaim_reboot(clp);
fs/nfs/nfs4state.c:		clp->cl_mvops->reboot_recovery_ops;
fs/nfs/nfs4state.c:				clp->cl_mvops->reboot_recovery_ops;
fs/nfs/nfs4state.c:static void nfs41_handle_server_reboot(struct nfs_client *clp)
fs/nfs/nfs4state.c:		nfs4_state_start_reclaim_reboot(clp);
fs/nfs/nfs4state.c:		dprintk("%s: server %s rebooted!\n", __func__,
fs/nfs/nfs4state.c:		nfs41_handle_server_reboot(clp);
fs/nfs/nfs4state.c:		/* First recover reboot state... */
fs/nfs/nfs4state.c:			section = "reclaim reboot";
fs/nfs/nfs4state.c:				clp->cl_mvops->reboot_recovery_ops);
fs/nfs/nfs4state.c:			nfs4_state_end_reclaim_reboot(clp);
fs/nfs/delegation.c: * nfs_delegation_reap_unclaimed - reap unclaimed delegations after reboot recovery is done
fs/afs/cmservice.c: * allow the fileserver to quickly find out if the fileserver has been rebooted
fs/afs/afs_cm.h:	CBProbeUuid		= 214,	/* check the client hasn't rebooted */
fs/namespace.c:	 * /reboot - static binary that would close all descriptors and
fs/namespace.c:	 * call reboot(9). Then init(8) could umount root and exec /reboot.
fs/lockd/mon.c: * nsm_monitor - Notify a peer in case we reboot
fs/lockd/mon.c: * the peer to notify in case we reboot.
fs/lockd/mon.c: * when we reboot.
fs/lockd/mon.c: * unique across reboots.  If user space bugs cause a stale cookie to
fs/lockd/mon.c: * lock state if cookies were not unique across reboots.
fs/lockd/mon.c: * nsm_reboot_lookup - match NLMPROC_SM_NOTIFY arguments to an nsm_handle
fs/lockd/mon.c:struct nsm_handle *nsm_reboot_lookup(const struct nlm_reboot *info)
fs/lockd/mon.c:		dprintk("lockd: never saw rebooted peer '%.*s' before\n",
fs/lockd/mon.c:	dprintk("lockd: host %s (%s) rebooted, cnt %d\n",
fs/lockd/clntproc.c:		 * The server has rebooted and appears to be in the grace
fs/lockd/clntproc.c:		/* Did a reclaimer thread notify us of a server reboot? */
fs/lockd/clntproc.c:		/* Check whether or not the server has rebooted */
fs/lockd/clntlock.c:	/* Reset the lock status after a server reboot so we resend */
fs/lockd/clntlock.c:			/* Argh! The server rebooted again! */
fs/lockd/svcproc.c:nlmsvc_proc_sm_notify(struct svc_rqst *rqstp, struct nlm_reboot *argp,
fs/lockd/svcproc.c:	nlm_host_rebooted(argp);
fs/lockd/svcproc.c:  PROC(sm_notify,	reboot,		void,		reboot,	void, 1),
fs/lockd/host.c:					const struct nlm_reboot *info)
fs/lockd/host.c: * nlm_host_rebooted - Release all resources held by rebooted host
fs/lockd/host.c: * We were notified that the specified host has rebooted.  Release
fs/lockd/host.c:void nlm_host_rebooted(const struct nlm_reboot *info)
fs/lockd/host.c:	nsm = nsm_reboot_lookup(info);
fs/lockd/host.c:	/* Mark all hosts tied to this NSM state as having rebooted.
fs/lockd/xdr4.c:nlm4svc_decode_reboot(struct svc_rqst *rqstp, __be32 *p, struct nlm_reboot *argp)
fs/lockd/xdr.c:nlmsvc_decode_reboot(struct svc_rqst *rqstp, __be32 *p, struct nlm_reboot *argp)
fs/lockd/svc4proc.c:nlm4svc_proc_sm_notify(struct svc_rqst *rqstp, struct nlm_reboot *argp,
fs/lockd/svc4proc.c:	nlm_host_rebooted(argp);
fs/lockd/svc4proc.c:  PROC(sm_notify,	reboot,		void,		reboot,	void, 1),
fs/ext3/super.c:                   inconsistencies, to force a fsck at reboot.  But for
fs/ext3/resize.c:			     "forcing fsck on next reboot", group, err);
fs/reiserfs/super.c:		      "reboot after fdisk when it told you to");
fs/reiserfs/inode.c:		 * - on reboot the file either appears truncated properly
fs/proc/Kconfig:	  a recompile of the kernel or reboot of the system.  The primary
fs/pstore/Kconfig:	  interface /dev/pmsg0 to log user space messages. On reboot
fs/pstore/Kconfig:	  ram buffer that can be decoded and dumped after reboot through
fs/ubifs/super.c:		 * Set the "dirty" flag so that if we reboot uncleanly we
fs/ubifs/super.c:			 * reboot, and it should be un-mapped.
fs/ubifs/journal.c: * unclean reboots. Should the unclean reboot happen, the recovery code drops
fs/ubifs/log.c:		 * an unclean reboot, because the target LEB might have been
fs/ubifs/recovery.c:		 * unclean reboot. However, it is possible that the master node
fs/ubifs/recovery.c: * been caused by unclean reboots from which we are attempting to recover
fs/ubifs/recovery.c: * (assume that only the last log LEB can be corrupted by an unclean reboot).
fs/ubifs/replay.c:		 * it is the last, because unclean reboots can possibly corrupt
fs/ubifs/file.c: * an unclean reboot happens. When the file system is mounted next time, the
fs/ubifs/file.c:			 * reboot we may end up with some pages beyond inode
fs/ubifs/ubifs-media.h: * UBIFS_MST_DIRTY: rebooted uncleanly - master node is dirty
fs/ext4/resize.c:			     "forcing fsck on next reboot", group, err);
fs/nfsd/state.h: * from non-volitile storage) upon reboot.
fs/nfsd/nfsctl.c:		 *	- Too long: do you really want reboot recovery
fs/nfsd/nfs4recover.c:		 * reclaim_complete(), records from the previous reboot
fs/nfsd/nfs4recover.c:nfsd4_load_reboot_recovery_data(struct net *net)
fs/nfsd/nfs4recover.c:	status = nfsd4_load_reboot_recovery_data(net);
fs/nfsd/netns.h:	 * reclaim_str_hashtbl[] holds known client info from previous reset/reboot
fs/nfsd/netns.h:	 * used in reboot/reset lease grace period processing
fs/nfsd/nfs4state.c:		/* case 5, client reboot */
fs/nfsd/nfs4state.c:	else /* case 4 (new client) or cases 2, 3 (client reboot): */
fs/nfsd/nfs4state.c:		else /* case 4: client hasn't noticed we rebooted yet? */
fs/nfsd/nfs4state.c:	} else { /* case 3: normal case; new or rebooted client */
tools/lguest/lguest.c:/* Remember the arguments to the program so we can "reboot" */
tools/lguest/lguest.c:		/* ERESTART means that we need to reboot the guest */
tools/lguest/lguest.c:	/* Save the args: we "reboot" by execing ourselves again. */
tools/testing/ktest/examples/kvm.conf:# Guests sometimes get stuck on reboot. We wait 3 seconds after running
tools/testing/ktest/examples/kvm.conf:# the reboot command and then  do a full power-cycle of the guest.
tools/testing/ktest/examples/test.conf:# is booting into. BOX is used for the scripts to reboot and power cycle
tools/testing/ktest/examples/include/defaults.conf:# have directory for the scripts to reboot and power cycle the boxes
tools/testing/ktest/examples/include/defaults.conf:# and ktest will use that kernel to reboot into.
tools/testing/ktest/examples/include/defaults.conf:# To speed up reboots for bisects and patchcheck, instead of
tools/testing/ktest/examples/include/defaults.conf:# finished rebooting and it will be able to continue the tests.
tools/testing/ktest/examples/include/defaults.conf:# something else, ktest will power cycle or reboot the target box
tools/testing/ktest/sample.conf:# A script or command to reboot the box
tools/testing/ktest/sample.conf:# Here is an example to reboot a virtual box on the current host
tools/testing/ktest/sample.conf:# The tool for REBOOT_TYPE = grub2 to set the next reboot kernel
tools/testing/ktest/sample.conf:# (default grub2_reboot)
tools/testing/ktest/sample.conf:#GRUB_REBOOT = grub2_reboot
tools/testing/ktest/sample.conf:# reboot into.
tools/testing/ktest/sample.conf:# (on the target) to use to set up the next reboot to boot the
tools/testing/ktest/sample.conf:# A script to reboot the target into the test kernel
tools/testing/ktest/sample.conf:#   install - build and install, but do nothing else (does not reboot)
tools/testing/ktest/sample.conf:#PRE_TEST = ${SSH} reboot_to_special_kernel
tools/testing/ktest/sample.conf:# Way to reboot the box to the test kernel.
tools/testing/ktest/sample.conf:# and select that target to reboot to the kernel. If this is not
tools/testing/ktest/sample.conf:# after the install, where this one runs just before a reboot.
tools/testing/ktest/sample.conf:# the known good image to reboot safely back into.
tools/testing/ktest/sample.conf:# to reboot to a good known image.
tools/testing/ktest/sample.conf:#   # reboot
tools/testing/ktest/sample.conf:# May need to reboot to get your network back to copy the mymods
tools/testing/ktest/sample.conf:# To speed up between reboots, defining a line that the
tools/testing/ktest/sample.conf:# time here to get pass a reboot. Some machines may not produce
tools/testing/ktest/sample.conf:# any console output for a long time during a reboot. You do
tools/testing/ktest/sample.conf:# the process of rebooting to the test kernel.
tools/testing/ktest/sample.conf:# In between tests, a reboot of the box may occur, and this
tools/testing/ktest/sample.conf:# output. Some machines may not produce a large lag on reboot
tools/testing/ktest/sample.conf:# when rebooting to the test kernel. This sleep time happens
tools/testing/ktest/sample.conf:# another test. If a reboot to the reliable kernel happens,
tools/testing/ktest/sample.conf:# You can speed up reboot times even more by setting REBOOT_SUCCESS_LINE.
tools/testing/ktest/sample.conf:# In case there are isses with rebooting, you can specify this
tools/testing/ktest/sample.conf:# reboot.
tools/testing/ktest/sample.conf:# makes it powercycle immediately after rebooting. Do not define
tools/testing/ktest/sample.conf:# The nice way to reboot the target
tools/testing/ktest/sample.conf:# (default ssh $SSH_USER@$MACHINE reboot)
tools/testing/ktest/sample.conf:#REBOOT = ssh $SSH_USER@$MACHINE reboot
tools/testing/ktest/sample.conf:# and there is no panic or callback, but simply a reboot.
tools/testing/ktest/sample.conf:#   whatever reason. (Can't reboot, want to inspect each iteration)
tools/testing/ktest/ktest.pl:    "REBOOT"			=> "ssh \$SSH_USER\@\$MACHINE reboot",
tools/testing/ktest/ktest.pl:    "GRUB_REBOOT"		=> "grub2-reboot",
tools/testing/ktest/ktest.pl:my $reboot_type;
tools/testing/ktest/ktest.pl:my $reboot_script;
tools/testing/ktest/ktest.pl:my $reboot;
tools/testing/ktest/ktest.pl:my $reboot_on_error;
tools/testing/ktest/ktest.pl:my $reboot_on_success;
tools/testing/ktest/ktest.pl:my $powercycle_after_reboot;
tools/testing/ktest/ktest.pl:my $grub_reboot;
tools/testing/ktest/ktest.pl:my $reboot_success_line;
tools/testing/ktest/ktest.pl:my $reboot_time;
tools/testing/ktest/ktest.pl:# do not force reboots on config problems
tools/testing/ktest/ktest.pl:my $no_reboot = 1;
tools/testing/ktest/ktest.pl:# reboot on success
tools/testing/ktest/ktest.pl:my $reboot_success = 0;
tools/testing/ktest/ktest.pl:    "REBOOT"			=> \$reboot,
tools/testing/ktest/ktest.pl:    "REBOOT_TYPE"		=> \$reboot_type,
tools/testing/ktest/ktest.pl:    "GRUB_REBOOT"		=> \$grub_reboot,
tools/testing/ktest/ktest.pl:    "REBOOT_SCRIPT"		=> \$reboot_script,
tools/testing/ktest/ktest.pl:    "REBOOT_ON_ERROR"		=> \$reboot_on_error,
tools/testing/ktest/ktest.pl:    "REBOOT_ON_SUCCESS"		=> \$reboot_on_success,
tools/testing/ktest/ktest.pl:    "POWERCYCLE_AFTER_REBOOT"	=> \$powercycle_after_reboot,
tools/testing/ktest/ktest.pl:    "REBOOT_SUCCESS_LINE"	=> \$reboot_success_line,
tools/testing/ktest/ktest.pl: A script or command to reboot the box.
tools/testing/ktest/ktest.pl: Here is an example to reboot a virtual box on the current host
tools/testing/ktest/ktest.pl: Way to reboot the box to the test kernel.
tools/testing/ktest/ktest.pl: and select that target to reboot to the kernel. If this is not
tools/testing/ktest/ktest.pl: reboot into.
tools/testing/ktest/ktest.pl: A script to reboot the target into the test kernel
tools/testing/ktest/ktest.pl:    if ($reboot_time) {
tools/testing/ktest/ktest.pl:	show_time($reboot_time);
tools/testing/ktest/ktest.pl:    $reboot_time = 0;
tools/testing/ktest/ktest.pl:sub reboot {
tools/testing/ktest/ktest.pl:	# May contain the reboot success line
tools/testing/ktest/ktest.pl:    # try to reboot normally
tools/testing/ktest/ktest.pl:    if (run_command $reboot) {
tools/testing/ktest/ktest.pl:	if (defined($powercycle_after_reboot)) {
tools/testing/ktest/ktest.pl:	    sleep $powercycle_after_reboot;
tools/testing/ktest/ktest.pl:	    # reboot got stuck?
tools/testing/ktest/ktest.pl:	# Still need to wait for the reboot to finish
tools/testing/ktest/ktest.pl:	wait_for_monitor($time, $reboot_success_line);
tools/testing/ktest/ktest.pl:sub reboot_to_good {
tools/testing/ktest/ktest.pl:    reboot $time;
tools/testing/ktest/ktest.pl:sub do_not_reboot {
tools/testing/ktest/ktest.pl:    return $test_type eq "build" || $no_reboot ||
tools/testing/ktest/ktest.pl:    if ($reboot_on_error && !do_not_reboot) {
tools/testing/ktest/ktest.pl:	reboot_to_good;
tools/testing/ktest/ktest.pl:    # used by reboot (which wants to see a reboot)
tools/testing/ktest/ktest.pl:	# no need to reboot for just building.
tools/testing/ktest/ktest.pl:	if (!do_not_reboot) {
tools/testing/ktest/ktest.pl:	    reboot_to_good $sleep_time;
tools/testing/ktest/ktest.pl:    if ($reboot_type eq "grub2") {
tools/testing/ktest/ktest.pl:    if ($reboot_type ne "grub") {
tools/testing/ktest/ktest.pl:sub reboot_to {
tools/testing/ktest/ktest.pl:    if ($reboot_type eq "grub") {
tools/testing/ktest/ktest.pl:    } elsif ($reboot_type eq "grub2") {
tools/testing/ktest/ktest.pl:	run_ssh "$grub_reboot $grub_number";
tools/testing/ktest/ktest.pl:    } elsif ($reboot_type eq "syslinux") {
tools/testing/ktest/ktest.pl:    } elsif (defined $reboot_script) {
tools/testing/ktest/ktest.pl:	run_command "$reboot_script";
tools/testing/ktest/ktest.pl:    reboot;
tools/testing/ktest/ktest.pl:    reboot_to;
tools/testing/ktest/ktest.pl:    $reboot_time = $end_time - $start_time;
tools/testing/ktest/ktest.pl:# Sometimes the reboot fails, and will hang. We try to ssh to the box
tools/testing/ktest/ktest.pl:# and if we fail, we force another reboot, that should powercycle it.
tools/testing/ktest/ktest.pl:	reboot $sleep_time;
tools/testing/ktest/ktest.pl:    # Failed builds should not reboot the target
tools/testing/ktest/ktest.pl:    my $save_no_reboot = $no_reboot;
tools/testing/ktest/ktest.pl:    $no_reboot = 1;
tools/testing/ktest/ktest.pl:		$no_reboot = $save_no_reboot;
tools/testing/ktest/ktest.pl:    $no_reboot = $save_no_reboot;
tools/testing/ktest/ktest.pl:    # Failed builds should not reboot the target
tools/testing/ktest/ktest.pl:    my $save_no_reboot = $no_reboot;
tools/testing/ktest/ktest.pl:    $no_reboot = 1;
tools/testing/ktest/ktest.pl:	    $no_reboot = $save_no_reboot;
tools/testing/ktest/ktest.pl:    $no_reboot = $save_no_reboot;
tools/testing/ktest/ktest.pl:    if ($i != $opt{"NUM_TESTS"} && !do_not_reboot) {
tools/testing/ktest/ktest.pl:	reboot_to_good $sleep_time;
tools/testing/ktest/ktest.pl:    $reboot_on_error = 0;
tools/testing/ktest/ktest.pl:sub bisect_reboot {
tools/testing/ktest/ktest.pl:    reboot_to_good $bisect_sleep_time;
tools/testing/ktest/ktest.pl:		bisect_reboot;
tools/testing/ktest/ktest.pl:    # reboot the box to a kernel we can ssh to
tools/testing/ktest/ktest.pl:	bisect_reboot;
tools/testing/ktest/ktest.pl:sub patchcheck_reboot {
tools/testing/ktest/ktest.pl:    reboot_to_good $patchcheck_sleep_time;
tools/testing/ktest/ktest.pl:	patchcheck_reboot;
tools/testing/ktest/ktest.pl:	reboot_to_good $sleep_time;
tools/testing/ktest/ktest.pl:    # Do not reboot on failing test options
tools/testing/ktest/ktest.pl:    $no_reboot = 1;
tools/testing/ktest/ktest.pl:    $reboot_success = 0;
tools/testing/ktest/ktest.pl:    $reboot_time = 0;
tools/testing/ktest/ktest.pl:	if ($reboot_type eq "grub") {
tools/testing/ktest/ktest.pl:	} elsif ($reboot_type eq "grub2") {
tools/testing/ktest/ktest.pl:	} elsif ($reboot_type eq "syslinux") {
tools/testing/ktest/ktest.pl:    $no_reboot = 0;
tools/testing/ktest/ktest.pl:    # A test may opt to not reboot the box
tools/testing/ktest/ktest.pl:    if ($reboot_on_success) {
tools/testing/ktest/ktest.pl:	$reboot_success = 1;
tools/testing/ktest/ktest.pl:	$no_reboot = 1;
tools/testing/ktest/ktest.pl:} elsif ($opt{"REBOOT_ON_SUCCESS"} && !do_not_reboot && $reboot_success) {
tools/testing/ktest/ktest.pl:    reboot_to_good;
drivers/pinctrl/qcom/pinctrl-msm.c:#include <linux/reboot.h>
drivers/message/fusion/mptspi.c:#include <linux/reboot.h>	/* notifier code */
drivers/message/fusion/mptfc.c:#include <linux/reboot.h>	/* notifier code */
drivers/message/fusion/mptscsih.c:#include <linux/reboot.h>	/* notifier code */
drivers/message/fusion/mptscsih.c: *	mptscsih_shutdown - reboot notifier
drivers/isdn/hysdn/hysdn_init.c:/* Additionally newer versions may be activated without rebooting.          */
drivers/isdn/hysdn/hysdn_net.c:/* there is non-reboot way to recover if something goes wrong.       */
drivers/isdn/hysdn/hycapi.c:This functions will also be used if the adapter has been rebooted to
drivers/isdn/hysdn/hycapi.c:After an adapter has been rebootet, re-register all applications and
drivers/isdn/hysdn/hycapi.c:Stop CAPI-Output on a card. (e.g. during reboot)
drivers/infiniband/hw/ipath/ipath_diag.c: * driver is unloaded, or in some cases, until the system is rebooted.
drivers/infiniband/hw/ipath/ipath_iba6110.c:		 * is reloaded, probably until reboot, since no
drivers/infiniband/hw/ipath/ipath_driver.c:				      "not usable until reboot\n");
drivers/infiniband/hw/qib/qib_diag.c: * driver is unloaded, or in some cases, until the system is rebooted.
drivers/infiniband/hw/mthca/mthca_reset.c:	 * after the chip reboots.  We skip config space offsets 22
drivers/ata/pata_icside.c:	 * after a soft reboot.  This also disables access to
drivers/ata/ahci_xgene.c: * reboot cycle regression, sometimes the PHY reports link down even if the
drivers/hv/hv_util.c:#include <linux/reboot.h>
drivers/hv/hv_util.c: * Synchronize time with host after reboot, restore, etc.
drivers/hv/hv_util.c: * ICTIMESYNCFLAG_SYNC flag bit indicates reboot, restore events of the VM.
drivers/hv/hv_util.c: * After reboot the flag ICTIMESYNCFLAG_SYNC is included in the first time
drivers/i2c/busses/i2c-i801.c:	/* Some BIOSes don't like it when PEC is enabled at reboot or resume
drivers/cpufreq/s5pv210-cpufreq.c:#include <linux/reboot.h>
drivers/cpufreq/s5pv210-cpufreq.c:static int s5pv210_cpufreq_reboot_notifier_event(struct notifier_block *this,
drivers/cpufreq/s5pv210-cpufreq.c:static struct notifier_block s5pv210_cpufreq_reboot_notifier = {
drivers/cpufreq/s5pv210-cpufreq.c:	.notifier_call = s5pv210_cpufreq_reboot_notifier_event,
drivers/cpufreq/s5pv210-cpufreq.c:	register_reboot_notifier(&s5pv210_cpufreq_reboot_notifier);
drivers/cpufreq/s3c2416-cpufreq.c:#include <linux/reboot.h>
drivers/cpufreq/s3c2416-cpufreq.c:/* frequency to sleep and reboot in
drivers/cpufreq/s3c2416-cpufreq.c: * regulator on reboot
drivers/cpufreq/s3c2416-cpufreq.c:static int s3c2416_cpufreq_reboot_notifier_evt(struct notifier_block *this,
drivers/cpufreq/s3c2416-cpufreq.c:	/* some boards don't reconfigure the regulator on reboot, which
drivers/cpufreq/s3c2416-cpufreq.c:	 * Therefore we always leave the DVS mode on reboot.
drivers/cpufreq/s3c2416-cpufreq.c:		pr_debug("cpufreq: leave dvs on reboot\n");
drivers/cpufreq/s3c2416-cpufreq.c:static struct notifier_block s3c2416_cpufreq_reboot_notifier = {
drivers/cpufreq/s3c2416-cpufreq.c:	.notifier_call = s3c2416_cpufreq_reboot_notifier_evt,
drivers/cpufreq/s3c2416-cpufreq.c:	register_reboot_notifier(&s3c2416_cpufreq_reboot_notifier);
drivers/cpufreq/powernv-cpufreq.c:#include <linux/reboot.h>
drivers/cpufreq/powernv-cpufreq.c:static bool rebooting;
drivers/cpufreq/powernv-cpufreq.c:	if (unlikely(rebooting) && new_index != get_nominal_index())
drivers/cpufreq/powernv-cpufreq.c:static int powernv_cpufreq_reboot_notifier(struct notifier_block *nb,
drivers/cpufreq/powernv-cpufreq.c:	rebooting = true;
drivers/cpufreq/powernv-cpufreq.c:static struct notifier_block powernv_cpufreq_reboot_nb = {
drivers/cpufreq/powernv-cpufreq.c:	.notifier_call = powernv_cpufreq_reboot_notifier,
drivers/cpufreq/powernv-cpufreq.c:	register_reboot_notifier(&powernv_cpufreq_reboot_nb);
drivers/cpufreq/powernv-cpufreq.c:	unregister_reboot_notifier(&powernv_cpufreq_reboot_nb);
drivers/lguest/core.c:	/* Special case: Guest is 'dead' but wants a reboot. */
drivers/power/reset/arm-versatile-reboot.c:#include <linux/reboot.h>
drivers/power/reset/arm-versatile-reboot.c:enum versatile_reboot {
drivers/power/reset/arm-versatile-reboot.c:static enum versatile_reboot versatile_reboot_type;
drivers/power/reset/arm-versatile-reboot.c:static const struct of_device_id versatile_reboot_of_match[] = {
drivers/power/reset/arm-versatile-reboot.c:static int versatile_reboot(struct notifier_block *this, unsigned long mode,
drivers/power/reset/arm-versatile-reboot.c:	switch (versatile_reboot_type) {
drivers/power/reset/arm-versatile-reboot.c:static struct notifier_block versatile_reboot_nb = {
drivers/power/reset/arm-versatile-reboot.c:	.notifier_call = versatile_reboot,
drivers/power/reset/arm-versatile-reboot.c:static int __init versatile_reboot_probe(void)
drivers/power/reset/arm-versatile-reboot.c:	const struct of_device_id *reboot_id;
drivers/power/reset/arm-versatile-reboot.c:	np = of_find_matching_node_and_match(NULL, versatile_reboot_of_match,
drivers/power/reset/arm-versatile-reboot.c:						 &reboot_id);
drivers/power/reset/arm-versatile-reboot.c:	versatile_reboot_type = (enum versatile_reboot)reboot_id->data;
drivers/power/reset/arm-versatile-reboot.c:	err = register_restart_handler(&versatile_reboot_nb);
drivers/power/reset/arm-versatile-reboot.c:	pr_info("versatile reboot driver registered\n");
drivers/power/reset/arm-versatile-reboot.c:device_initcall(versatile_reboot_probe);
drivers/power/reset/hisi-reboot.c:#include <linux/reboot.h>
drivers/power/reset/hisi-reboot.c:static u32 reboot_offset;
drivers/power/reset/hisi-reboot.c:	writel_relaxed(0xdeadbeef, base + reboot_offset);
drivers/power/reset/hisi-reboot.c:static int hisi_reboot_probe(struct platform_device *pdev)
drivers/power/reset/hisi-reboot.c:	if (of_property_read_u32(np, "reboot-offset", &reboot_offset) < 0) {
drivers/power/reset/hisi-reboot.c:		pr_err("failed to find reboot-offset property\n");
drivers/power/reset/hisi-reboot.c:static struct of_device_id hisi_reboot_of_match[] = {
drivers/power/reset/hisi-reboot.c:static struct platform_driver hisi_reboot_driver = {
drivers/power/reset/hisi-reboot.c:	.probe = hisi_reboot_probe,
drivers/power/reset/hisi-reboot.c:		.name = "hisi-reboot",
drivers/power/reset/hisi-reboot.c:		.of_match_table = hisi_reboot_of_match,
drivers/power/reset/hisi-reboot.c:module_platform_driver(hisi_reboot_driver);
drivers/power/reset/ltc2952-poweroff.c:#include <linux/reboot.h>
drivers/power/reset/keystone-reset.c: * TI keystone reboot driver
drivers/power/reset/keystone-reset.c:#include <linux/reboot.h>
drivers/power/reset/vexpress-poweroff.c:#include <linux/reboot.h>
drivers/power/reset/vexpress-poweroff.c:		.compatible = "arm,vexpress-reboot",
drivers/power/reset/st-poweroff.c:#include <linux/reboot.h>
drivers/power/reset/restart-poweroff.c:#include <linux/reboot.h>
drivers/power/reset/restart-poweroff.c:	reboot_mode = REBOOT_HARD;
drivers/power/reset/rmobile-reset.c:#include <linux/reboot.h>
drivers/power/reset/at91-reset.c:#include <linux/reboot.h>
drivers/power/reset/axxia-reset.c:#include <linux/reboot.h>
drivers/power/reset/brcmstb-reboot.c:#include <linux/reboot.h>
drivers/power/reset/brcmstb-reboot.c:	{ .compatible = "brcm,brcmstb-reboot", .data = &reset_bits_40nm },
drivers/power/reset/brcmstb-reboot.c:	{ .compatible = "brcm,bcm7038-reboot", .data = &reset_bits_65nm },
drivers/power/reset/brcmstb-reboot.c:static int brcmstb_reboot_probe(struct platform_device *pdev)
drivers/power/reset/brcmstb-reboot.c:static struct platform_driver brcmstb_reboot_driver = {
drivers/power/reset/brcmstb-reboot.c:	.probe = brcmstb_reboot_probe,
drivers/power/reset/brcmstb-reboot.c:		.name = "brcmstb-reboot",
drivers/power/reset/brcmstb-reboot.c:static int __init brcmstb_reboot_init(void)
drivers/power/reset/brcmstb-reboot.c:	return platform_driver_probe(&brcmstb_reboot_driver,
drivers/power/reset/brcmstb-reboot.c:					brcmstb_reboot_probe);
drivers/power/reset/brcmstb-reboot.c:subsys_initcall(brcmstb_reboot_init);
drivers/power/reset/msm-poweroff.c:#include <linux/reboot.h>
drivers/power/reset/xgene-reboot.c: * This driver provides system reboot functionality for APM X-Gene SoC.
drivers/power/reset/xgene-reboot.c:#include <linux/reboot.h>
drivers/power/reset/xgene-reboot.c:struct xgene_reboot_context {
drivers/power/reset/xgene-reboot.c:	struct xgene_reboot_context *ctx =
drivers/power/reset/xgene-reboot.c:		container_of(this, struct xgene_reboot_context,
drivers/power/reset/xgene-reboot.c:	/* Issue the reboot */
drivers/power/reset/xgene-reboot.c:static int xgene_reboot_probe(struct platform_device *pdev)
drivers/power/reset/xgene-reboot.c:	struct xgene_reboot_context *ctx;
drivers/power/reset/xgene-reboot.c:static struct of_device_id xgene_reboot_of_match[] = {
drivers/power/reset/xgene-reboot.c:	{ .compatible = "apm,xgene-reboot" },
drivers/power/reset/xgene-reboot.c:static struct platform_driver xgene_reboot_driver = {
drivers/power/reset/xgene-reboot.c:	.probe = xgene_reboot_probe,
drivers/power/reset/xgene-reboot.c:		.name = "xgene-reboot",
drivers/power/reset/xgene-reboot.c:		.of_match_table = xgene_reboot_of_match,
drivers/power/reset/xgene-reboot.c:static int __init xgene_reboot_init(void)
drivers/power/reset/xgene-reboot.c:	return platform_driver_register(&xgene_reboot_driver);
drivers/power/reset/xgene-reboot.c:device_initcall(xgene_reboot_init);
drivers/power/reset/Makefile:obj-$(CONFIG_POWER_RESET_BRCMSTB) += brcmstb-reboot.o
drivers/power/reset/Makefile:obj-$(CONFIG_POWER_RESET_HISI) += hisi-reboot.o
drivers/power/reset/Makefile:obj-$(CONFIG_POWER_RESET_VERSATILE) += arm-versatile-reboot.o
drivers/power/reset/Makefile:obj-$(CONFIG_POWER_RESET_XGENE) += xgene-reboot.o
drivers/power/reset/Makefile:obj-$(CONFIG_POWER_RESET_SYSCON) += syscon-reboot.o
drivers/power/reset/gpio-restart.c:#include <linux/reboot.h>
drivers/power/reset/syscon-reboot.c:#include <linux/reboot.h>
drivers/power/reset/syscon-reboot.c:struct syscon_reboot_context {
drivers/power/reset/syscon-reboot.c:	struct syscon_reboot_context *ctx =
drivers/power/reset/syscon-reboot.c:			container_of(this, struct syscon_reboot_context,
drivers/power/reset/syscon-reboot.c:	/* Issue the reboot */
drivers/power/reset/syscon-reboot.c:static int syscon_reboot_probe(struct platform_device *pdev)
drivers/power/reset/syscon-reboot.c:	struct syscon_reboot_context *ctx;
drivers/power/reset/syscon-reboot.c:static struct of_device_id syscon_reboot_of_match[] = {
drivers/power/reset/syscon-reboot.c:	{ .compatible = "syscon-reboot" },
drivers/power/reset/syscon-reboot.c:static struct platform_driver syscon_reboot_driver = {
drivers/power/reset/syscon-reboot.c:	.probe = syscon_reboot_probe,
drivers/power/reset/syscon-reboot.c:		.name = "syscon-reboot",
drivers/power/reset/syscon-reboot.c:		.of_match_table = syscon_reboot_of_match,
drivers/power/reset/syscon-reboot.c:module_platform_driver(syscon_reboot_driver);
drivers/power/reset/Kconfig:	bool "ARM Versatile family reboot driver"
drivers/watchdog/softdog.c:#include <linux/reboot.h>
drivers/watchdog/softdog.c:	"Softdog action, set to 1 to ignore reboots, 0 to reboot (default=0)");
drivers/watchdog/softdog.c:	"Softdog action, set to 1 to panic, 0 to reboot (default=0)");
drivers/watchdog/softdog.c:		pr_crit("Initiating system reboot\n");
drivers/watchdog/softdog.c:	ret = register_reboot_notifier(&softdog_notifier);
drivers/watchdog/softdog.c:		pr_err("cannot register reboot notifier (err=%d)\n", ret);
drivers/watchdog/softdog.c:		unregister_reboot_notifier(&softdog_notifier);
drivers/watchdog/softdog.c:	unregister_reboot_notifier(&softdog_notifier);
drivers/watchdog/meson_wdt.c:#include <linux/reboot.h>
drivers/watchdog/meson_wdt.c:	u32 tc_reboot = MESON_WDT_DC_RESET | MESON_WDT_TC_EN;
drivers/watchdog/meson_wdt.c:		writel(tc_reboot, meson_wdt->wdt_base + MESON_WDT_TC);
drivers/watchdog/nv_tco.h: * power-good (survives reboots), unfortunately this bit is never
drivers/watchdog/cpwd.c:	bool		reboot;
drivers/watchdog/cpwd.c:	prop_val = of_get_property(options, "watchdog-reboot?", NULL);
drivers/watchdog/cpwd.c:	p->reboot = (prop_val ? true : false);
drivers/watchdog/wdt.c: *		Alan Cox	:	Fixed the reboot problem (as noted by
drivers/watchdog/wdt.c:#include <linux/reboot.h>
drivers/watchdog/wdt.c:		pr_crit("Initiating system reboot\n");
drivers/watchdog/wdt.c: *	cascade, into counter 1 which downcounts to reboot. When the counter
drivers/watchdog/wdt.c: *	reboots. In the former case we disable the counters, in the latter
drivers/watchdog/wdt.c: *	off at reboot otherwise the machine will reboot again during memory
drivers/watchdog/wdt.c: *	module in 60 seconds or reboot.
drivers/watchdog/wdt.c:	unregister_reboot_notifier(&wdt_notifier);
drivers/watchdog/wdt.c:	ret = register_reboot_notifier(&wdt_notifier);
drivers/watchdog/wdt.c:		pr_err("cannot register reboot notifier (err=%d)\n", ret);
drivers/watchdog/wdt.c:	unregister_reboot_notifier(&wdt_notifier);
drivers/watchdog/intel_scu_watchdog.h:/* Time from warning to reboot is 2 seconds */
drivers/watchdog/it8712f_wdt.c:#include <linux/reboot.h>
drivers/watchdog/it8712f_wdt.c:	err = register_reboot_notifier(&it8712f_wdt_notifier);
drivers/watchdog/it8712f_wdt.c:		pr_err("unable to register reboot notifier\n");
drivers/watchdog/it8712f_wdt.c:		goto reboot_out;
drivers/watchdog/it8712f_wdt.c:reboot_out:
drivers/watchdog/it8712f_wdt.c:	unregister_reboot_notifier(&it8712f_wdt_notifier);
drivers/watchdog/it8712f_wdt.c:	unregister_reboot_notifier(&it8712f_wdt_notifier);
drivers/watchdog/cpu5wdt.c:	/* watchdog reboot? */
drivers/watchdog/smsc37b787_wdt.c: *	reset the system (causing a reboot) after the timeout occurs.
drivers/watchdog/smsc37b787_wdt.c:#include <linux/reboot.h>
drivers/watchdog/smsc37b787_wdt.c:	ret = register_reboot_notifier(&wb_smsc_wdt_notifier);
drivers/watchdog/smsc37b787_wdt.c:		pr_err("Unable to register reboot notifier err = %d\n", ret);
drivers/watchdog/smsc37b787_wdt.c:	unregister_reboot_notifier(&wb_smsc_wdt_notifier);
drivers/watchdog/smsc37b787_wdt.c:	unregister_reboot_notifier(&wb_smsc_wdt_notifier);
drivers/watchdog/da9063_wdt.c:#include <linux/reboot.h>
drivers/watchdog/via_wdt.c:		pr_crit("I will reboot your machine !\n");
drivers/watchdog/eurotechwdt.c:#include <linux/reboot.h>
drivers/watchdog/eurotechwdt.c:	pr_crit("Initiating system reboot\n");
drivers/watchdog/eurotechwdt.c: * reboots. In the former case we disable the counters, in the latter
drivers/watchdog/eurotechwdt.c: * off at reboot otherwise the machine will reboot again during memory
drivers/watchdog/eurotechwdt.c: * module in 60 seconds or reboot.
drivers/watchdog/eurotechwdt.c:	unregister_reboot_notifier(&eurwdt_notifier);
drivers/watchdog/eurotechwdt.c:	ret = register_reboot_notifier(&eurwdt_notifier);
drivers/watchdog/eurotechwdt.c:		pr_err("can't register reboot notifier (err=%d)\n", ret);
drivers/watchdog/eurotechwdt.c:		goto outreboot;
drivers/watchdog/eurotechwdt.c:		io, irq, (!strcmp("int", ev) ? "int" : "reboot"));
drivers/watchdog/eurotechwdt.c:outreboot:
drivers/watchdog/eurotechwdt.c:	unregister_reboot_notifier(&eurwdt_notifier);
drivers/watchdog/omap_wdt.c:#include <linux/reboot.h>
drivers/watchdog/lantiq_wdt.c:	/* find out if the watchdog caused the last reboot */
drivers/watchdog/pcwd.c: *		"cold reboot sense" entry.
drivers/watchdog/pcwd.c:#include <linux/reboot.h>	/* For kernel_power_off() */
drivers/watchdog/pcwd.c:		pr_info("Previous reboot was caused by the card\n");
drivers/watchdog/pcwd.c:		 * over-temperature condition. And the reboot
drivers/watchdog/pcwd.c:	/* clear the "card caused reboot" flag */
drivers/watchdog/iTCO_vendor_support.c: *	    reboot. When application starts to use watchdog function,
drivers/watchdog/iTCO_vendor_support.c: *	    Note: The system will reboot when Expire Flag is set TWICE.
drivers/watchdog/iTCO_vendor_support.c: *	watchdog timer on these machines, as a result they reboot after five
drivers/watchdog/iTCO_vendor_support.c: *	and does not reload the time. Thus the TCO watchdog does not reboot
drivers/watchdog/iTCO_vendor_support.c: *	second timeout and reboot. Otherwise it simply clears TIMEOUT bit
drivers/watchdog/iTCO_vendor_support.c: *	The only fix found to get the motherboard(s) to reboot is to put
drivers/watchdog/iTCO_vendor_support.c:int iTCO_vendor_check_noreboot_on(void)
drivers/watchdog/iTCO_vendor_support.c:EXPORT_SYMBOL(iTCO_vendor_check_noreboot_on);
drivers/watchdog/dw_wdt.c:#include <linux/reboot.h>
drivers/watchdog/dw_wdt.c:			pr_crit("unexpected close, system will reboot soon\n");
drivers/watchdog/dw_wdt.c:			pr_crit("watchdog cannot be disabled, system will reboot soon\n");
drivers/watchdog/cadence_wdt.c:#include <linux/reboot.h>
drivers/watchdog/cadence_wdt.c: * cdns_wdt_notify_sys - Notifier for reboot or shutdown.
drivers/watchdog/cadence_wdt.c: * This notifier is invoked whenever the system reboot or shutdown occur
drivers/watchdog/cadence_wdt.c:	ret = register_reboot_notifier(&wdt->cdns_wdt_notifier);
drivers/watchdog/cadence_wdt.c:		dev_err(&pdev->dev, "cannot register reboot notifier err=%d)\n",
drivers/watchdog/cadence_wdt.c:	unregister_reboot_notifier(&wdt->cdns_wdt_notifier);
drivers/watchdog/sbc_epx_c3.c:#include <linux/reboot.h>
drivers/watchdog/sbc_epx_c3.c:	ret = register_reboot_notifier(&epx_c3_notifier);
drivers/watchdog/sbc_epx_c3.c:		pr_err("cannot register reboot notifier (err=%d)\n", ret);
drivers/watchdog/sbc_epx_c3.c:		unregister_reboot_notifier(&epx_c3_notifier);
drivers/watchdog/sbc_epx_c3.c:	unregister_reboot_notifier(&epx_c3_notifier);
drivers/watchdog/coh901327_wdt.c:	 * default value immediately, so we HAVE to reboot and get back
drivers/watchdog/coh901327_wdt.c:	 * into the kernel in 30s, or the device will reboot again!
drivers/watchdog/w83627hf_wdt.c:#include <linux/reboot.h>
drivers/watchdog/w83627hf_wdt.c:	ret = register_reboot_notifier(&wdt_notifier);
drivers/watchdog/w83627hf_wdt.c:		pr_err("cannot register reboot notifier (err=%d)\n", ret);
drivers/watchdog/w83627hf_wdt.c:		goto unreg_reboot;
drivers/watchdog/w83627hf_wdt.c:unreg_reboot:
drivers/watchdog/w83627hf_wdt.c:	unregister_reboot_notifier(&wdt_notifier);
drivers/watchdog/w83627hf_wdt.c:	unregister_reboot_notifier(&wdt_notifier);
drivers/watchdog/iTCO_vendor.h:extern int iTCO_vendor_check_noreboot_on(void);
drivers/watchdog/iTCO_vendor.h:#define iTCO_vendor_check_noreboot_on()			1
drivers/watchdog/iTCO_vendor.h:				/* 1=check noreboot; 0=don't check */
drivers/watchdog/gpio_wdt.c:#include <linux/reboot.h>
drivers/watchdog/gpio_wdt.c:		dev_crit(wdd->dev, "Timer expired. System will reboot soon!\n");
drivers/watchdog/gpio_wdt.c:	ret = register_reboot_notifier(&priv->notifier);
drivers/watchdog/gpio_wdt.c:	unregister_reboot_notifier(&priv->notifier);
drivers/watchdog/w83877f_wdt.c:#include <linux/reboot.h>
drivers/watchdog/w83877f_wdt.c:	unregister_reboot_notifier(&wdt_notifier);
drivers/watchdog/w83877f_wdt.c:	rc = register_reboot_notifier(&wdt_notifier);
drivers/watchdog/w83877f_wdt.c:		pr_err("cannot register reboot notifier (err=%d)\n", rc);
drivers/watchdog/w83877f_wdt.c:		goto err_out_reboot;
drivers/watchdog/w83877f_wdt.c:err_out_reboot:
drivers/watchdog/w83877f_wdt.c:	unregister_reboot_notifier(&wdt_notifier);
drivers/watchdog/sb_wdog.c:#include <linux/reboot.h>
drivers/watchdog/sb_wdog.c:	 * register a reboot notifier
drivers/watchdog/sb_wdog.c:	ret = register_reboot_notifier(&sbwdog_notifier);
drivers/watchdog/sb_wdog.c:		pr_err("%s: cannot register reboot notifier (err=%d)\n",
drivers/watchdog/sb_wdog.c:	unregister_reboot_notifier(&sbwdog_notifier);
drivers/watchdog/sb_wdog.c:	unregister_reboot_notifier(&sbwdog_notifier);
drivers/watchdog/wdt977.c:#include <linux/reboot.h>
drivers/watchdog/wdt977.c:MODULE_PARM_DESC(testmode, "Watchdog testmode (1 = no reboot), default=0");
drivers/watchdog/wdt977.c:	rc = register_reboot_notifier(&wdt977_notifier);
drivers/watchdog/wdt977.c:		pr_err("cannot register reboot notifier (err=%d)\n", rc);
drivers/watchdog/wdt977.c:		goto err_out_reboot;
drivers/watchdog/wdt977.c:err_out_reboot:
drivers/watchdog/wdt977.c:	unregister_reboot_notifier(&wdt977_notifier);
drivers/watchdog/wdt977.c:	unregister_reboot_notifier(&wdt977_notifier);
drivers/watchdog/wdt_pci.c: *		Alan Cox	:	Fixed the reboot problem (as noted by
drivers/watchdog/wdt_pci.c:#include <linux/reboot.h>
drivers/watchdog/wdt_pci.c:		pr_crit("Initiating system reboot\n");
drivers/watchdog/wdt_pci.c: *	cascade, into counter 1 which downcounts to reboot. When the counter
drivers/watchdog/wdt_pci.c: *	reboots. In the former case we disable the counters, in the latter
drivers/watchdog/wdt_pci.c: *	off at reboot otherwise the machine will reboot again during memory
drivers/watchdog/wdt_pci.c:	ret = register_reboot_notifier(&wdtpci_notifier);
drivers/watchdog/wdt_pci.c:		pr_err("cannot register reboot notifier (err=%d)\n", ret);
drivers/watchdog/wdt_pci.c:	unregister_reboot_notifier(&wdtpci_notifier);
drivers/watchdog/wdt_pci.c:	unregister_reboot_notifier(&wdtpci_notifier);
drivers/watchdog/pcwd_pci.c:#include <linux/reboot.h>	/* For reboot_notifier stuff */
drivers/watchdog/pcwd_pci.c:	/* Read the time that's left before rebooting */
drivers/watchdog/pcwd_pci.c:		pr_debug("Time left before next reboot: %d\n", *time_left);
drivers/watchdog/pcwd_pci.c:	/* clear the "card caused reboot" flag */
drivers/watchdog/pcwd_pci.c:	ret = register_reboot_notifier(&pcipcwd_notifier);
drivers/watchdog/pcwd_pci.c:		pr_err("cannot register reboot notifier (err=%d)\n", ret);
drivers/watchdog/pcwd_pci.c:			goto err_out_unregister_reboot;
drivers/watchdog/pcwd_pci.c:err_out_unregister_reboot:
drivers/watchdog/pcwd_pci.c:	unregister_reboot_notifier(&pcipcwd_notifier);
drivers/watchdog/pcwd_pci.c:	unregister_reboot_notifier(&pcipcwd_notifier);
drivers/watchdog/pcwd_usb.c:#include <linux/reboot.h>	/* For reboot_notifier stuff */
drivers/watchdog/pcwd_usb.c:	/* Read the time that's left before rebooting */
drivers/watchdog/pcwd_usb.c:	retval = register_reboot_notifier(&usb_pcwd_notifier);
drivers/watchdog/pcwd_usb.c:		pr_err("cannot register reboot notifier (err=%d)\n", retval);
drivers/watchdog/pcwd_usb.c:		goto err_out_unregister_reboot;
drivers/watchdog/pcwd_usb.c:err_out_unregister_reboot:
drivers/watchdog/pcwd_usb.c:	unregister_reboot_notifier(&usb_pcwd_notifier);
drivers/watchdog/pcwd_usb.c:	unregister_reboot_notifier(&usb_pcwd_notifier);
drivers/watchdog/sc520_wdt.c:#include <linux/reboot.h>
drivers/watchdog/sc520_wdt.c:	unregister_reboot_notifier(&wdt_notifier);
drivers/watchdog/sc520_wdt.c:	rc = register_reboot_notifier(&wdt_notifier);
drivers/watchdog/sc520_wdt.c:		pr_err("cannot register reboot notifier (err=%d)\n", rc);
drivers/watchdog/sc520_wdt.c:	unregister_reboot_notifier(&wdt_notifier);
drivers/watchdog/scx200_wdt.c:#include <linux/reboot.h>
drivers/watchdog/scx200_wdt.c:	r = register_reboot_notifier(&scx200_wdt_notifier);
drivers/watchdog/scx200_wdt.c:		pr_err("unable to register reboot notifier\n");
drivers/watchdog/scx200_wdt.c:		unregister_reboot_notifier(&scx200_wdt_notifier);
drivers/watchdog/scx200_wdt.c:	unregister_reboot_notifier(&scx200_wdt_notifier);
drivers/watchdog/w83977f_wdt.c:#include <linux/reboot.h>
drivers/watchdog/w83977f_wdt.c:MODULE_PARM_DESC(testmode, "Watchdog testmode (1 = no reboot), default=0");
drivers/watchdog/w83977f_wdt.c:	rc = register_reboot_notifier(&wdt_notifier);
drivers/watchdog/w83977f_wdt.c:		pr_err("cannot register reboot notifier (err=%d)\n", rc);
drivers/watchdog/w83977f_wdt.c:		goto err_out_reboot;
drivers/watchdog/w83977f_wdt.c:err_out_reboot:
drivers/watchdog/w83977f_wdt.c:	unregister_reboot_notifier(&wdt_notifier);
drivers/watchdog/w83977f_wdt.c:	unregister_reboot_notifier(&wdt_notifier);
drivers/watchdog/octeon-wdt-main.c:			/* Bad news, you are about to reboot. */
drivers/watchdog/octeon-wdt-main.c: *	reboots. In the former case we disable the counters, in the latter
drivers/watchdog/intel_scu_watchdog.c:#include <linux/reboot.h>
drivers/watchdog/intel_scu_watchdog.c:		"A value of 1 means that the driver will reboot"
drivers/watchdog/intel_scu_watchdog.c:/* Forces restart, if force_reboot is set */
drivers/watchdog/intel_scu_watchdog.c:		pr_crit("Initiating system reboot\n");
drivers/watchdog/intel_scu_watchdog.c:	ret = register_reboot_notifier(&watchdog_device.intel_scu_notifier);
drivers/watchdog/intel_scu_watchdog.c:		goto register_reboot_error;
drivers/watchdog/intel_scu_watchdog.c:	unregister_reboot_notifier(&watchdog_device.intel_scu_notifier);
drivers/watchdog/intel_scu_watchdog.c:register_reboot_error:
drivers/watchdog/intel_scu_watchdog.c:	unregister_reboot_notifier(&watchdog_device.intel_scu_notifier);
drivers/watchdog/sbc7240_wdt.c:#include <linux/reboot.h>
drivers/watchdog/sbc7240_wdt.c:	unregister_reboot_notifier(&wdt_notifier);
drivers/watchdog/sbc7240_wdt.c:	rc = register_reboot_notifier(&wdt_notifier);
drivers/watchdog/sbc7240_wdt.c:		pr_err("cannot register reboot notifier (err=%d)\n", rc);
drivers/watchdog/sbc7240_wdt.c:		goto err_out_reboot_notifier;
drivers/watchdog/sbc7240_wdt.c:err_out_reboot_notifier:
drivers/watchdog/sbc7240_wdt.c:	unregister_reboot_notifier(&wdt_notifier);
drivers/watchdog/alim1535_wdt.c:#include <linux/reboot.h>
drivers/watchdog/alim1535_wdt.c:	ret = register_reboot_notifier(&ali_notifier);
drivers/watchdog/alim1535_wdt.c:		pr_err("cannot register reboot notifier (err=%d)\n", ret);
drivers/watchdog/alim1535_wdt.c:		goto unreg_reboot;
drivers/watchdog/alim1535_wdt.c:unreg_reboot:
drivers/watchdog/alim1535_wdt.c:	unregister_reboot_notifier(&ali_notifier);
drivers/watchdog/alim1535_wdt.c:	unregister_reboot_notifier(&ali_notifier);
drivers/watchdog/machzwd.c:#include <linux/reboot.h>
drivers/watchdog/machzwd.c:	ret = register_reboot_notifier(&zf_notifier);
drivers/watchdog/machzwd.c:		pr_err("can't register reboot notifier (err=%d)\n", ret);
drivers/watchdog/machzwd.c:		goto no_reboot;
drivers/watchdog/machzwd.c:	unregister_reboot_notifier(&zf_notifier);
drivers/watchdog/machzwd.c:no_reboot:
drivers/watchdog/machzwd.c:	unregister_reboot_notifier(&zf_notifier);
drivers/watchdog/pnx833x_wdt.c:#include <linux/reboot.h>
drivers/watchdog/pnx833x_wdt.c:	ret = register_reboot_notifier(&pnx833x_wdt_notifier);
drivers/watchdog/pnx833x_wdt.c:		pr_err("cannot register reboot notifier (err=%d)\n", ret);
drivers/watchdog/pnx833x_wdt.c:		unregister_reboot_notifier(&pnx833x_wdt_notifier);
drivers/watchdog/pnx833x_wdt.c:	unregister_reboot_notifier(&pnx833x_wdt_notifier);
drivers/watchdog/mixcomwd.c:#include <linux/reboot.h>
drivers/watchdog/mixcomwd.c:			pr_warn("I quit now, hardware will probably reboot!\n");
drivers/watchdog/wdrtas.c:#include <linux/reboot.h>
drivers/watchdog/wdrtas.c: * include/linux/watchdog.h, indicating why the watchdog rebooted the system
drivers/watchdog/wdrtas.c: * wdrtas_reboot - reboot notifier function
drivers/watchdog/wdrtas.c: * @code: reboot code
drivers/watchdog/wdrtas.c: * wdrtas_reboot stops the watchdog in case of a reboot
drivers/watchdog/wdrtas.c:static int wdrtas_reboot(struct notifier_block *this,
drivers/watchdog/wdrtas.c:	.notifier_call =	wdrtas_reboot,
drivers/watchdog/wdrtas.c: * registers the file handlers and the reboot notifier
drivers/watchdog/wdrtas.c:	if (register_reboot_notifier(&wdrtas_notifier)) {
drivers/watchdog/wdrtas.c:		pr_err("could not register reboot notifier. Terminating watchdog code.\n");
drivers/watchdog/wdrtas.c: * unregisters the file handlers and the reboot notifier
drivers/watchdog/wdrtas.c:	unregister_reboot_notifier(&wdrtas_notifier);
drivers/watchdog/it87_wdt.c:#include <linux/reboot.h>
drivers/watchdog/it87_wdt.c:MODULE_PARM_DESC(testmode, "Watchdog test mode (1 = no reboot), default="
drivers/watchdog/it87_wdt.c:	rc = register_reboot_notifier(&wdt_notifier);
drivers/watchdog/it87_wdt.c:		pr_err("Cannot register reboot notifier (err=%d)\n", rc);
drivers/watchdog/it87_wdt.c:		goto err_out_reboot;
drivers/watchdog/it87_wdt.c:err_out_reboot:
drivers/watchdog/it87_wdt.c:	unregister_reboot_notifier(&wdt_notifier);
drivers/watchdog/it87_wdt.c:	unregister_reboot_notifier(&wdt_notifier);
drivers/watchdog/sbc8360.c:#include <linux/reboot.h>
drivers/watchdog/sbc8360.c:	res = register_reboot_notifier(&sbc8360_notifier);
drivers/watchdog/sbc8360.c:		pr_err("Failed to register reboot notifier\n");
drivers/watchdog/sbc8360.c:		goto out_noreboot;
drivers/watchdog/sbc8360.c:	unregister_reboot_notifier(&sbc8360_notifier);
drivers/watchdog/sbc8360.c:out_noreboot:
drivers/watchdog/sbc8360.c:	unregister_reboot_notifier(&sbc8360_notifier);
drivers/watchdog/wafer5823wdt.c:#include <linux/reboot.h>
drivers/watchdog/wafer5823wdt.c:	ret = register_reboot_notifier(&wafwdt_notifier);
drivers/watchdog/wafer5823wdt.c:		pr_err("cannot register reboot notifier (err=%d)\n", ret);
drivers/watchdog/wafer5823wdt.c:	unregister_reboot_notifier(&wafwdt_notifier);
drivers/watchdog/wafer5823wdt.c:	unregister_reboot_notifier(&wafwdt_notifier);
drivers/watchdog/sc1200wdt.c:#include <linux/reboot.h>
drivers/watchdog/sc1200wdt.c:	ret = register_reboot_notifier(&sc1200wdt_notifier);
drivers/watchdog/sc1200wdt.c:		pr_err("Unable to register reboot notifier err = %d\n", ret);
drivers/watchdog/sc1200wdt.c:	unregister_reboot_notifier(&sc1200wdt_notifier);
drivers/watchdog/sc1200wdt.c:	unregister_reboot_notifier(&sc1200wdt_notifier);
drivers/watchdog/watchdog_dev.c: *	watchdog_get_timeleft: wrapper to get the time left before a reboot
drivers/watchdog/watchdog_dev.c: *	Get the time before a watchdog will reboot (if not pinged).
drivers/watchdog/qcom-wdt.c:#include <linux/reboot.h>
drivers/watchdog/pika_wdt.c:#include <linux/reboot.h>
drivers/watchdog/s3c2410_wdt.c:#include <linux/reboot.h>
drivers/watchdog/s3c2410_wdt.c:MODULE_PARM_DESC(soft_noboot, "Watchdog action, set to 1 to ignore reboots, "
drivers/watchdog/s3c2410_wdt.c:			"0 to reboot (default 0)");
drivers/watchdog/indydog.c:#include <linux/reboot.h>
drivers/watchdog/indydog.c:	ret = register_reboot_notifier(&indydog_notifier);
drivers/watchdog/indydog.c:		pr_err("cannot register reboot notifier (err=%d)\n", ret);
drivers/watchdog/indydog.c:		unregister_reboot_notifier(&indydog_notifier);
drivers/watchdog/indydog.c:	unregister_reboot_notifier(&indydog_notifier);
drivers/watchdog/sunxi_wdt.c:#include <linux/reboot.h>
drivers/watchdog/f71808e_wdt.c:#include <linux/reboot.h>
drivers/watchdog/f71808e_wdt.c:	char		caused_reboot;	/* last reboot was by the watchdog */
drivers/watchdog/f71808e_wdt.c:	status = (watchdog.caused_reboot) ? WDIOF_CARDRESET : 0;
drivers/watchdog/f71808e_wdt.c:	watchdog.caused_reboot = wdt_conf & F71808FG_FLAG_WDTMOUT_STS;
drivers/watchdog/f71808e_wdt.c:	err = register_reboot_notifier(&watchdog_notifier);
drivers/watchdog/f71808e_wdt.c:		goto exit_reboot;
drivers/watchdog/f71808e_wdt.c:exit_reboot:
drivers/watchdog/f71808e_wdt.c:	unregister_reboot_notifier(&watchdog_notifier);
drivers/watchdog/f71808e_wdt.c:	unregister_reboot_notifier(&watchdog_notifier);
drivers/watchdog/wdt285.c:#include <linux/reboot.h>
drivers/watchdog/wdt285.c: * Define this to stop the watchdog actually rebooting the machine.
drivers/watchdog/pc87413_wdt.c:#include <linux/reboot.h>
drivers/watchdog/pc87413_wdt.c: *	reboots. In the former case we disable the counters, in the latter
drivers/watchdog/pc87413_wdt.c: *	off at reboot otherwise the machine will reboot again during memory
drivers/watchdog/pc87413_wdt.c:	ret = register_reboot_notifier(&pc87413_notifier);
drivers/watchdog/pc87413_wdt.c:		pr_err("cannot register reboot notifier (err=%d)\n", ret);
drivers/watchdog/pc87413_wdt.c:		goto reboot_unreg;
drivers/watchdog/pc87413_wdt.c:reboot_unreg:
drivers/watchdog/pc87413_wdt.c:	unregister_reboot_notifier(&pc87413_notifier);
drivers/watchdog/pc87413_wdt.c: *	module in 60 seconds or reboot.
drivers/watchdog/pc87413_wdt.c:	unregister_reboot_notifier(&pc87413_notifier);
drivers/watchdog/geodewdt.c:#include <linux/reboot.h>
drivers/watchdog/sp5100_tco.c:	/* Check to see if last reboot was due to watchdog timeout */
drivers/watchdog/sp5100_tco.c:	pr_info("Last reboot was %striggered by watchdog.\n",
drivers/watchdog/moxart_wdt.c:#include <linux/reboot.h>
drivers/watchdog/at91sam9_wdt.c:#include <linux/reboot.h>
drivers/watchdog/at91sam9_wdt.c:	pr_warn("I quit now, hardware will probably reboot!\n");
drivers/watchdog/i6300esb.c:#define ESB_WDT_REBOOT  (0x01 << 5)   /* Enable reboot on timeout          */
drivers/watchdog/i6300esb.c:	 * timer2 results in a reboot. We set it to not generate
drivers/watchdog/bcm47xx_wdt.c:#include <linux/reboot.h>
drivers/watchdog/bcm47xx_wdt.c:	ret = register_reboot_notifier(&wdt->notifier);
drivers/watchdog/bcm47xx_wdt.c:	unregister_reboot_notifier(&wdt->notifier);
drivers/watchdog/bcm47xx_wdt.c:	unregister_reboot_notifier(&wdt->notifier);
drivers/watchdog/mtk_wdt.c:#include <linux/reboot.h>
drivers/watchdog/nv_tco.c:		pr_err("failed to reset NO_REBOOT flag, reboot disabled by hardware\n");
drivers/watchdog/nv_tco.c:	/* Check to see if last reboot was due to watchdog timeout */
drivers/watchdog/nv_tco.c:	pr_info("Watchdog reboot %sdetected\n",
drivers/watchdog/nv_tco.c:	/* Set the NO_REBOOT bit to prevent later reboots, just for sure */
drivers/watchdog/iTCO_wdt.c:	/* Set the NO_REBOOT bit: this disables reboots */
drivers/watchdog/iTCO_wdt.c:	/* Unset the NO_REBOOT bit: this enables reboots */
drivers/watchdog/iTCO_wdt.c:		pr_err("failed to reset NO_REBOOT flag, reboot disabled by hardware/BIOS\n");
drivers/watchdog/iTCO_wdt.c:	/* Set the NO_REBOOT bit to prevent later reboots, just for sure */
drivers/watchdog/iTCO_wdt.c:		 * needs to count down twice again before rebooting */
drivers/watchdog/iTCO_wdt.c:	/* For TCO v1 the timer counts down twice before rebooting */
drivers/watchdog/iTCO_wdt.c:	if (iTCO_wdt_unset_NO_REBOOT_bit() && iTCO_vendor_check_noreboot_on()) {
drivers/watchdog/iTCO_wdt.c:	/* Set the NO_REBOOT bit to prevent later reboots, just for sure */
drivers/watchdog/Kconfig:	  longer than 1 minute will result in rebooting the machine. This
drivers/watchdog/Kconfig:	  reboot the machine) and a driver for hardware watchdog boards, which
drivers/watchdog/Kconfig:	  also monitor NFS connections and can reboot the machine when the process
drivers/watchdog/Kconfig:	  A software monitoring watchdog. This will fail to reboot your system
drivers/watchdog/Kconfig:	  ARM Primecell SP805 Watchdog timer. This will reboot your system when
drivers/watchdog/Kconfig:	  Watchdog timer embedded into AT91RM9200 chips. This will reboot your
drivers/watchdog/Kconfig:	  reboot your system when the timeout is reached.
drivers/watchdog/Kconfig:	  Watchdog timer embedded into KS8695 processor. This will reboot your
drivers/watchdog/Kconfig:	  Watchdog timer block in the Samsung SoCs. This will reboot
drivers/watchdog/Kconfig:	  reboot your system when timeout is reached.
drivers/watchdog/Kconfig:	  Watchdog timer embedded into AT32AP700x devices. This will reboot
drivers/watchdog/Kconfig:	  it does, it reboots your computer after a certain amount of time.
drivers/watchdog/Kconfig:	  (Total Cost of Ownership) timer is a watchdog timer that will reboot
drivers/watchdog/Kconfig:	  it doesn't freeze, and if it does, it reboots your computer after
drivers/watchdog/Kconfig:	  freeze, and if it does, it reboots your computer after a certain
drivers/watchdog/Kconfig:	  it does, it reboots your computer after a certain amount of time.
drivers/watchdog/Kconfig:	  that will reboot the machine after its second expiration. The
drivers/watchdog/Kconfig:	  NO_REBOOT flag which prevents the watchdog from rebooting the
drivers/watchdog/Kconfig:	  "failed to reset NO_REBOOT flag, reboot disabled by hardware".
drivers/watchdog/Kconfig:	  freeze, and if it does, it reboots your computer after a certain
drivers/watchdog/Kconfig:	  freeze, and if it does, it reboots your computer after a certain
drivers/watchdog/Kconfig:	  watchdog timer that will reboot the machine after its second
drivers/watchdog/Kconfig:	  NO_REBOOT flag which prevents the watchdog from rebooting the
drivers/watchdog/Kconfig:	  "failed to reset NO_REBOOT flag, reboot disabled by hardware".
drivers/watchdog/Kconfig:	  and if it does, it reboots your computer after a certain amount of
drivers/watchdog/Kconfig:	  freeze, and if it does, it reboots your computer after a certain
drivers/watchdog/Kconfig:	  freeze, and if it does, it reboots your computer after a certain
drivers/watchdog/Kconfig:	  and if it does, it reboots your computer after a certain amount of
drivers/watchdog/Kconfig:	  and if it does, it reboots your computer after a certain amount of
drivers/watchdog/Kconfig:	  reboots your computer after a certain amount of time.
drivers/watchdog/Kconfig:	  watchdog timer that will reboot the machine after a 60 second
drivers/watchdog/Kconfig:	  will reboot the machine after a 100 seconds timer expired.
drivers/watchdog/Kconfig:	  watchdog timer that will reboot the machine after a programmable
drivers/watchdog/Kconfig:	  and if it does, it reboots your computer after a certain amount of
drivers/watchdog/Kconfig:	  and if it does, it reboots your computer after a certain amount of
drivers/watchdog/Kconfig:	  and if it does, it reboots your computer after a certain amount of
drivers/watchdog/Kconfig:	  and if it does, it reboots your computer after a certain amount of
drivers/watchdog/mena21_wdt.c:		"Unregistering A21 watchdog driver, board may reboot\n");
drivers/watchdog/alim7101_wdt.c:#include <linux/reboot.h>
drivers/watchdog/alim7101_wdt.c:	 * Cobalt devices have no way of rebooting themselves other
drivers/watchdog/alim7101_wdt.c:	 * watchdog on reboot with no heartbeat.
drivers/watchdog/alim7101_wdt.c:	unregister_reboot_notifier(&wdt_notifier);
drivers/watchdog/alim7101_wdt.c:	rc = register_reboot_notifier(&wdt_notifier);
drivers/watchdog/alim7101_wdt.c:		pr_err("cannot register reboot notifier (err=%d)\n", rc);
drivers/watchdog/alim7101_wdt.c:		goto err_out_reboot;
drivers/watchdog/alim7101_wdt.c:err_out_reboot:
drivers/watchdog/alim7101_wdt.c:	unregister_reboot_notifier(&wdt_notifier);
drivers/watchdog/sbc60xxwdt.c:#include <linux/reboot.h>
drivers/watchdog/sbc60xxwdt.c:	unregister_reboot_notifier(&wdt_notifier);
drivers/watchdog/sbc60xxwdt.c:	rc = register_reboot_notifier(&wdt_notifier);
drivers/watchdog/sbc60xxwdt.c:		pr_err("cannot register reboot notifier (err=%d)\n", rc);
drivers/watchdog/sbc60xxwdt.c:		goto err_out_reboot;
drivers/watchdog/sbc60xxwdt.c:err_out_reboot:
drivers/watchdog/sbc60xxwdt.c:	unregister_reboot_notifier(&wdt_notifier);
drivers/watchdog/imx2_wdt.c:#include <linux/reboot.h>
drivers/watchdog/imx2_wdt.c:	/* ping it every wdog->timeout / 2 seconds to prevent reboot */
drivers/watchdog/imx2_wdt.c:		dev_crit(&pdev->dev, "Device removed: Expect reboot!\n");
drivers/watchdog/imx2_wdt.c:		 * give max timeout before reboot will take place
drivers/watchdog/imx2_wdt.c:		dev_crit(&pdev->dev, "Device shutdown: Expect reboot!\n");
drivers/char/agp/amd64-agp.c:			dev_err(&dev->dev, "consider rebooting with iommu=memaper=2 to get a good aperture\n");
drivers/char/hangcheck-timer.c:#include <linux/reboot.h>
drivers/char/hangcheck-timer.c:static int hangcheck_reboot;  /* Defaults to not reboot */
drivers/char/hangcheck-timer.c:module_param(hangcheck_reboot, int, 0);
drivers/char/hangcheck-timer.c:MODULE_PARM_DESC(hangcheck_reboot, "If nonzero, the machine will reboot when the timer margin is exceeded.");
drivers/char/hangcheck-timer.c:static int __init hangcheck_parse_reboot(char *str)
drivers/char/hangcheck-timer.c:		hangcheck_reboot = par;
drivers/char/hangcheck-timer.c:__setup("hcheck_reboot", hangcheck_parse_reboot);
drivers/char/hangcheck-timer.c:		if (hangcheck_reboot) {
drivers/char/hw_random/n2-drv.c: * If a control node reboots or reloads it's n2rng driver, this won't
drivers/char/tb0219.c:#include <asm/reboot.h>
drivers/char/ipmi/ipmi_watchdog.c:#include <linux/reboot.h>
drivers/char/ipmi/ipmi_watchdog.c:static int wdog_reboot_handler(struct notifier_block *this,
drivers/char/ipmi/ipmi_watchdog.c:	static int reboot_event_handled;
drivers/char/ipmi/ipmi_watchdog.c:	if ((watchdog_user) && (!reboot_event_handled)) {
drivers/char/ipmi/ipmi_watchdog.c:		reboot_event_handled = 1;
drivers/char/ipmi/ipmi_watchdog.c:			/* Set a long timer to let the reboot happens, but
drivers/char/ipmi/ipmi_watchdog.c:			   reboot if it hangs, but only if the watchdog
drivers/char/ipmi/ipmi_watchdog.c:static struct notifier_block wdog_reboot_notifier = {
drivers/char/ipmi/ipmi_watchdog.c:	.notifier_call	= wdog_reboot_handler,
drivers/char/ipmi/ipmi_watchdog.c:	register_reboot_notifier(&wdog_reboot_notifier);
drivers/char/ipmi/ipmi_watchdog.c:		unregister_reboot_notifier(&wdog_reboot_notifier);
drivers/char/ipmi/ipmi_watchdog.c:	unregister_reboot_notifier(&wdog_reboot_notifier);
drivers/char/ipmi/ipmi_poweroff.c: * MontaVista IPMI Poweroff extension to sys_reboot
drivers/char/ipmi/ipmi_poweroff.c:	       " IPMI Powerdown via sys_reboot.\n");
drivers/char/ipmi/ipmi_poweroff.c:MODULE_DESCRIPTION("IPMI Poweroff extension to sys_reboot");
drivers/char/nwbutton.c:static int reboot_count = NUM_PRESSES_REBOOT; /* Number of presses to reboot */
drivers/char/nwbutton.c: * any matching registered function callbacks, initiate reboot, etc.).
drivers/char/nwbutton.c:	if (button_press_count == reboot_count)
drivers/char/nwbutton.c:		kill_cad_pid(SIGINT, 1);	/* Ask init to reboot us */
drivers/char/mbcs.c:#include <linux/reboot.h>
drivers/char/Kconfig:	  shutdown and reboot by pressing the orange button a number of times.
drivers/char/Kconfig:	  time with "insmod button reboot_count=<something>".
drivers/char/Kconfig:	  out to lunch past a certain margin.  It can reboot the system
drivers/xen/manage.c: * Handle extern requests for shutdown, reboot and sysrq
drivers/xen/manage.c:#include <linux/reboot.h>
drivers/xen/manage.c:		/* Don't do it when we are halting/rebooting. */
drivers/xen/manage.c:static void do_reboot(void)
drivers/xen/manage.c:		{ "reboot",	do_reboot   },
drivers/xen/manage.c:static struct notifier_block xen_reboot_nb = {
drivers/xen/manage.c:	register_reboot_notifier(&xen_reboot_nb);
drivers/xen/Kconfig:	  run without rebooting.
drivers/bus/omap_l3_smx.c:		 * do besides rebooting the board. So let's BUG on any
drivers/sbus/char/bbc_envctrl.c:#include <linux/reboot.h>
drivers/sbus/char/envctrl.c:#include <linux/reboot.h>
drivers/staging/wlan-ng/hfa384x_usb.c:			pr_debug("Causality violation: please reboot Universe\n");
drivers/staging/i2o/i2o_block.c:	 * it.  ex: Unmounting a deleted RAID volume at reboot.
drivers/staging/i2o/iop.c:		 * rebooted before we can let the system talk to it. We read
drivers/staging/i2o/iop.c:		 * IOP could not reboot properly.
drivers/staging/i2o/iop.c:		osm_debug("%s: Reset in progress, waiting for reboot...\n",
drivers/staging/olpc_dcon/olpc_dcon.h:	struct notifier_block reboot_nb;
drivers/staging/olpc_dcon/olpc_dcon.c:#include <linux/reboot.h>
drivers/staging/olpc_dcon/olpc_dcon.c:static int dcon_reboot_notify(struct notifier_block *nb,
drivers/staging/olpc_dcon/olpc_dcon.c:	struct dcon_priv *dcon = container_of(nb, struct dcon_priv, reboot_nb);
drivers/staging/olpc_dcon/olpc_dcon.c:	dcon->reboot_nb.notifier_call = dcon_reboot_notify;
drivers/staging/olpc_dcon/olpc_dcon.c:	dcon->reboot_nb.priority = -1;
drivers/staging/olpc_dcon/olpc_dcon.c:	register_reboot_notifier(&dcon->reboot_nb);
drivers/staging/olpc_dcon/olpc_dcon.c:	unregister_reboot_notifier(&dcon->reboot_nb);
drivers/staging/speakup/spkguide.txt:the system is rebooted.
drivers/staging/speakup/spkguide.txt:running.  In other words, it is not necessary to reboot the system
drivers/staging/speakup/spkguide.txt:you reboot, or until you load another keymap.
drivers/staging/unisys/Documentation/overview.txt:partition is rebooted, and the device is reinitialized. This allows
drivers/staging/unisys/Documentation/overview.txt:rebooted using ACPI.
drivers/staging/unisys/Documentation/proc-entries.txt:next reboot will launch the installation and recovery tool. If set to
drivers/staging/lustre/lnet/lnet/api-ni.c:	 * replies and ACKs appearing valid after reboot.
drivers/staging/lustre/lnet/klnds/socklnd/socklnd_cb.c:			LCONSOLE_WARN("Host %pI4h reset our connection while we were sending data; it may have rebooted.\n",
drivers/staging/lustre/lnet/klnds/socklnd/socklnd_cb.c:				CNETERR("A connection with %s (%pI4h:%d) was reset; it may have rebooted.\n",
drivers/staging/lustre/lnet/klnds/socklnd/socklnd.c:		/* Peer rebooted or I've got the wrong protocol version */
drivers/staging/lustre/lnet/klnds/socklnd/socklnd.c:		       "peer rebooted" :
drivers/staging/lustre/include/linux/lnet/lib-types.h: * reboots).  The object cookie only matches one object on that interface
drivers/staging/lustre/lustre/ptlrpc/client.c: * To avoid an unlikely collision between match bits after a client reboot
drivers/staging/lustre/lustre/include/obd_support.h:/* Should be very conservative; must catch the first reconnect after reboot */
drivers/staging/vt6655/device.h:#include <linux/reboot.h>
drivers/staging/vt6655/device_main.c:static int device_notify_reboot(struct notifier_block *, unsigned long event, void *ptr);
drivers/staging/vt6655/device_main.c:	.notifier_call = device_notify_reboot,
drivers/staging/vt6655/device_main.c:		register_reboot_notifier(&device_notifier);
drivers/staging/vt6655/device_main.c:	unregister_reboot_notifier(&device_notifier);
drivers/staging/vt6655/device_main.c:device_notify_reboot(struct notifier_block *nb, unsigned long event, void *p)
drivers/staging/panel/panel.c:#include <linux/reboot.h>
drivers/staging/panel/panel.c:	register_reboot_notifier(&panel_notifier);
drivers/staging/panel/panel.c:	unregister_reboot_notifier(&panel_notifier);
drivers/block/drbd/drbd_req.c:		   During connection handshake, we ensure that the peer was not rebooted. */
drivers/block/drbd/drbd_worker.c:	 * Still the affected node has to be rebooted "soon".
drivers/block/drbd/drbd_receiver.c:		/* Do not allow tl_restart(RESEND) for a rebooted peer. We can only allow this
drivers/block/drbd/drbd_main.c:#include <linux/reboot.h>
drivers/block/rsxx/core.c:#include <linux/reboot.h>
drivers/block/DAC960.c:#include <linux/reboot.h>
drivers/block/cciss.c: * then it will be left alone for the next reboot.  The exception to this
drivers/block/cciss.c: * the next reboot.
drivers/block/cciss.c: * so that mount points are preserved until the next reboot.  This allows
drivers/mtd/maps/nettel.c:#include <linux/reboot.h>
drivers/mtd/maps/nettel.c:static int nettel_reboot_notifier(struct notifier_block *nb, unsigned long val, void *v)
drivers/mtd/maps/nettel.c:	nettel_reboot_notifier, NULL, 0
drivers/mtd/maps/nettel.c:	register_reboot_notifier(&nettel_notifier_block);
drivers/mtd/maps/nettel.c:	unregister_reboot_notifier(&nettel_notifier_block);
drivers/mtd/maps/ixp4xx.c:#include <linux/reboot.h>
drivers/mtd/inftlcore.c:	 * is important, by doing oldest first if we crash/reboot then it
drivers/mtd/devices/pmc551.c: *	cause the system to hang w/ a reboot being the only chance at
drivers/mtd/devices/st_spi_fsm.c:	/* Reset is not properly handled and may result in failure to reboot */
drivers/mtd/devices/docg3.c: * reboot will boot on floor 0, where the IPL is.
drivers/mtd/devices/ms02-nv.c:	 * upon a reboot.  Take paging into account for mapping support.
drivers/mtd/devices/ms02-nv.h: * 0x000000 - 0x0003ff	diagnostic area, destroyed upon a reboot
drivers/mtd/mtdcore.c:#include <linux/reboot.h>
drivers/mtd/mtdcore.c:static int mtd_reboot_notifier(struct notifier_block *n, unsigned long state,
drivers/mtd/mtdcore.c:	mtd = container_of(n, struct mtd_info, reboot_notifier);
drivers/mtd/mtdcore.c:	mtd->_reboot(mtd);
drivers/mtd/mtdcore.c:	 * So we have to check if we've already assigned the reboot notifier.
drivers/mtd/mtdcore.c:	if (mtd->_reboot && !mtd->reboot_notifier.notifier_call) {
drivers/mtd/mtdcore.c:		mtd->reboot_notifier.notifier_call = mtd_reboot_notifier;
drivers/mtd/mtdcore.c:		register_reboot_notifier(&mtd->reboot_notifier);
drivers/mtd/mtdcore.c:	if (master->_reboot)
drivers/mtd/mtdcore.c:		unregister_reboot_notifier(&master->reboot_notifier);
drivers/mtd/nand/gpmi-nand/gpmi-lib.c:	* consecutive reboots. The latter case has not been seen on the MX23
drivers/mtd/nand/nand_base.c:	mtd->_reboot = nand_shutdown;
drivers/mtd/chips/cfi_cmdset_0001.c:#include <linux/reboot.h>
drivers/mtd/chips/cfi_cmdset_0001.c:static int cfi_intelext_reboot (struct notifier_block *, unsigned long, void *);
drivers/mtd/chips/cfi_cmdset_0001.c:	mtd->reboot_notifier.notifier_call = cfi_intelext_reboot;
drivers/mtd/chips/cfi_cmdset_0001.c:	register_reboot_notifier(&mtd->reboot_notifier);
drivers/mtd/chips/cfi_cmdset_0001.c:		/* The machine is rebooting now,so no one can get chip anymore */
drivers/mtd/chips/cfi_cmdset_0001.c:		   flash is accessible for soft reboot. */
drivers/mtd/chips/cfi_cmdset_0001.c:static int cfi_intelext_reboot(struct notifier_block *nb, unsigned long val,
drivers/mtd/chips/cfi_cmdset_0001.c:	mtd = container_of(nb, struct mtd_info, reboot_notifier);
drivers/mtd/chips/cfi_cmdset_0001.c:	unregister_reboot_notifier(&mtd->reboot_notifier);
drivers/mtd/chips/cfi_cmdset_0002.c:#include <linux/reboot.h>
drivers/mtd/chips/cfi_cmdset_0002.c:static int cfi_amdstd_reboot(struct notifier_block *, unsigned long, void *);
drivers/mtd/chips/cfi_cmdset_0002.c:	mtd->reboot_notifier.notifier_call = cfi_amdstd_reboot;
drivers/mtd/chips/cfi_cmdset_0002.c:	register_reboot_notifier(&mtd->reboot_notifier);
drivers/mtd/chips/cfi_cmdset_0002.c:		/* The machine is rebooting */
drivers/mtd/chips/cfi_cmdset_0002.c: * unloading the driver or rebooting.  On some systems, rebooting while
drivers/mtd/chips/cfi_cmdset_0002.c:static int cfi_amdstd_reboot(struct notifier_block *nb, unsigned long val,
drivers/mtd/chips/cfi_cmdset_0002.c:	mtd = container_of(nb, struct mtd_info, reboot_notifier);
drivers/mtd/chips/cfi_cmdset_0002.c:	unregister_reboot_notifier(&mtd->reboot_notifier);
drivers/mtd/ubi/eba.c: * unclean reboot the old contents is preserved. Returns zero in case of
drivers/mtd/ubi/eba.c:				 * This may happen in case of an unclean reboot
drivers/mtd/ubi/vtbl.c: * other. This redundancy guarantees robustness to unclean reboots. The volume
drivers/mtd/ubi/vtbl.c: * LEB 1. This scheme guarantees recoverability from unclean reboots.
drivers/mtd/ubi/vtbl.c: * the update operation was interrupted (e.g. by an unclean reboot) - the
drivers/mtd/ubi/vtbl.c:	 * Due to unclean reboots, the contents of LEB 0 may be lost, but there
drivers/mtd/ubi/vtbl.c:	 * finally, unclean reboots may result in a situation when neither LEB
drivers/mtd/ubi/vtbl.c:			 * reboot while the volume was being removed. Discard
drivers/mtd/ubi/attach.c:		 * but only if no unclean reboots happened.
drivers/mtd/ubi/attach.c:		 * logical eraseblocks because there was an unclean reboot.
drivers/mtd/ubi/attach.c:	 * unclean reboots. However, many of them may indicate some problems
drivers/mtd/ubi/kapi.c: * later on. This function guarantees that in case of an unclean reboot the old
drivers/mtd/ubi/kapi.c: * example, if several logical eraseblocks are un-mapped, and an unclean reboot
drivers/mtd/ubi/kapi.c: * unclean reboot happens after the logical eraseblock has been un-mapped and
drivers/mtd/ubi/kapi.c: * bytes) and be mapped to a physical eraseblock, even if an unclean reboot
drivers/mtd/ubi/ubi-media.h: * so P1 is written to, then an unclean reboot happens. Result - there are 2
drivers/mtd/ubi/ubi-media.h: * to P1, and an unclean reboot happens before P is physically erased, there
drivers/mtd/ubi/ubi-media.h: * number, because the unclean reboot could have happen in the middle of the
drivers/mtd/ubi/ubi-media.h: * the copying). Moreover, the unclean reboot may happen when the erasure of P
drivers/mtd/ubi/ubi.h: * the moment or is damaged because of an unclean reboot.
drivers/video/fbdev/bfin-lq035q1-fb.c:/* Power down all displays on reboot, poweroff or halt */
drivers/video/fbdev/aty/aty128fb.c:	 * know we'll be rebooted, ...
drivers/video/fbdev/aty/atyfb_base.c:#include <linux/reboot.h>
drivers/video/fbdev/aty/atyfb_base.c:static DEFINE_MUTEX(reboot_lock);
drivers/video/fbdev/aty/atyfb_base.c:static struct fb_info *reboot_info;
drivers/video/fbdev/aty/atyfb_base.c:	mutex_lock(&reboot_lock);
drivers/video/fbdev/aty/atyfb_base.c:	if (!reboot_info)
drivers/video/fbdev/aty/atyfb_base.c:		reboot_info = info;
drivers/video/fbdev/aty/atyfb_base.c:	mutex_unlock(&reboot_lock);
drivers/video/fbdev/aty/atyfb_base.c:	mutex_lock(&reboot_lock);
drivers/video/fbdev/aty/atyfb_base.c:	if (reboot_info == info)
drivers/video/fbdev/aty/atyfb_base.c:		reboot_info = NULL;
drivers/video/fbdev/aty/atyfb_base.c:	mutex_unlock(&reboot_lock);
drivers/video/fbdev/aty/atyfb_base.c:static int atyfb_reboot_notify(struct notifier_block *nb,
drivers/video/fbdev/aty/atyfb_base.c:	mutex_lock(&reboot_lock);
drivers/video/fbdev/aty/atyfb_base.c:	if (!reboot_info)
drivers/video/fbdev/aty/atyfb_base.c:	if (!lock_fb_info(reboot_info))
drivers/video/fbdev/aty/atyfb_base.c:	par = reboot_info->par;
drivers/video/fbdev/aty/atyfb_base.c:	 * to the original state to allow successful reboots.
drivers/video/fbdev/aty/atyfb_base.c:	par->pll_ops->set_pll(reboot_info, &par->saved_pll);
drivers/video/fbdev/aty/atyfb_base.c:	unlock_fb_info(reboot_info);
drivers/video/fbdev/aty/atyfb_base.c:	mutex_unlock(&reboot_lock);
drivers/video/fbdev/aty/atyfb_base.c:static struct notifier_block atyfb_reboot_notifier = {
drivers/video/fbdev/aty/atyfb_base.c:	.notifier_call = atyfb_reboot_notify,
drivers/video/fbdev/aty/atyfb_base.c:static const struct dmi_system_id atyfb_reboot_ids[] __initconst = {
drivers/video/fbdev/aty/atyfb_base.c:	if (dmi_check_system(atyfb_reboot_ids)) {
drivers/video/fbdev/aty/atyfb_base.c:		register_reboot_notifier(&atyfb_reboot_notifier);
drivers/video/fbdev/aty/atyfb_base.c:		unregister_reboot_notifier(&atyfb_reboot_notifier);
drivers/video/fbdev/mxsfb.c:	 * Force stop the LCD controller as keeping it running during reboot
drivers/video/backlight/tdo24m.c:/* Power down all displays on reboot, poweroff or halt */
drivers/video/backlight/s6e63m0.c:/* Power down all displays on reboot, poweroff or halt. */
drivers/video/backlight/ld9040.c:/* Power down all displays on reboot, poweroff or halt. */
drivers/video/backlight/ili9320.c:/* Power down all displays on reboot, poweroff or halt */
drivers/video/backlight/ltv350qv.c:/* Power down all displays on reboot, poweroff or halt */
drivers/hwmon/w83793.c:#include <linux/reboot.h>
drivers/hwmon/w83793.c:	unsigned int watchdog_caused_reboot;
drivers/hwmon/w83793.c: * for usage in the reboot notifier callback.
drivers/hwmon/w83793.c:		val = data->watchdog_caused_reboot ? WDIOF_CARDRESET : 0;
drivers/hwmon/w83793.c:	unregister_reboot_notifier(&watchdog_notifier);
drivers/hwmon/w83793.c:	err = register_reboot_notifier(&watchdog_notifier);
drivers/hwmon/w83793.c:			"cannot register reboot notifier (err=%d)\n", err);
drivers/hwmon/w83793.c:	/* Check, if last reboot was caused by watchdog */
drivers/hwmon/w83793.c:	data->watchdog_caused_reboot =
drivers/hwmon/ab8500.c:#include <linux/reboot.h>
drivers/hwmon/abituguru.c:	 * See if there is an uguru there. After a reboot uGuru will hold 0x00
drivers/hwmon/it87.c:					/* PECI (coreboot) */
drivers/parisc/ccio-dma.c:#include <linux/reboot.h>
drivers/parisc/led.c:#include <linux/reboot.h>
drivers/parisc/led.c:   ** called by the reboot notifier chain at shutdown and stops all
drivers/parisc/led.c:	 * register to the reboot notifier chain */
drivers/parisc/led.c:	register_reboot_notifier(&led_notifier);
drivers/parisc/led.c:	unregister_reboot_notifier(&led_notifier);
drivers/parisc/power.c:#include <linux/reboot.h>
drivers/parisc/pdc_stable.c:				"Please check it carefully upon next reboot.\n", __func__);
drivers/tty/ipwireless/main.h:	struct work_struct work_reboot;
drivers/tty/ipwireless/hardware.h:				 void (*reboot_cb) (void *data),
drivers/tty/ipwireless/hardware.h:				 void *reboot_cb_data);
drivers/tty/ipwireless/main.c:static void signalled_reboot_work(struct work_struct *work_reboot)
drivers/tty/ipwireless/main.c:	struct ipw_dev *ipw = container_of(work_reboot, struct ipw_dev,
drivers/tty/ipwireless/main.c:			work_reboot);
drivers/tty/ipwireless/main.c:static void signalled_reboot_callback(void *callback_data)
drivers/tty/ipwireless/main.c:	schedule_work(&ipw->work_reboot);
drivers/tty/ipwireless/main.c:	INIT_WORK(&ipw->work_reboot, signalled_reboot_work);
drivers/tty/ipwireless/main.c:				    ipw->is_v2_card, signalled_reboot_callback,
drivers/tty/ipwireless/hardware.c:	void (*reboot_callback) (void *data);
drivers/tty/ipwireless/hardware.c:	void *reboot_callback_data;
drivers/tty/ipwireless/hardware.c:struct ipw_setup_reboot_msg_ack {
drivers/tty/ipwireless/hardware.c:			       ": Setup not completed - ignoring reboot msg\n");
drivers/tty/ipwireless/hardware.c:			struct ipw_setup_reboot_msg_ack *packet;
drivers/tty/ipwireless/hardware.c:					sizeof(struct ipw_setup_reboot_msg_ack),
drivers/tty/ipwireless/hardware.c:			if (hw->reboot_callback)
drivers/tty/ipwireless/hardware.c:				hw->reboot_callback(hw->reboot_callback_data);
drivers/tty/ipwireless/hardware.c:		void (*reboot_callback) (void *data),
drivers/tty/ipwireless/hardware.c:		void *reboot_callback_data)
drivers/tty/ipwireless/hardware.c:	hw->reboot_callback = reboot_callback;
drivers/tty/ipwireless/hardware.c:	hw->reboot_callback_data = reboot_callback_data;
drivers/tty/sysrq.c:#include <linux/reboot.h>
drivers/tty/sysrq.c:static void sysrq_handle_reboot(int key)
drivers/tty/sysrq.c:static struct sysrq_key_op sysrq_reboot_op = {
drivers/tty/sysrq.c:	.handler	= sysrq_handle_reboot,
drivers/tty/sysrq.c:	.help_msg	= "reboot(b)",
drivers/tty/sysrq.c:	&sysrq_reboot_op,		/* b */
drivers/tty/serial/68328serial.c:#include <linux/reboot.h>
drivers/tty/serial/sunsab.c:	 * reboot or shutdown.  This needs to be investigated further,
drivers/tty/serial/ifx6x60.c:#include <linux/reboot.h>
drivers/tty/serial/ifx6x60.c:static int ifx_modem_reboot_callback(struct notifier_block *nfb,
drivers/tty/serial/ifx6x60.c:static struct notifier_block ifx_modem_reboot_notifier_block = {
drivers/tty/serial/ifx6x60.c:	.notifier_call = ifx_modem_reboot_callback,
drivers/tty/serial/ifx6x60.c:static int ifx_modem_reboot_callback(struct notifier_block *nfb,
drivers/tty/serial/ifx6x60.c:	unregister_reboot_notifier(&ifx_modem_reboot_notifier_block);
drivers/tty/serial/ifx6x60.c:	result = register_reboot_notifier(&ifx_modem_reboot_notifier_block);
drivers/tty/serial/ifx6x60.c:		pr_err("%s: register ifx modem reboot notifier failed(%d)",
drivers/tty/vt/keyboard.c:#include <linux/reboot.h>
drivers/media/tuners/si2157.c:	/* reboot the tuner with new firmware? */
drivers/media/pci/ivtv/ivtv-driver.h:   rebooted. */
drivers/media/pci/saa7164/saa7164-fw.c:			"%s() Download flag already set, please reboot\n",
drivers/media/pci/saa7134/saa7134-cards.c:		/* watch TV without software reboot. For solve this problem */
drivers/media/usb/dvb-usb/cxusb.c:	/* Drain USB pipes to avoid hang after reboot */
drivers/media/platform/coda/coda-common.c:	 * Data in this SRAM survives a reboot.
drivers/firmware/dell_rbu.c: * after a reboot.
drivers/firmware/dcdbas.c:#include <linux/reboot.h>
drivers/firmware/dcdbas.c: * dcdbas_reboot_notify: handle reboot notification for host control
drivers/firmware/dcdbas.c:static int dcdbas_reboot_notify(struct notifier_block *nb, unsigned long code,
drivers/firmware/dcdbas.c:static struct notifier_block dcdbas_reboot_nb = {
drivers/firmware/dcdbas.c:	.notifier_call = dcdbas_reboot_notify,
drivers/firmware/dcdbas.c:	register_reboot_notifier(&dcdbas_reboot_nb);
drivers/firmware/dcdbas.c:	unregister_reboot_notifier(&dcdbas_reboot_nb);
drivers/firmware/dcdbas.c:	unregister_reboot_notifier(&dcdbas_reboot_nb);
drivers/firmware/efi/reboot.c:#include <linux/reboot.h>
drivers/firmware/efi/reboot.c:int efi_reboot_quirk_mode = -1;
drivers/firmware/efi/reboot.c:void efi_reboot(enum reboot_mode reboot_mode, const char *__unused)
drivers/firmware/efi/reboot.c:	switch (reboot_mode) {
drivers/firmware/efi/reboot.c:	if (efi_reboot_quirk_mode != -1)
drivers/firmware/efi/reboot.c:		efi_mode = efi_reboot_quirk_mode;
drivers/firmware/efi/libstub/arm-stub.c:static int efi_secureboot_enabled(efi_system_table_t *sys_table_arg)
drivers/firmware/efi/libstub/arm-stub.c:	if (efi_secureboot_enabled(sys_table)) {
drivers/firmware/efi/Makefile:obj-$(CONFIG_EFI)			+= efi.o vars.o reboot.o
drivers/firmware/efi/cper.c: * CPER record ID need to be unique even after reboot, because record
drivers/firmware/google/gsmi.c:#include <linux/reboot.h>
drivers/firmware/google/gsmi.c:static int gsmi_reboot_callback(struct notifier_block *nb,
drivers/firmware/google/gsmi.c:static struct notifier_block gsmi_reboot_notifier = {
drivers/firmware/google/gsmi.c:	.notifier_call = gsmi_reboot_callback
drivers/firmware/google/gsmi.c:	register_reboot_notifier(&gsmi_reboot_notifier);
drivers/firmware/google/gsmi.c:	unregister_reboot_notifier(&gsmi_reboot_notifier);
drivers/gpu/drm/vmwgfx/svga_reg.h: * number of FIFO registers won't change without a reboot.
drivers/gpu/drm/drm_fb_helper.c:	 * if the kernel should reboot before panic messages can be seen.
drivers/gpu/drm/i915/intel_dp.c:#include <linux/reboot.h>
drivers/gpu/drm/i915/intel_dp.c:			unregister_reboot_notifier(&intel_dp->edp_notifier);
drivers/gpu/drm/i915/intel_dp.c:		register_reboot_notifier(&intel_dp->edp_notifier);
drivers/gpu/drm/i915/i915_drv.c:	 *                            (2) after rebooting, before restoring
drivers/gpu/drm/i915/i915_drv.c:	 *                            image, before rebooting [PMSG_HIBERNATE]
drivers/gpu/drm/i915/i915_drv.c:	 * @restore, @restore_early : called after rebooting and restoring the
drivers/gpu/drm/nouveau/include/nvif/os.h:#include <linux/reboot.h>
drivers/pci/host/pci-imx6.c:	/* bring down link, so bootloader gets clean state in case of reboot */
drivers/pci/hotplug/cpqphp.h:#define msg_unable_to_save	"unable to store PCI hot plug add resource information. This system must be rebooted before adding any PCI devices.\n"
drivers/pci/pci-driver.c:	 * If this is a kexec reboot, turn off Bus Master bit on the
drivers/pci/pci-driver.c:	 * If it is not a kexec reboot, firmware will hit the PCI
drivers/pci/irq.c:		pci_note_irq_problem(pdev, "Potential ACPI misrouting please reboot with acpi=noirq");
drivers/scsi/be2iscsi/be_main.c:#include <linux/reboot.h>
drivers/scsi/megaraid.c:#include <linux/reboot.h>
drivers/scsi/ips.c:/*          - Hook into the reboot_notifier to flush the controller cache    */
drivers/scsi/ips.c:#include <linux/reboot.h>
drivers/scsi/ips.c:/*   Perform cleanup when the system reboots                                */
drivers/scsi/ips.c:	register_reboot_notifier(&ips_notifier);
drivers/scsi/ips.c:	unregister_reboot_notifier(&ips_notifier);
drivers/scsi/dpt_i2o.c:#include <linux/reboot.h>
drivers/scsi/3w-xxxx.c:#include <linux/reboot.h>
drivers/scsi/qla2xxx/qla_nx.c:		/* skipping cold reboot MAGIC */
drivers/scsi/qla2xxx/qla_isr.c:				    "state, reboot required.\n");
drivers/scsi/gdth.c:#include <linux/reboot.h>
drivers/scsi/gdth.c:	register_reboot_notifier(&gdth_notifier);
drivers/scsi/gdth.c:	unregister_reboot_notifier(&gdth_notifier);
drivers/scsi/mesh.c:#include <linux/reboot.h>
drivers/scsi/mesh.c: * CDROMs), and reboot to MacOS, it gets confused, poor thing.
drivers/scsi/mesh.c: * So, on reboot we reset the SCSI bus.
drivers/scsi/mesh.c:	 * at reboot if the bus was set to synchronous mode already
drivers/scsi/bfa/bfad.c:	port_cfg.preboot_vp  = BFA_TRUE;
drivers/scsi/bfa/bfa_fcs_lport.c:	vport_cfg->preboot_vp = BFA_FALSE;
drivers/scsi/bfa/bfa_fcs_lport.c:	vport->lport.port_cfg.preboot_vp = BFA_TRUE;
drivers/scsi/bfa/bfa_fcs_lport.c:	if (vport && (vport->lport.port_cfg.preboot_vp == BFA_TRUE))
drivers/scsi/bfa/bfa_fcs_lport.c:	if (vport->lport.port_cfg.preboot_vp)
drivers/scsi/bfa/bfa_defs.h:	BFA_PREBOOT_BOOTLUN_MAX = 8,    /*  maximum preboot lun per IOC */
drivers/scsi/bfa/bfad_attr.c:			port_cfg.preboot_vp =
drivers/scsi/bfa/bfad_attr.c:				vp->fcs_vport.lport.port_cfg.preboot_vp;
drivers/scsi/bfa/bfad_bsg.c:bfad_iocmd_preboot_query(struct bfad_s *bfad, void *cmd)
drivers/scsi/bfa/bfad_bsg.c:	struct bfa_bsg_preboot_s *iocmd = (struct bfa_bsg_preboot_s *)cmd;
drivers/scsi/bfa/bfad_bsg.c:		rc = bfad_iocmd_preboot_query(bfad, iocmd);
drivers/scsi/bfa/bfa_defs_fcs.h:	bfa_boolean_t   preboot_vp;  /*  vport created from PBC */
drivers/scsi/bfa/bfad_bsg.h:struct bfa_bsg_preboot_s {
drivers/scsi/isci/probe_roms.h:	uint8_t preboot_source;
drivers/scsi/ipr.c:#include <linux/reboot.h>
drivers/scsi/ipr.c: * This function is invoked upon system shutdown/reboot. It will issue
drivers/scsi/ipr.c:	register_reboot_notifier(&ipr_notifier);
drivers/scsi/ipr.c:	unregister_reboot_notifier(&ipr_notifier);
drivers/scsi/qla4xxx/ql4_nx.c:		/* skipping cold reboot MAGIC */
drivers/scsi/qla4xxx/ql4_init.c:	 * connections use the same TCP ports after each reboot,
drivers/scsi/3w-9xxx.c:#include <linux/reboot.h>
drivers/scsi/mpt2sas/mpt2sas_base.c:		      "Please reboot the system and ensure that the correct"
drivers/scsi/3w-sas.c:#include <linux/reboot.h>
drivers/scsi/mpt3sas/mpt3sas_base.c:		      "Please reboot the system and ensure that the correct"
drivers/scsi/arcmsr/arcmsr_hba.c:#include <linux/reboot.h>
drivers/net/appletalk/Kconfig:	  module so you can restart your AppleTalk stack without rebooting
drivers/net/fddi/defxx.c: *		Linux.  This routine would be called during "reboot" or
drivers/net/fddi/defxx.c: *		state before a warm reboot occurs.  To be really safe, the user
drivers/net/wimax/i2400m/driver.c:		 "recognized as the value the device sends as a reboot "
drivers/net/wimax/i2400m/driver.c: * The device has rebooted; fix up the device and the driver
drivers/net/wimax/i2400m/driver.c:		dev_err(dev, "device rebooted somewhere else?\n");
drivers/net/wimax/i2400m/usb.c: * The device will send a reboot barker in the notification endpoint
drivers/net/wimax/i2400m/fw.c: * system, when it crashes and when you ask it to reboot. There are
drivers/net/wimax/i2400m/fw.c: * reboot barker (4 le32 words with the same value). We ack it by
drivers/net/wimax/i2400m/fw.c: * reboot ack barker (4 le32 words with value I2400M_ACK_BARKER) and
drivers/net/wimax/i2400m/fw.c: * waiting for a reboot barker, that means maybe we are already in
drivers/net/wimax/i2400m/fw.c: * boot mode, so we send a reboot barker.
drivers/net/wimax/i2400m/fw.c:		goto error_reboot;
drivers/net/wimax/i2400m/fw.c:		d_printf(3, dev, "boot-mode cmd %d: HW reboot ack barker\n",
drivers/net/wimax/i2400m/fw.c:		goto error_reboot_ack;
drivers/net/wimax/i2400m/fw.c:error_reboot_ack:
drivers/net/wimax/i2400m/fw.c:error_reboot:
drivers/net/wimax/i2400m/fw.c: *     -ERESTARTSYS  The device has rebooted
drivers/net/wimax/i2400m/fw.c: * Indicate if the device emitted a reboot barker that indicates
drivers/net/wimax/i2400m/fw.c: *      I2400M_BRI_SOFT: a reboot barker has been seen
drivers/net/wimax/i2400m/fw.c: *      I2400M_BRI_NO_REBOOT: Don't send a reboot command, but wait
drivers/net/wimax/i2400m/fw.c: *          for a reboot barker notification. This is a one shot; if
drivers/net/wimax/i2400m/fw.c: *          the state machine needs to send a reboot command it will.
drivers/net/wimax/i2400m/fw.c: * a. (1) send a reboot command and (2) get a reboot barker
drivers/net/wimax/i2400m/fw.c: * b. (1) echo/ack the reboot sending the reboot barker back and (2)
drivers/net/wimax/i2400m/fw.c: * the reboot barker (the device might send different ones depending
drivers/net/wimax/i2400m/fw.c: * on its EEPROM config) and once the device reboots and waits for the
drivers/net/wimax/i2400m/fw.c: * echo/ack reboot barker being sent back, it doesn't understand
drivers/net/wimax/i2400m/fw.c:		goto do_reboot_ack;
drivers/net/wimax/i2400m/fw.c:do_reboot:
drivers/net/wimax/i2400m/fw.c:	d_printf(4, dev, "device reboot: reboot command [%d # left]\n",
drivers/net/wimax/i2400m/fw.c:		d_printf(4, dev, "device reboot: got reboot barker\n");
drivers/net/wimax/i2400m/fw.c:		d_printf(4, dev, "device reboot: got ack barker - whatever\n");
drivers/net/wimax/i2400m/fw.c:		goto do_reboot;
drivers/net/wimax/i2400m/fw.c:			dev_err(dev, "device boot: reboot barker timed out, "
drivers/net/wimax/i2400m/fw.c:			goto do_reboot_ack;
drivers/net/wimax/i2400m/fw.c:					 "#%d/%08x; rebooting j.i.c.\n",
drivers/net/wimax/i2400m/fw.c:				goto do_reboot;
drivers/net/wimax/i2400m/fw.c:		dev_err(dev, "device reboot: error %d while waiting "
drivers/net/wimax/i2400m/fw.c:			"for reboot barker - rebooting\n", result);
drivers/net/wimax/i2400m/fw.c:		goto do_reboot;
drivers/net/wimax/i2400m/fw.c:	 * hence the cast. _bm_cmd() will catch the reboot ack
drivers/net/wimax/i2400m/fw.c:do_reboot_ack:
drivers/net/wimax/i2400m/fw.c:	d_printf(4, dev, "device reboot ack: sending ack [%d # left]\n", count);
drivers/net/wimax/i2400m/fw.c:		d_printf(4, dev, "reboot ack: got reboot barker - retrying\n");
drivers/net/wimax/i2400m/fw.c:		goto do_reboot_ack;
drivers/net/wimax/i2400m/fw.c:		d_printf(4, dev, "reboot ack: got ack barker - good\n");
drivers/net/wimax/i2400m/fw.c:			d_printf(4, dev, "reboot ack timedout: retrying\n");
drivers/net/wimax/i2400m/fw.c:			goto do_reboot_ack;
drivers/net/wimax/i2400m/fw.c:			dev_err(dev, "reboot ack timedout too long: "
drivers/net/wimax/i2400m/fw.c:				"trying reboot\n");
drivers/net/wimax/i2400m/fw.c:			goto do_reboot;
drivers/net/wimax/i2400m/fw.c:		dev_err(dev, "device reboot ack: error %d while waiting for "
drivers/net/wimax/i2400m/fw.c:			"reboot ack barker - rebooting\n", result);
drivers/net/wimax/i2400m/fw.c:		goto do_reboot;
drivers/net/wimax/i2400m/fw.c:	d_printf(2, dev, "device reboot ack: got ack barker - boot done\n");
drivers/net/wimax/i2400m/fw.c:	dev_err(dev, "Timed out waiting for reboot ack\n");
drivers/net/wimax/i2400m/fw.c: *     rebooted.
drivers/net/wimax/i2400m/fw.c:hw_reboot:
drivers/net/wimax/i2400m/fw.c:		dev_err(dev, "device rebooted too many times, aborting\n");
drivers/net/wimax/i2400m/fw.c:		goto error_too_many_reboots;
drivers/net/wimax/i2400m/fw.c:	 * rebooted, so it has to be passed along.
drivers/net/wimax/i2400m/fw.c:		goto error_dev_rebooted;
drivers/net/wimax/i2400m/fw.c:		goto error_dev_rebooted;
drivers/net/wimax/i2400m/fw.c:		goto error_dev_rebooted;
drivers/net/wimax/i2400m/fw.c:error_too_many_reboots:
drivers/net/wimax/i2400m/fw.c:error_dev_rebooted:
drivers/net/wimax/i2400m/fw.c:	dev_err(dev, "device rebooted, %d tries left\n", count);
drivers/net/wimax/i2400m/fw.c:	goto hw_reboot;
drivers/net/wimax/i2400m/usb-notif.c: * we act to either reinitialize the device after a reboot or to
drivers/net/wimax/i2400m/usb-notif.c: *   - a reboot barker, we do a bootstrap (the device has reseted).
drivers/net/wimax/i2400m/usb-notif.c:		ret = i2400m_dev_reset_handle(i2400m, "device rebooted");
drivers/net/wimax/i2400m/i2400m.h: *        and off, handling the device reboots/resets and a few simple
drivers/net/wimax/i2400m/i2400m.h: *     sequence; this way if the device reboots in the middle, we
drivers/net/wimax/i2400m/i2400m.h: *	all the device reboot events detected can be still handled properly
drivers/net/wimax/i2400m/i2400m.h: * @I2400M_BRI_SOFT: The device rebooted already and a reboot
drivers/net/wimax/i2400m/i2400m.h: * @I2400M_BRI_NO_REBOOT: Do not reboot the device and proceed
drivers/net/wimax/i2400m/i2400m.h: *     directly to wait for a reboot barker from the device.
drivers/net/arcnet/arcnet.c: * non-reboot way to recover if something goes wrong.
drivers/net/wan/dscc4.c: * again is still a mystery. If RDO happens, plan a reboot. More details
drivers/net/wan/dscc4.c: * rebooting.
drivers/net/wan/dscc4.c:	 * the HDLC configuration without rebooting but at least the ports
drivers/net/wireless/ath/carl9170/usb.c:	err = carl9170_reboot(ar);
drivers/net/wireless/ath/carl9170/usb.c:	/* The reboot procedure can take quite a while to complete. */
drivers/net/wireless/ath/carl9170/usb.c:		carl9170_reboot(ar);
drivers/net/wireless/ath/carl9170/cmd.h:int carl9170_reboot(struct ar9170 *ar);
drivers/net/wireless/ath/carl9170/cmd.c:int carl9170_reboot(struct ar9170 *ar)
drivers/net/wireless/ath/ath9k/hif_usb.c:static void ath9k_hif_usb_reboot(struct usb_device *udev)
drivers/net/wireless/ath/ath9k/hif_usb.c:	u32 reboot_cmd = 0xffffffff;
drivers/net/wireless/ath/ath9k/hif_usb.c:	buf = kmemdup(&reboot_cmd, 4, GFP_KERNEL);
drivers/net/wireless/ath/ath9k/hif_usb.c:		dev_err(&udev->dev, "ath9k_htc: USB reboot failed\n");
drivers/net/wireless/ath/ath9k/hif_usb.c:		ath9k_hif_usb_reboot(udev);
drivers/net/wireless/ath/ath6kl/usb.c:	/* Delay to wait for the target to reboot */
drivers/net/wireless/ath/ath6kl/init.c:		 * Most likely USB target is in odd state after reboot and
drivers/net/wireless/ath/ath10k/htt_rx.c:			/* FIXME: It's probably a good idea to reboot the
drivers/net/wireless/rtlwifi/rtl8192se/hw.c:	/* For warm reboot NIC disappera bug. */
drivers/net/wireless/rtlwifi/rtl8192se/hw.c:	/* For warm reboot NIC disappera bug. */
drivers/net/wireless/brcm80211/brcmfmac/usb.c:#define DL_REBOOT	4	/* reboot the device in 2 seconds */
drivers/net/wireless/ti/wlcore/main.c:	/* reboot the chipset */
drivers/net/wireless/airo.c:	//Allow for the ap being rebooted - if it is then use the next 
drivers/net/wireless/iwlwifi/dvm/commands.h: * notification that the driver will receive after rebooting uCode;
drivers/net/wireless/prism54/islpci_dev.c:	/* wait a while for the device to reboot */
drivers/net/wireless/iwlegacy/commands.h: * rebooting uCode; the "initialize" alive is indicated by subtype field == 9.
drivers/net/wireless/iwlegacy/commands.h: * notification that the driver will receive after rebooting uCode;
drivers/net/xen-netfront.c:		 * situation to the system controller to reboot the backend.
drivers/net/cris/eth_v10.c: * there is non-reboot way to recover if something goes wrong.
drivers/net/ethernet/neterion/vxge/vxge-main.c:	       "hard reset before using, thus requiring a system reboot or a "
drivers/net/ethernet/sfc/enum.h: * @RESET_TYPE_MC_FAILURE: MC reboot/assertion
drivers/net/ethernet/sfc/mcdi.c:/* A reboot/assertion causes the MCDI status word to be set after the
drivers/net/ethernet/sfc/mcdi.c: * command word is set or a REBOOT event is sent. If we notice a reboot
drivers/net/ethernet/sfc/mcdi.c:	(void) efx_mcdi_poll_reboot(efx);
drivers/net/ethernet/sfc/mcdi.c:		netif_err(efx, hw, efx->net_dev, "MC rebooted\n");
drivers/net/ethernet/sfc/mcdi.c:	/* Check for a reboot atomically with respect to efx_mcdi_copyout() */
drivers/net/ethernet/sfc/mcdi.c:	rc = efx_mcdi_poll_reboot(efx);
drivers/net/ethernet/sfc/mcdi.c:/* Test and clear MC-rebooted flag for this port/function; reset
drivers/net/ethernet/sfc/mcdi.c:int efx_mcdi_poll_reboot(struct efx_nic *efx)
drivers/net/ethernet/sfc/mcdi.c:	return efx->type->mcdi_poll_reboot(efx);
drivers/net/ethernet/sfc/mcdi.c:			efx_mcdi_poll_reboot(efx);
drivers/net/ethernet/sfc/mcdi.c:	 * in polled mode, then do nothing because the MC reboot handler will
drivers/net/ethernet/sfc/mcdi.c:	 * request. Did the mc reboot before or after the copyout? The
drivers/net/ethernet/sfc/mcdi.c:			if (efx_mcdi_poll_reboot(efx))
drivers/net/ethernet/sfc/mcdi.c:	/* Attempt to read any stored assertion state before we reboot
drivers/net/ethernet/sfc/mcdi.c:	 * reboot.  We set a flag that makes the command a no-op if it
drivers/net/ethernet/sfc/mcdi.h: * @new_epoch: Indicates start of day or start of MC reboot recovery
drivers/net/ethernet/sfc/mcdi.h:int efx_mcdi_poll_reboot(struct efx_nic *efx);
drivers/net/ethernet/sfc/net_driver.h: * @mcdi_poll_reboot: Test whether the MCDI has rebooted.  If so,
drivers/net/ethernet/sfc/net_driver.h:	int (*mcdi_poll_reboot)(struct efx_nic *efx);
drivers/net/ethernet/sfc/nic.h: * @must_realloc_vis: Flag: VIs have yet to be reallocated after MC reboot
drivers/net/ethernet/sfc/nic.h: * @must_restore_filters: Flag: filters have yet to be restored after MC reboot
drivers/net/ethernet/sfc/nic.h: *	reboot
drivers/net/ethernet/sfc/nic.h: *	after MC reboot
drivers/net/ethernet/sfc/ef10.c:	/* Get the MC's warm boot count.  In case it's rebooting right
drivers/net/ethernet/sfc/ef10.c:static int efx_ef10_mcdi_poll_reboot(struct efx_nic *efx)
drivers/net/ethernet/sfc/ef10.c:		 * rebooting.  However, we are supposed to report each
drivers/net/ethernet/sfc/ef10.c:		 * reboot just once, so we must only do that once we
drivers/net/ethernet/sfc/ef10.c:	/* If the MC has just rebooted, the TX/RX queues will have already been
drivers/net/ethernet/sfc/ef10.c:	.mcdi_poll_reboot = efx_ef10_mcdi_poll_reboot,
drivers/net/ethernet/sfc/siena.c:static int siena_mcdi_poll_reboot(struct efx_nic *efx)
drivers/net/ethernet/sfc/siena.c:	.mcdi_poll_reboot = siena_mcdi_poll_reboot,
drivers/net/ethernet/sfc/mcdi_pcol.h: * memory on reboot and assert */
drivers/net/ethernet/sfc/mcdi_pcol.h:/* enum: The MC has rebooted (huntington and later, siena uses CODE_REBOOT and
drivers/net/ethernet/sfc/mcdi_pcol.h:/* enum: The FC was rebooted. */
drivers/net/ethernet/sfc/mcdi_pcol.h: * This is useful for certain soft rebooting scenarios. (Huntington only)
drivers/net/ethernet/sfc/mcdi_pcol.h: * certain soft rebooting scenarios. (Huntington only)
drivers/net/ethernet/sfc/mcdi_pcol.h: * which means that they will automatically reboot out of the assertion
drivers/net/ethernet/sfc/mcdi_pcol.h: * Set the mode for the next MC reboot. Locks required: NONE. Sets the reboot
drivers/net/ethernet/sfc/mcdi_pcol.h: * Control the system and DPCPU clock frequencies. Changes are lost reboot.
drivers/net/ethernet/sfc/mcdi_pcol.h: * reboot.
drivers/net/ethernet/sfc/mcdi_pcol.h: * or a reboot of the MC.)
drivers/net/ethernet/sfc/efx.c:	if (efx_mcdi_poll_reboot(efx) && efx_reset(efx, RESET_TYPE_ALL))
drivers/net/ethernet/sfc/efx.c:		if (efx_mcdi_poll_reboot(efx))
drivers/net/ethernet/sfc/efx.c:	netif_err(efx, drv, efx->net_dev, "Warning: No MC reboot after BIST mode\n");
drivers/net/ethernet/sfc/efx.c:	/* Either way unset the BIST flag. If we found no reboot we probably
drivers/net/ethernet/amd/pcnet32.c:	 * DOS packet driver after a warm reboot
drivers/net/ethernet/amd/pcnet32.c:	 * DOS packet driver after a warm reboot
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:	int rebooted;
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:	if (mgp->rebooted == 0) {
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:static u32 myri10ge_read_reboot(struct myri10ge_priv *mgp)
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:	u32 reboot;
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:	pci_read_config_dword(pdev, vs + 0x14, &reboot);
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:	return reboot;
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:	u32 reboot, rx_pause_cnt;
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:	int status, rebooted;
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:	rebooted = 0;
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:		 * if the card rebooted due to a parity error
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:		reboot = myri10ge_read_reboot(mgp);
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:		netdev_err(mgp->dev, "NIC rebooted (0x%x),%s resetting\n",
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:			   reboot, myri10ge_reset_recover ? "" : " not");
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:		mgp->rebooted = 1;
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:		rebooted = 1;
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:		mgp->rebooted = 0;
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:		 * A rebooted nic will come back with config space as
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:	if (!rebooted) {
drivers/net/ethernet/myricom/myri10ge/myri10ge.c:	 * the reboot register later on */
drivers/net/ethernet/chelsio/cxgb4vf/cxgb4vf_main.c:	 * fail to reset "Assigned Devices" when the VM reboots.  Therefore we
drivers/net/ethernet/intel/ixgb/ixgb.h:#include <linux/reboot.h>
drivers/net/ethernet/intel/i40evf/i40evf_main.c: * i40evf_shutdown - Shutdown the device in preparation for a reboot
drivers/net/ethernet/intel/e1000/e1000.h:#include <linux/reboot.h>
drivers/net/ethernet/seeq/ether3.c: * there is non-reboot way to recover if something goes wrong.
drivers/net/ethernet/emulex/benet/be_main.c:			dev_err(dev, "Please reboot server to recover");
drivers/net/ethernet/emulex/benet/be_main.c:			 * the reboot.
drivers/net/ethernet/toshiba/tc35815.c: * there is non-reboot way to recover if something goes wrong.
drivers/net/ethernet/realtek/atp.c:   there is non-reboot way to recover if something goes wrong.
drivers/net/ethernet/qlogic/netxen/netxen_nic_init.c:		/* skipping cold reboot MAGIC */
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c:				"\t\tIf reboot doesn't help, try flashing the card\n");
drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c:				dev_err(&pdev->dev, "Adapter initialization failed. Please reboot\n");
drivers/net/ethernet/qlogic/qlcnic/qlcnic_init.c:		/* skipping cold reboot MAGIC */
drivers/net/ethernet/nvidia/forcedeth.c: * Power down phy when interface is down (persists through reboot;
drivers/net/ethernet/nvidia/forcedeth.c:	 * down, and this stays across warm reboots. The sequence
drivers/net/ethernet/via/via-rhine.c:	 * it is not known if that still works with the "win98-reboot" problem.
drivers/net/ethernet/via/via-velocity.c:#include <linux/reboot.h>
drivers/net/ethernet/natsemi/sonic.c: *  there is non-reboot way to recover if something goes wrong.
drivers/net/ethernet/microchip/enc28j60.c: * there is non-reboot way to recover if something goes wrong.
drivers/net/ethernet/3com/typhoon.c:		netdev_err(dev, "unable to reboot into sleep img\n");
drivers/net/ethernet/cirrus/cs89x0.c:   there is non-reboot way to recover if something goes wrong.
drivers/net/ethernet/cirrus/mac89x0.c:   there is non-reboot way to recover if something goes wrong.
drivers/net/ethernet/mellanox/mlx4/reset.c:	 * after the chip reboots.  We skip config space offsets 22
drivers/net/ethernet/ibm/ehea/ehea_main.c:#include <linux/reboot.h>
drivers/net/ethernet/ibm/ehea/ehea_main.c:static int ehea_reboot_notifier(struct notifier_block *nb,
drivers/net/ethernet/ibm/ehea/ehea_main.c:static struct notifier_block ehea_reboot_nb = {
drivers/net/ethernet/ibm/ehea/ehea_main.c:	.notifier_call = ehea_reboot_notifier,
drivers/net/ethernet/ibm/ehea/ehea_main.c:	ret = register_reboot_notifier(&ehea_reboot_nb);
drivers/net/ethernet/ibm/ehea/ehea_main.c:		pr_info("register_reboot_notifier failed\n");
drivers/net/ethernet/ibm/ehea/ehea_main.c:	unregister_reboot_notifier(&ehea_reboot_nb);
drivers/net/ethernet/ibm/ehea/ehea_main.c:	unregister_reboot_notifier(&ehea_reboot_nb);
drivers/net/ethernet/dec/tulip/de4x5.c:    reboot sequences).  Loadable module support  under PCI and EISA has been
drivers/net/ethernet/dec/tulip/de4x5.c:    kernel with the de4x5 configuration turned off and reboot.
drivers/net/ethernet/broadcom/bnx2x/bnx2x.h: * (you will need to reboot afterwards) */
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:			  "you will need to reboot when done\n");
drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c:			  "you will need to reboot when done\n");
drivers/net/ethernet/broadcom/bnx2x/bnx2x_vfpf.c:	 * CIDs incorrectly requiring a VF-flr [VM reboot] in order to recover
drivers/net/ethernet/broadcom/bnx2x/bnx2x_link.c:	 * rely on link set by preboot driver
drivers/net/ethernet/broadcom/bnx2x/bnx2x_link.c:	/* Ucode reboot and rst */
drivers/net/ethernet/8390/etherh.c: * there is non-reboot way to recover if something goes wrong.
drivers/net/ethernet/8390/smc-ultra.c:	/* Enabled FINE16 mode to avoid BIOS ROM width mismatches @ reboot. */
drivers/net/ethernet/8390/wd.c:	/* Turn off 16 bit access so that reboot works.	 ISA brain-damage */
drivers/net/ethernet/8390/wd.c:		/* Turn on and off 16 bit access so that reboot works. */
drivers/net/ethernet/8390/wd.c:	/* Change from 16-bit to 8-bit shared memory so reboot works. */
drivers/net/hamradio/hdlcdrv.c: * there is non-reboot way to recover if something goes wrong.
drivers/net/hamradio/baycom_epp.c: * there is non-reboot way to recover if something goes wrong.
drivers/clk/samsung/clk-exynos5440.c:#include <linux/reboot.h>
drivers/clk/samsung/clk-s3c2412.c:#include <linux/reboot.h>
drivers/clk/samsung/clk-s3c2443.c:#include <linux/reboot.h>
drivers/clk/rockchip/clk.c:#include <linux/reboot.h>
drivers/clk/clk-nomadik.c:#include <linux/reboot.h>
drivers/clk/clk-nomadik.c:static int nomadik_clk_reboot_handler(struct notifier_block *this,
drivers/clk/clk-nomadik.c:	/* The main chrystal need to be enabled for reboot to work */
drivers/clk/clk-nomadik.c:static struct notifier_block nomadik_clk_reboot_notifier = {
drivers/clk/clk-nomadik.c:	.notifier_call = nomadik_clk_reboot_handler,
drivers/clk/clk-nomadik.c:	register_reboot_notifier(&nomadik_clk_reboot_notifier);
drivers/ide/pmac.c:#include <linux/reboot.h>
drivers/ide/ide-gd.c:static const struct dmi_system_id ide_coldreboot_table[] = {
drivers/ide/ide-gd.c:		/* Acer TravelMate 66x cuts power during reboot */
drivers/ide/ide-gd.c:	   different from reboot(8). Therefore, we don't need to
drivers/ide/ide-gd.c:		!dmi_check_system(ide_coldreboot_table)) {
drivers/ide/ide-io.c:#include <linux/reboot.h>
drivers/ide/icside.c:	 * after a soft reboot.  This also disables access to
drivers/memory/emif.c:#include <linux/reboot.h>
drivers/input/serio/i8042.c: * Save the CTR for restore on unload / reboot.
drivers/input/serio/i8042-x86ia64io.h: * die horrible death on reboot.
drivers/input/mouse/alps.c:	 * it unusable until the machine reboots, so exit it here just
drivers/input/mouse/alps.c:	 * it unusable until the machine reboots, so exit it here just
drivers/input/mouse/cyapa_gen5.c:			 * trackpad device when booting/rebooting
drivers/input/keyboard/atkbd.c: * reboot.
drivers/usb/storage/uas.c: * hang on reboot when the device is still in uas mode. Note the reset is
drivers/usb/host/fusbh200-hcd.c:		 * or else system reboot).  See EHCI 2.3.9 and 4.14 for info
drivers/usb/host/ehci-hcd.c:	/* make BIOS/etc use companion controller during reboot */
drivers/usb/host/ehci-hcd.c:	 * having let the firmware kick in during reboot.
drivers/usb/host/fotg210-hcd.c:		 * or else system reboot).  See EHCI 2.3.9 and 4.14 for info
drivers/usb/host/oxu210hp-hcd.c:	/* make BIOS/etc use companion controller during reboot */
drivers/usb/host/oxu210hp-hcd.c:		 * or else system reboot).  See EHCI 2.3.9 and 4.14 for info
drivers/usb/host/ehci-hub.c:		 * or else system reboot).  See EHCI 2.3.9 and 4.14 for info
drivers/usb/host/xhci.c: * This is called when the machine is rebooting or halting.  We assume that the
drivers/usb/core/usb.c:	/* This will matter if shutdown/reboot does exitcalls. */
drivers/usb/atm/ueagle-atm.c:	/* reload firmware when reboot start and it's loaded already */
drivers/usb/atm/ueagle-atm.c:	/* reload firmware when reboot start and it's loaded already */
drivers/usb/atm/ueagle-atm.c: * return < 0 if an error occurs (-EAGAIN reboot needed)
drivers/usb/atm/ueagle-atm.c:	 * but before we start the reboot, the ack occurs and set this to 1.
drivers/usb/atm/ueagle-atm.c: * In case of an error wait 1s before rebooting the modem
drivers/usb/atm/ueagle-atm.c: * if the modem don't request reboot (-EAGAIN).
drivers/usb/atm/ueagle-atm.c:static ssize_t reboot(struct device *dev, struct device_attribute *attr,
drivers/usb/atm/ueagle-atm.c:static DEVICE_ATTR(stat_status, S_IWUSR | S_IRUGO, read_status, reboot);
drivers/usb/gadget/udc/at91_udc.c:	/* force disconnect on reboot */
drivers/usb/gadget/udc/lpc32xx_udc.c:	/* Force disconnect on reboot */
drivers/usb/gadget/udc/net2280.c:	ep_warn(dev, "It will operate on cold-reboot and SS connect");
drivers/usb/gadget/udc/net2280.c: * generating IRQs across the upcoming reboot.
drivers/usb/isp1760/isp1760-hcd.c: * done bit is not being set. This is bad - it blocks the endpoint until reboot.
drivers/usb/serial/io_ti.c:		/* Device will reboot */
drivers/usb/serial/io_ti.c:		dev_dbg(dev, "%s - Download successful -- Device rebooting...\n", __func__);
drivers/usb/serial/io_usbvend.h:#define USB_REQUEST_ION_RESET_DEVICE	0	// Warm reboot Edgeport, retaining USB address
drivers/usb/wusbcore/wusbhc.h: *                 unique value that doesn't change across reboots (so
drivers/mmc/core/pwrseq_emmc.c:#include <linux/reboot.h>
drivers/mmc/core/pwrseq_emmc.c:	 * emergency_reboot(), priority 129 schedules it just before
drivers/mmc/core/pwrseq_emmc.c:	 * system reboot
drivers/regulator/max77802.c:		 * If the regulator is disabled and the system warm rebooted,
drivers/regulator/tps65910-regulator.c:	 * then before shutting down/rebooting the system, the external
drivers/platform/x86/Kconfig:	  then reboots into Linux, the system may remain configured to resume
drivers/platform/chrome/chromeos_pstore.c:		 * coreboot as bios vendor. No other systems with this
drivers/platform/chrome/chromeos_pstore.c:			DMI_MATCH(DMI_BIOS_VENDOR, "coreboot"),
drivers/platform/chrome/chromeos_pstore.c: * range untouched across reboots, so we use that to store our pstore
drivers/platform/chrome/chromeos_laptop.c:			DMI_MATCH(DMI_BIOS_VENDOR, "coreboot"),
drivers/platform/chrome/chromeos_laptop.c:			DMI_MATCH(DMI_BIOS_VENDOR, "coreboot"),
drivers/platform/chrome/chromeos_laptop.c:			DMI_MATCH(DMI_BIOS_VENDOR, "coreboot"),
drivers/platform/chrome/Kconfig:	  information across reboots.
drivers/misc/sgi-xp/xpc_sn2.c:		/* the other side rebooted */
drivers/misc/sgi-xp/xpc_sn2.c:	 * reloads and system reboots.
drivers/misc/sgi-xp/xpc_main.c:#include <linux/reboot.h>
drivers/misc/sgi-xp/xpc_main.c:static int xpc_system_reboot(struct notifier_block *, unsigned long, void *);
drivers/misc/sgi-xp/xpc_main.c:static struct notifier_block xpc_reboot_notifier = {
drivers/misc/sgi-xp/xpc_main.c:	.notifier_call = xpc_system_reboot,
drivers/misc/sgi-xp/xpc_main.c:	/* a 'rmmod XPC' and a 'reboot' cannot both end up here together */
drivers/misc/sgi-xp/xpc_main.c:		(void)unregister_reboot_notifier(&xpc_reboot_notifier);
drivers/misc/sgi-xp/xpc_main.c: * This function is called when the system is being rebooted.
drivers/misc/sgi-xp/xpc_main.c:xpc_system_reboot(struct notifier_block *nb, unsigned long event, void *unused)
drivers/misc/sgi-xp/xpc_main.c:	/* add ourselves to the reboot_notifier_list */
drivers/misc/sgi-xp/xpc_main.c:	ret = register_reboot_notifier(&xpc_reboot_notifier);
drivers/misc/sgi-xp/xpc_main.c:		dev_warn(xpc_part, "can't register reboot notifier\n");
drivers/misc/sgi-xp/xpc_main.c:	(void)unregister_reboot_notifier(&xpc_reboot_notifier);
drivers/misc/sgi-xp/xp.h:	xpSystemReboot,		/* 47: system is being rebooted */
drivers/misc/mic/card/mic_device.c:#include <linux/reboot.h>
drivers/misc/ibmasm/module.c: * Failure to do so would result in system reboot.
drivers/misc/ibmasm/heartbeat.c: * will be rebooted.
drivers/misc/ibmasm/heartbeat.c: * the OS is still running and thus preventing a reboot.
drivers/misc/ibmasm/heartbeat.c: * if yes it suspends heartbeat, causing the service processor to reboot as
drivers/nfc/st21nfca/i2c.c: * In order to get the CLF in a known state we generate an internal reboot
drivers/nfc/st21nfca/i2c.c: * Once the reboot is completed, we expect to receive a ST21NFCA_SOF_EOF
drivers/nfc/st21nfca/i2c.c:	u16 wait_reboot[] = { 50, 300, 1000 };
drivers/nfc/st21nfca/i2c.c:	char reboot_cmd[] = { 0x7E, 0x66, 0x48, 0xF6, 0x7E };
drivers/nfc/st21nfca/i2c.c:	for (i = 0; i < ARRAY_SIZE(wait_reboot) && r < 0; i++) {
drivers/nfc/st21nfca/i2c.c:		r = i2c_master_send(phy->i2c_dev, reboot_cmd,
drivers/nfc/st21nfca/i2c.c:				    sizeof(reboot_cmd));
drivers/nfc/st21nfca/i2c.c:			msleep(wait_reboot[i]);
drivers/nfc/st21nfca/i2c.c:	/* CLF is spending about 20ms to do an internal reboot */
drivers/nfc/st21nfca/i2c.c:	for (i = 0; i < ARRAY_SIZE(wait_reboot) && r < 0; i++) {
drivers/nfc/st21nfca/i2c.c:			msleep(wait_reboot[i]);
drivers/nfc/st21nfca/i2c.c:		nfc_err(&client->dev, "Unable to reboot st21nfca\n");
drivers/macintosh/windfarm_core.c:#include <linux/reboot.h>
drivers/macintosh/windfarm_pm112.c:#include <linux/reboot.h>
drivers/macintosh/windfarm_rm31.c:#include <linux/reboot.h>
drivers/macintosh/windfarm_pm72.c:#include <linux/reboot.h>
drivers/thermal/rcar_thermal.c:#include <linux/reboot.h>
drivers/thermal/thermal_core.c:#include <linux/reboot.h>
drivers/thermal/ti-soc-thermal/ti-bandgap.c:#include <linux/reboot.h>
drivers/virt/fsl_hypervisor.c:#include <linux/reboot.h>
drivers/rtc/rtc-ds1374.c:#include <linux/reboot.h>
drivers/rtc/rtc-ds1374.c:	ret = register_reboot_notifier(&ds1374_wdt_notifier);
drivers/rtc/rtc-ds1374.c:	unregister_reboot_notifier(&ds1374_wdt_notifier);
drivers/rtc/rtc-m41t80.c:#include <linux/reboot.h>
drivers/rtc/rtc-m41t80.c: *	off at reboot otherwise the machine will reboot again during memory
drivers/rtc/rtc-m41t80.c:		rc = register_reboot_notifier(&wdt_notifier);
drivers/rtc/rtc-m41t80.c:		unregister_reboot_notifier(&wdt_notifier);
drivers/rtc/rtc-at91sam9.c:	 * RTT on at least some reboots.  If you have that chip, you must
drivers/rtc/rtc-ds1511.c: * will reboot the system
drivers/mfd/ab8500-sysctrl.c:#include <linux/reboot.h>
drivers/mfd/ab8500-sysctrl.c:	 * reboot into charge-only mode.
drivers/mfd/twl4030-power.c:		/* Reset any existing sleep script to avoid hangs on reboot */
drivers/mfd/cros_ec_spi.c: * The EC is unresponsive for a time after a reboot command.  Add a
drivers/mfd/ab8500-core.c:	 * the device is rebooted with AC/USB charger connected. Due to
drivers/acpi/sleep.c:#include <linux/reboot.h>
drivers/acpi/sleep.c:static int tts_notify_reboot(struct notifier_block *this,
drivers/acpi/sleep.c:	.notifier_call	= tts_notify_reboot,
drivers/acpi/sleep.c:	 * Register the tts_notifier to reboot notifier list so that the _TTS
drivers/acpi/sleep.c:	register_reboot_notifier(&tts_notifier);
drivers/acpi/apei/ghes.c:		/* reboot to log the error! */
drivers/acpi/reboot.c:#include <acpi/reboot.h>
drivers/acpi/reboot.c:void acpi_reboot(void)
drivers/acpi/video_detect.c:	 * reboot. It's why we should prevent video.ko from being used here
drivers/acpi/ec_sys.c:MODULE_PARM_DESC(write_support, "Dangerous, reboot and removal of battery may "
drivers/acpi/Makefile:acpi-y				+= osl.o utils.o reboot.o
drivers/acpi/thermal.c:#include <linux/reboot.h>
drivers/acpi/thermal.c:		 * BIOSes return really low values and cause reboots at startup.
drivers/acpi/Kconfig:	  Controller in a way that a normal reboot is not enough. You then
drivers/acpi/Kconfig:	  replaced without rebooting the system. For details refer to:
drivers/acpi/acpica/hwsleep.c:	 * and use it to determine whether the system is rebooting or
drivers/acpi/acpica/hwesleep.c:	 * and use it to determine whether the system is rebooting or
drivers/pnp/pnpbios/bioscalls.c:		       "PnPBIOS: You may need to reboot with the \"pnpbios=off\" option to operate stably\n");
drivers/leds/trigger/ledtrig-heartbeat.c:#include <linux/reboot.h>
drivers/leds/trigger/ledtrig-heartbeat.c:static int heartbeat_reboot_notifier(struct notifier_block *nb,
drivers/leds/trigger/ledtrig-heartbeat.c:static struct notifier_block heartbeat_reboot_nb = {
drivers/leds/trigger/ledtrig-heartbeat.c:	.notifier_call = heartbeat_reboot_notifier,
drivers/leds/trigger/ledtrig-heartbeat.c:		register_reboot_notifier(&heartbeat_reboot_nb);
drivers/leds/trigger/ledtrig-heartbeat.c:	unregister_reboot_notifier(&heartbeat_reboot_nb);
drivers/base/power/trace.c: * than 24 bits of actual data we can save across reboots.
drivers/base/power/trace.c: * regenerate after the reboot.
drivers/base/firmware_class.c:#include <linux/reboot.h>
drivers/base/firmware_class.c:/* reboot notifier for avoid deadlock with usermode_lock */
drivers/base/firmware_class.c:	register_reboot_notifier(&fw_shutdown_nb);
drivers/base/firmware_class.c:	unregister_reboot_notifier(&fw_shutdown_nb);
drivers/soc/tegra/pmc.c:#include <linux/reboot.h>
drivers/soc/tegra/pmc.c: * tegra_pmc_restart() - reboot the system
drivers/soc/tegra/pmc.c: * @mode: which mode to reboot in
drivers/soc/tegra/pmc.c: * @cmd: reboot command
drivers/soc/tegra/pmc.c:void tegra_pmc_restart(enum reboot_mode mode, const char *cmd)
drivers/ps3/ps3-sys-manager.c:#include <linux/reboot.h>
drivers/s390/char/sclp_quiesce.c:#include <linux/reboot.h>
drivers/s390/char/con3215.c:#include <linux/reboot.h>
drivers/s390/char/con3215.c:static struct notifier_block on_reboot_nb = {
drivers/s390/char/con3215.c:	register_reboot_notifier(&on_reboot_nb);
drivers/s390/char/sclp_con.c:#include <linux/reboot.h>
drivers/s390/char/sclp_con.c:static struct notifier_block on_reboot_nb = {
drivers/s390/char/sclp_con.c:	register_reboot_notifier(&on_reboot_nb);
drivers/s390/char/sclp.c:#include <linux/reboot.h>
drivers/s390/char/sclp.c: * waiting too long would be harmful to the system, e.g. during SE reboot.
drivers/s390/char/sclp.c: * events from interfering with rebooted system. */
drivers/s390/char/sclp.c:sclp_reboot_event(struct notifier_block *this, unsigned long event, void *ptr)
drivers/s390/char/sclp.c:static struct notifier_block sclp_reboot_notifier = {
drivers/s390/char/sclp.c:	.notifier_call = sclp_reboot_event
drivers/s390/char/sclp.c:	/* Register reboot handler */
drivers/s390/char/sclp.c:	rc = register_reboot_notifier(&sclp_reboot_notifier);
drivers/s390/char/sclp.c:		goto fail_unregister_reboot_notifier;
drivers/s390/char/sclp.c:fail_unregister_reboot_notifier:
drivers/s390/char/sclp.c:	unregister_reboot_notifier(&sclp_reboot_notifier);
drivers/s390/char/sclp_vt220.c:#include <linux/reboot.h>
drivers/s390/char/sclp_vt220.c:static struct notifier_block on_reboot_nb = {
drivers/s390/char/sclp_vt220.c:	register_reboot_notifier(&on_reboot_nb);
drivers/s390/char/con3270.c:#include <linux/reboot.h>
drivers/s390/char/con3270.c:static struct notifier_block on_reboot_nb = {
drivers/s390/char/con3270.c:	register_reboot_notifier(&on_reboot_nb);
drivers/s390/cio/css.c:#include <linux/reboot.h>
drivers/s390/cio/css.c:static int css_reboot_event(struct notifier_block *this,
drivers/s390/cio/css.c:static struct notifier_block css_reboot_notifier = {
drivers/s390/cio/css.c:	.notifier_call = css_reboot_event,
drivers/s390/cio/css.c:	ret = register_reboot_notifier(&css_reboot_notifier);
drivers/s390/cio/css.c:		unregister_reboot_notifier(&css_reboot_notifier);
drivers/md/dm-raid1.c:		 * be wrong if the failed leg returned after reboot and
drivers/md/dm-snap-persistent.c: * will survive a reboot.
drivers/md/md.c:#include <linux/reboot.h>
drivers/md/md.c:	 * 1 reboot per second, or we have a bug...
drivers/md/md.c:static int md_notify_reboot(struct notifier_block *this,
drivers/md/md.c:	 * volatile wrt too early system reboots. While the
drivers/md/md.c:	.notifier_call	= md_notify_reboot,
drivers/md/md.c:	register_reboot_notifier(&md_notifier);
drivers/md/md.c:	unregister_reboot_notifier(&md_notifier);
drivers/md/bcache/super.c:#include <linux/reboot.h>
drivers/md/bcache/super.c:static int bcache_reboot(struct notifier_block *n, unsigned long code, void *x)
drivers/md/bcache/super.c:static struct notifier_block reboot = {
drivers/md/bcache/super.c:	.notifier_call	= bcache_reboot,
drivers/md/bcache/super.c:	unregister_reboot_notifier(&reboot);
drivers/md/bcache/super.c:	register_reboot_notifier(&reboot);
drivers/irqchip/irq-bcm7120-l2.c:#include <linux/reboot.h>
tags:BFA_PREBOOT_BOOTLUN_MAX	drivers/scsi/bfa/bfa_defs.h	/^	BFA_PREBOOT_BOOTLUN_MAX = 8,    \/*  maximum preboot lun per IOC *\/$/;"	e	enum:__anon4974
tags:BOOT_ACPI	include/linux/reboot.h	/^	BOOT_ACPI	= 'a',$/;"	e	enum:reboot_type
tags:BOOT_BIOS	include/linux/reboot.h	/^	BOOT_BIOS	= 'b',$/;"	e	enum:reboot_type
tags:BOOT_CF9_FORCE	include/linux/reboot.h	/^	BOOT_CF9_FORCE	= 'p',$/;"	e	enum:reboot_type
tags:BOOT_CF9_SAFE	include/linux/reboot.h	/^	BOOT_CF9_SAFE	= 'q',$/;"	e	enum:reboot_type
tags:BOOT_EFI	include/linux/reboot.h	/^	BOOT_EFI	= 'e',$/;"	e	enum:reboot_type
tags:BOOT_KBD	include/linux/reboot.h	/^	BOOT_KBD	= 'k',$/;"	e	enum:reboot_type
tags:BOOT_TRIPLE	include/linux/reboot.h	/^	BOOT_TRIPLE	= 't',$/;"	e	enum:reboot_type
tags:CBProbeUuid	fs/afs/afs_cm.h	/^	CBProbeUuid		= 214,	\/* check the client hasn't rebooted *\/$/;"	e	enum:AFS_CM_Operations
tags:C_A_D	kernel/reboot.c	/^int C_A_D = 1;$/;"	v
tags:DEFAULT_REBOOT_MODE	kernel/reboot.c	/^enum reboot_mode reboot_mode DEFAULT_REBOOT_MODE;$/;"	v	typeref:enum:reboot_mode
tags:DEFAULT_REBOOT_MODE	kernel/reboot.c	29;"	d	file:
tags:DEFAULT_REBOOT_MODE	kernel/reboot.c	31;"	d	file:
tags:EC_REBOOT_CANCEL	include/linux/mfd/cros_ec_commands.h	/^	EC_REBOOT_CANCEL = 0,        \/* Cancel a pending reboot *\/$/;"	e	enum:ec_reboot_cmd
tags:EC_REBOOT_COLD	include/linux/mfd/cros_ec_commands.h	/^	EC_REBOOT_COLD = 4,          \/* Cold-reboot *\/$/;"	e	enum:ec_reboot_cmd
tags:EC_REBOOT_DISABLE_JUMP	include/linux/mfd/cros_ec_commands.h	/^	EC_REBOOT_DISABLE_JUMP = 5,  \/* Disable jump until next reboot *\/$/;"	e	enum:ec_reboot_cmd
tags:EC_REBOOT_HIBERNATE	include/linux/mfd/cros_ec_commands.h	/^	EC_REBOOT_HIBERNATE = 6      \/* Hibernate EC *\/$/;"	e	enum:ec_reboot_cmd
tags:EC_REBOOT_JUMP_RO	include/linux/mfd/cros_ec_commands.h	/^	EC_REBOOT_JUMP_RO = 1,       \/* Jump to RO without rebooting *\/$/;"	e	enum:ec_reboot_cmd
tags:EC_REBOOT_JUMP_RW	include/linux/mfd/cros_ec_commands.h	/^	EC_REBOOT_JUMP_RW = 2,       \/* Jump to RW without rebooting *\/$/;"	e	enum:ec_reboot_cmd
tags:INTEGRATOR_CM_CTRL_RESET	drivers/power/reset/arm-versatile-reboot.c	19;"	d	file:
tags:INTEGRATOR_HDR_CTRL_OFFSET	drivers/power/reset/arm-versatile-reboot.c	17;"	d	file:
tags:INTEGRATOR_HDR_LOCK_OFFSET	drivers/power/reset/arm-versatile-reboot.c	18;"	d	file:
tags:INTEGRATOR_REBOOT_CM	drivers/power/reset/arm-versatile-reboot.c	/^	INTEGRATOR_REBOOT_CM,$/;"	e	enum:versatile_reboot	file:
tags:K1212_DB_RebootCard	sound/pci/korg1212/korg1212.c	/^   K1212_DB_RebootCard            = 0xA0, \/\/ instructs the card to reboot.$/;"	e	enum:korg1212_dbcnst	file:
tags:KERN_CTLALTDEL	include/uapi/linux/sysctl.h	/^	KERN_CTLALTDEL=22,	\/* int: allow ctl-alt-del to reboot *\/$/;"	e	enum:__anon9050
tags:KERN_SPARC_REBOOT	include/uapi/linux/sysctl.h	/^	KERN_SPARC_REBOOT=21,	\/* reboot command on Sparc *\/$/;"	e	enum:__anon9050
tags:LINUX_REBOOT_CMD_CAD_OFF	include/uapi/linux/reboot.h	31;"	d
tags:LINUX_REBOOT_CMD_CAD_ON	include/uapi/linux/reboot.h	30;"	d
tags:LINUX_REBOOT_CMD_HALT	include/uapi/linux/reboot.h	29;"	d
tags:LINUX_REBOOT_CMD_KEXEC	include/uapi/linux/reboot.h	35;"	d
tags:LINUX_REBOOT_CMD_POWER_OFF	include/uapi/linux/reboot.h	32;"	d
tags:LINUX_REBOOT_CMD_RESTART	include/uapi/linux/reboot.h	28;"	d
tags:LINUX_REBOOT_CMD_RESTART2	include/uapi/linux/reboot.h	33;"	d
tags:LINUX_REBOOT_CMD_SW_SUSPEND	include/uapi/linux/reboot.h	34;"	d
tags:LINUX_REBOOT_MAGIC1	include/uapi/linux/reboot.h	8;"	d
tags:LINUX_REBOOT_MAGIC2	include/uapi/linux/reboot.h	9;"	d
tags:LINUX_REBOOT_MAGIC2A	include/uapi/linux/reboot.h	10;"	d
tags:LINUX_REBOOT_MAGIC2B	include/uapi/linux/reboot.h	11;"	d
tags:LINUX_REBOOT_MAGIC2C	include/uapi/linux/reboot.h	12;"	d
tags:MRR_APM	arch/x86/include/asm/reboot.h	24;"	d
tags:MRR_BIOS	arch/x86/include/asm/reboot.h	23;"	d
tags:NFS_STATE_RECLAIM_REBOOT	fs/nfs/nfs4_fs.h	/^	NFS_STATE_RECLAIM_REBOOT,	\/* OPEN stateid server rebooted *\/$/;"	e	enum:__anon691
tags:OPAL_MSG_SHUTDOWN	arch/powerpc/include/asm/opal.h	/^	OPAL_MSG_SHUTDOWN,		\/* params[0] = 1 reboot, 0 shutdown *\/$/;"	e	enum:OpalMessageType
tags:PCI_DEVICE_ID_INTEL_CE4100	arch/x86/kernel/reboot_fixups_32.c	65;"	d	file:
tags:POWEROFF_CMD_PATH_LEN	include/linux/reboot.h	70;"	d
tags:REALVIEW_REBOOT_EB	drivers/power/reset/arm-versatile-reboot.c	/^	REALVIEW_REBOOT_EB,$/;"	e	enum:versatile_reboot	file:
tags:REALVIEW_REBOOT_PB1176	drivers/power/reset/arm-versatile-reboot.c	/^	REALVIEW_REBOOT_PB1176,$/;"	e	enum:versatile_reboot	file:
tags:REALVIEW_REBOOT_PB11MP	drivers/power/reset/arm-versatile-reboot.c	/^	REALVIEW_REBOOT_PB11MP,$/;"	e	enum:versatile_reboot	file:
tags:REALVIEW_REBOOT_PBA8	drivers/power/reset/arm-versatile-reboot.c	/^	REALVIEW_REBOOT_PBA8,$/;"	e	enum:versatile_reboot	file:
tags:REALVIEW_REBOOT_PBX	drivers/power/reset/arm-versatile-reboot.c	/^	REALVIEW_REBOOT_PBX,$/;"	e	enum:versatile_reboot	file:
tags:REALVIEW_SYS_LOCK_OFFSET	drivers/power/reset/arm-versatile-reboot.c	21;"	d	file:
tags:REALVIEW_SYS_RESETCTL_OFFSET	drivers/power/reset/arm-versatile-reboot.c	22;"	d	file:
tags:REBOOT_COLD	include/linux/reboot.h	/^	REBOOT_COLD = 0,	\/\/   \/,  $/;"	e	enum:reboot_mode
tags:REBOOT_GPIO	include/linux/reboot.h	/^	REBOOT_GPIO,		\/\/ GPIO  $/;"	e	enum:reboot_mode
tags:REBOOT_HARD	include/linux/reboot.h	/^	REBOOT_HARD,		\/\/    , PC $/;"	e	enum:reboot_mode
tags:REBOOT_SOFT	include/linux/reboot.h	/^	REBOOT_SOFT,		\/\/ SW  , ctrl+alt+del$/;"	e	enum:reboot_mode
tags:REBOOT_WARM	include/linux/reboot.h	/^	REBOOT_WARM,		\/\/   ,HW  $/;"	e	enum:reboot_mode
tags:RESET_SOURCE_ENABLE_REG	drivers/power/reset/brcmstb-reboot.c	31;"	d	file:
tags:SEL_DISABLE	security/selinux/selinuxfs.c	/^	SEL_DISABLE,	\/* disable SELinux until next reboot *\/$/;"	e	enum:sel_inos	file:
tags:SHUTDOWN_reboot	include/xen/interface/sched.h	106;"	d
tags:SW_MASTER_RESET_REG	drivers/power/reset/brcmstb-reboot.c	32;"	d	file:
tags:SYSCALL_DEFINE4	kernel/reboot.c	/^SYSCALL_DEFINE4(reboot, int, magic1, int, magic2, unsigned int, cmd,$/;"	f
tags:SYS_DOWN	include/linux/reboot.h	8;"	d
tags:SYS_HALT	include/linux/reboot.h	10;"	d
tags:SYS_POWER_OFF	include/linux/reboot.h	11;"	d
tags:SYS_RESTART	include/linux/reboot.h	9;"	d
tags:VERSATILE_LOCK_VAL	drivers/power/reset/arm-versatile-reboot.c	25;"	d	file:
tags:_ASM_REBOOT_H	arch/mips/include/asm/reboot.h	10;"	d
tags:_ASM_X86_REBOOT_FIXUPS_H	arch/x86/include/asm/reboot_fixups.h	2;"	d
tags:_ASM_X86_REBOOT_H	arch/x86/include/asm/reboot.h	2;"	d
tags:_LINUX_REBOOT_H	include/linux/reboot.h	2;"	d
tags:_UAPI_LINUX_REBOOT_H	include/uapi/linux/reboot.h	2;"	d
tags:__ACPI_REBOOT_H	include/acpi/reboot.h	2;"	d
tags:__ASM_REBOOT_H__	arch/blackfin/include/asm/reboot.h	10;"	d
tags:__ASM_SH_REBOOT_H	arch/sh/include/asm/reboot.h	2;"	d
tags:__NR_osf_reboot	arch/alpha/include/uapi/asm/unistd.h	59;"	d
tags:__NR_reboot	arch/alpha/include/uapi/asm/unistd.h	272;"	d
tags:__NR_reboot	arch/arm/include/uapi/asm/unistd.h	116;"	d
tags:__NR_reboot	arch/arm64/include/asm/unistd32.h	200;"	d
tags:__NR_reboot	arch/avr32/include/uapi/asm/unistd.h	104;"	d
tags:__NR_reboot	arch/blackfin/include/uapi/asm/unistd.h	100;"	d
tags:__NR_reboot	arch/cris/include/uapi/asm/unistd.h	96;"	d
tags:__NR_reboot	arch/frv/include/uapi/asm/unistd.h	96;"	d
tags:__NR_reboot	arch/ia64/include/uapi/asm/unistd.h	87;"	d
tags:__NR_reboot	arch/m32r/include/uapi/asm/unistd.h	96;"	d
tags:__NR_reboot	arch/m68k/include/uapi/asm/unistd.h	96;"	d
tags:__NR_reboot	arch/microblaze/include/uapi/asm/unistd.h	102;"	d
tags:__NR_reboot	arch/mips/include/uapi/asm/unistd.h	111;"	d
tags:__NR_reboot	arch/mips/include/uapi/asm/unistd.h	561;"	d
tags:__NR_reboot	arch/mips/include/uapi/asm/unistd.h	895;"	d
tags:__NR_reboot	arch/mn10300/include/uapi/asm/unistd.h	102;"	d
tags:__NR_reboot	arch/parisc/include/uapi/asm/unistd.h	104;"	d
tags:__NR_reboot	arch/powerpc/include/uapi/asm/unistd.h	101;"	d
tags:__NR_reboot	arch/s390/include/uapi/asm/unistd.h	72;"	d
tags:__NR_reboot	arch/sh/include/uapi/asm/unistd_32.h	100;"	d
tags:__NR_reboot	arch/sh/include/uapi/asm/unistd_64.h	105;"	d
tags:__NR_reboot	arch/sparc/include/uapi/asm/unistd.h	87;"	d
tags:__NR_reboot	arch/xtensa/include/uapi/asm/unistd.h	444;"	d
tags:__NR_reboot	include/uapi/asm-generic/unistd.h	423;"	d
tags:____kvm_handle_fault_on_reboot	arch/x86/include/asm/kvm_host.h	1109;"	d
tags:__bcm63xx_machine_reboot	arch/mips/bcm63xx/setup.c	/^static void __bcm63xx_machine_reboot(char *p)$/;"	f	file:
tags:__initconst	drivers/video/fbdev/aty/atyfb_base.c	/^static const struct dmi_system_id atyfb_reboot_ids[] __initconst = {$/;"	v	typeref:struct:atyfb_reboot_ids	file:
tags:__kvm_handle_fault_on_reboot	arch/x86/include/asm/kvm_host.h	1122;"	d
tags:__machine_emergency_restart	arch/x86/kernel/reboot.c	/^static void __machine_emergency_restart(int emergency)$/;"	f	file:
tags:__orderly_poweroff	kernel/reboot.c	/^static int __orderly_poweroff(bool force)$/;"	f	file:
tags:__packed	include/linux/mfd/cros_ec_commands.h	/^} __packed;$/;"	v	typeref:struct:ec_params_reboot_ec
tags:_reboot	include/linux/mtd/mtd.h	/^	void (*_reboot) (struct mtd_info *mtd);$/;"	m	struct:mtd_info
tags:acpi_reboot	drivers/acpi/reboot.c	/^void acpi_reboot(void)$/;"	f
tags:acpi_reboot	include/acpi/reboot.h	/^static inline void acpi_reboot(void) { }$/;"	f
tags:am33xx_restart	arch/arm/mach-omap2/am33xx-restart.c	/^void am33xx_restart(enum reboot_mode mode, const char *cmd)$/;"	f
tags:am33xx_restart	arch/arm/mach-omap2/common.h	/^static inline void am33xx_restart(enum reboot_mode mode, const char *cmd)$/;"	f
tags:apm	arch/x86/realmode/rm/reboot.S	/^apm:$/;"	l
tags:arm_pm_restart	arch/arm/kernel/process.c	/^void (*arm_pm_restart)(enum reboot_mode reboot_mode, const char *cmd);$/;"	v
tags:arm_pm_restart	arch/arm64/kernel/process.c	/^void (*arm_pm_restart)(enum reboot_mode reboot_mode, const char *cmd);$/;"	v
tags:armv7m_restart	arch/arm/kernel/v7m.c	/^void armv7m_restart(enum reboot_mode mode, const char *cmd)$/;"	f
tags:at91rm9200_restart	arch/arm/mach-at91/at91rm9200.c	/^static void at91rm9200_restart(enum reboot_mode reboot_mode, const char *cmd)$/;"	f	file:
tags:ath9k_hif_usb_reboot	drivers/net/wireless/ath/ath9k/hif_usb.c	/^static void ath9k_hif_usb_reboot(struct usb_device *udev)$/;"	f	file:
tags:atyfb_reboot_notifier	drivers/video/fbdev/aty/atyfb_base.c	/^static struct notifier_block atyfb_reboot_notifier = {$/;"	v	typeref:struct:notifier_block	file:
tags:atyfb_reboot_notify	drivers/video/fbdev/aty/atyfb_base.c	/^static int atyfb_reboot_notify(struct notifier_block *nb,$/;"	f	file:
tags:base	drivers/power/reset/hisi-reboot.c	/^static void __iomem *base;$/;"	v	file:
tags:bcache_reboot	drivers/md/bcache/super.c	/^static int bcache_reboot(struct notifier_block *n, unsigned long code, void *x)$/;"	f	file:
tags:bcm21664_restart	arch/arm/mach-bcm/board_bcm21664.c	/^static void bcm21664_restart(enum reboot_mode mode, const char *cmd)$/;"	f	file:
tags:bcm281xx_restart	arch/arm/mach-bcm/board_bcm281xx.c	/^static void bcm281xx_restart(enum reboot_mode mode, const char *cmd)$/;"	f	file:
tags:bcm2835_restart	arch/arm/mach-bcm/board_bcm2835.c	/^static void bcm2835_restart(enum reboot_mode mode, const char *cmd)$/;"	f	file:
tags:bcm6348_a1_reboot	arch/mips/bcm63xx/setup.c	/^static void bcm6348_a1_reboot(void)$/;"	f	file:
tags:bcm63xx_machine_reboot	arch/mips/bcm63xx/setup.c	/^void bcm63xx_machine_reboot(void)$/;"	f
tags:bfa_bsg_preboot_s	drivers/scsi/bfa/bfad_bsg.h	/^struct bfa_bsg_preboot_s {$/;"	s
tags:bfad_iocmd_preboot_query	drivers/scsi/bfa/bfad_bsg.c	/^bfad_iocmd_preboot_query(struct bfad_s *bfad, void *cmd)$/;"	f
tags:bfad_num	drivers/scsi/bfa/bfad_bsg.h	/^	u16		bfad_num;$/;"	m	struct:bfa_bsg_preboot_s
tags:bfin_reset	arch/blackfin/kernel/reboot.c	/^static void bfin_reset(void)$/;"	f	file:
tags:bi_bootflags	arch/powerpc/boot/ppcboot-hotfoot.h	/^	unsigned long	bi_bootflags;	\/* boot \/ reboot flag (for LynxOS) *\/$/;"	m	struct:bd_info
tags:bi_bootflags	arch/powerpc/boot/ppcboot.h	/^	unsigned long	bi_bootflags;	\/* boot \/ reboot flag (for LynxOS) *\/$/;"	m	struct:bd_info
tags:bios	arch/x86/realmode/rm/reboot.S	/^bios:$/;"	l
tags:bisect_reboot	tools/testing/ktest/ktest.pl	/^sub bisect_reboot {$/;"	s
tags:body	drivers/tty/ipwireless/hardware.c	/^	struct TlSetupRebootMsgAck body;$/;"	m	struct:ipw_setup_reboot_msg_ack	typeref:struct:ipw_setup_reboot_msg_ack::TlSetupRebootMsgAck	file:
tags:brcmstb_reboot_driver	drivers/power/reset/brcmstb-reboot.c	/^static struct platform_driver brcmstb_reboot_driver = {$/;"	v	typeref:struct:platform_driver	file:
tags:brcmstb_reboot_init	drivers/power/reset/brcmstb-reboot.c	/^static int __init brcmstb_reboot_init(void)$/;"	f	file:
tags:brcmstb_reboot_init	drivers/power/reset/brcmstb-reboot.c	/^subsys_initcall(brcmstb_reboot_init);$/;"	v
tags:brcmstb_reboot_probe	drivers/power/reset/brcmstb-reboot.c	/^static int brcmstb_reboot_probe(struct platform_device *pdev)$/;"	f	file:
tags:brcmstb_restart_handler	drivers/power/reset/brcmstb-reboot.c	/^static int brcmstb_restart_handler(struct notifier_block *this,$/;"	f	file:
tags:brcmstb_restart_nb	drivers/power/reset/brcmstb-reboot.c	/^static struct notifier_block brcmstb_restart_nb = {$/;"	v	typeref:struct:notifier_block	file:
tags:cad_pid	kernel/reboot.c	/^EXPORT_SYMBOL(cad_pid);$/;"	v
tags:cad_pid	kernel/reboot.c	/^struct pid *cad_pid;$/;"	v	typeref:struct:pid
tags:carl9170_reboot	drivers/net/wireless/ath/carl9170/cmd.c	/^int carl9170_reboot(struct ar9170 *ar)$/;"	f
tags:caused_reboot	drivers/watchdog/f71808e_wdt.c	/^	char		caused_reboot;	\/* last reboot was by the watchdog *\/$/;"	m	struct:watchdog_data	file:
tags:cbe_ptcal_notify_reboot	arch/powerpc/platforms/cell/ras.c	/^static int cbe_ptcal_notify_reboot(struct notifier_block *nb,$/;"	f	file:
tags:cbe_ptcal_reboot_notifier	arch/powerpc/platforms/cell/ras.c	/^static struct notifier_block cbe_ptcal_reboot_notifier = {$/;"	v	typeref:struct:notifier_block	file:
tags:ce4100_reset	arch/x86/kernel/reboot_fixups_32.c	/^static void ce4100_reset(struct pci_dev *dev)$/;"	f	file:
tags:cfg	drivers/scsi/bfa/bfad_bsg.h	/^	struct bfa_boot_pbc_s	cfg;$/;"	m	struct:bfa_bsg_preboot_s	typeref:struct:bfa_bsg_preboot_s::bfa_boot_pbc_s
tags:cfi_amdstd_reboot	drivers/mtd/chips/cfi_cmdset_0002.c	/^static int cfi_amdstd_reboot(struct notifier_block *nb, unsigned long val,$/;"	f	file:
tags:cfi_intelext_reboot	drivers/mtd/chips/cfi_cmdset_0001.c	/^static int cfi_intelext_reboot(struct notifier_block *nb, unsigned long val,$/;"	f	file:
tags:clps711x_restart	arch/arm/mach-clps711x/common.c	/^void clps711x_restart(enum reboot_mode mode, const char *cmd)$/;"	f
tags:cmd	include/linux/mfd/cros_ec_commands.h	/^	uint8_t cmd;           \/* enum ec_reboot_cmd *\/$/;"	m	struct:ec_params_reboot_ec
tags:cmm_reboot_nb	arch/powerpc/platforms/pseries/cmm.c	/^static struct notifier_block cmm_reboot_nb = {$/;"	v	typeref:struct:notifier_block	file:
tags:cmm_reboot_notifier	arch/powerpc/platforms/pseries/cmm.c	/^static int cmm_reboot_notifier(struct notifier_block *nb,$/;"	f	file:
tags:cns3xxx_restart	arch/arm/mach-cns3xxx/pm.c	/^void cns3xxx_restart(enum reboot_mode mode, const char *cmd)$/;"	f
tags:corgi_restart	arch/arm/mach-pxa/corgi.c	/^static void corgi_restart(enum reboot_mode mode, const char *cmd)$/;"	f	file:
tags:cpu8815_restart	arch/arm/mach-nomadik/cpu-8815.c	/^static void cpu8815_restart(enum reboot_mode mode, const char *cmd)$/;"	f	file:
tags:crash_nmi_callback	arch/x86/kernel/reboot.c	/^static int crash_nmi_callback(unsigned int val, struct pt_regs *regs)$/;"	f	file:
tags:crash_shutdown	arch/sh/include/asm/reboot.h	/^	void (*crash_shutdown)(struct pt_regs *);$/;"	m	struct:machine_ops
tags:crash_shutdown	arch/x86/include/asm/reboot.h	/^	void (*crash_shutdown)(struct pt_regs *);$/;"	m	struct:machine_ops
tags:crashing_cpu	arch/x86/kernel/reboot.c	/^static int crashing_cpu;$/;"	v	file:
tags:cs5530a_warm_reset	arch/x86/kernel/reboot_fixups_32.c	/^static void cs5530a_warm_reset(struct pci_dev *dev)$/;"	f	file:
tags:cs5536_warm_reset	arch/x86/kernel/reboot_fixups_32.c	/^static void cs5536_warm_reset(struct pci_dev *dev)$/;"	f	file:
tags:csr	drivers/power/reset/xgene-reboot.c	/^	void *csr;$/;"	m	struct:xgene_reboot_context	file:
tags:css_reboot_event	drivers/s390/cio/css.c	/^static int css_reboot_event(struct notifier_block *this,$/;"	f	file:
tags:css_reboot_notifier	drivers/s390/cio/css.c	/^static struct notifier_block css_reboot_notifier = {$/;"	v	typeref:struct:notifier_block	file:
tags:ctrl_alt_del	kernel/reboot.c	/^void ctrl_alt_del(void)$/;"	f
tags:da8xx_restart	arch/arm/mach-davinci/devices-da8xx.c	/^void da8xx_restart(enum reboot_mode mode, const char *cmd)$/;"	f
tags:davinci_restart	arch/arm/mach-davinci/devices.c	/^void davinci_restart(enum reboot_mode mode, const char *cmd)$/;"	f
tags:dbg_notify_reboot	kernel/debug/debug_core.c	/^dbg_notify_reboot(struct notifier_block *this, unsigned long code, void *x)$/;"	f	file:
tags:dbg_reboot_notifier	kernel/debug/debug_core.c	/^static struct notifier_block dbg_reboot_notifier = {$/;"	v	typeref:struct:notifier_block	file:
tags:dcdbas_reboot_nb	drivers/firmware/dcdbas.c	/^static struct notifier_block dcdbas_reboot_nb = {$/;"	v	typeref:struct:notifier_block	file:
tags:dcdbas_reboot_notify	drivers/firmware/dcdbas.c	/^static int dcdbas_reboot_notify(struct notifier_block *nb, unsigned long code,$/;"	f	file:
tags:dcon_reboot_notify	drivers/staging/olpc_dcon/olpc_dcon.c	/^static int dcon_reboot_notify(struct notifier_block *nb,$/;"	f	file:
tags:deferred_cad	kernel/reboot.c	/^static void deferred_cad(struct work_struct *dummy)$/;"	f	file:
tags:dev	drivers/power/reset/xgene-reboot.c	/^	struct device *dev;$/;"	m	struct:xgene_reboot_context	typeref:struct:xgene_reboot_context::device	file:
tags:device	arch/x86/kernel/reboot_fixups_32.c	/^	unsigned int device;$/;"	m	struct:device_fixup	file:
tags:device_fixup	arch/x86/kernel/reboot_fixups_32.c	/^struct device_fixup {$/;"	s	file:
tags:device_notify_reboot	drivers/staging/vt6655/device_main.c	/^device_notify_reboot(struct notifier_block *nb, unsigned long event, void *p)$/;"	f	file:
tags:do_kernel_restart	kernel/reboot.c	/^void do_kernel_restart(char *cmd)$/;"	f
tags:do_not_reboot	tools/testing/ktest/ktest.pl	/^sub do_not_reboot {$/;"	s
tags:do_reboot	drivers/xen/manage.c	/^static void do_reboot(void)$/;"	f	file:
tags:dove_restart	arch/arm/mach-dove/common.c	/^void dove_restart(enum reboot_mode mode, const char *cmd)$/;"	f
tags:ebsa110_restart	arch/arm/mach-ebsa110/core.c	/^static void ebsa110_restart(enum reboot_mode mode, const char *cmd)$/;"	f	file:
tags:ec_params_reboot_ec	include/linux/mfd/cros_ec_commands.h	/^struct ec_params_reboot_ec {$/;"	s
tags:ec_reboot_cmd	include/linux/mfd/cros_ec_commands.h	/^enum ec_reboot_cmd {$/;"	g
tags:eeh_reboot_nb	arch/powerpc/kernel/eeh.c	/^static struct notifier_block eeh_reboot_nb = {$/;"	v	typeref:struct:notifier_block	file:
tags:eeh_reboot_notifier	arch/powerpc/kernel/eeh.c	/^static int eeh_reboot_notifier(struct notifier_block *nb,$/;"	f	file:
tags:efi_power_off	drivers/firmware/efi/reboot.c	/^static void efi_power_off(void)$/;"	f	file:
tags:efi_poweroff_required	drivers/firmware/efi/reboot.c	/^bool __weak efi_poweroff_required(void)$/;"	f
tags:efi_reboot	drivers/firmware/efi/reboot.c	/^void efi_reboot(enum reboot_mode reboot_mode, const char *__unused)$/;"	f
tags:efi_reboot	include/linux/efi.h	/^efi_reboot(enum reboot_mode reboot_mode, const char *__unused) {}$/;"	f
tags:efi_reboot_quirk_mode	drivers/firmware/efi/reboot.c	/^int efi_reboot_quirk_mode = -1;$/;"	v
tags:efi_reboot_required	arch/x86/include/asm/efi.h	/^static inline bool efi_reboot_required(void)$/;"	f
tags:efi_reboot_required	arch/x86/platform/efi/quirks.c	/^bool efi_reboot_required(void)$/;"	f
tags:efi_secureboot_enabled	drivers/firmware/efi/libstub/arm-stub.c	/^static int efi_secureboot_enabled(efi_system_table_t *sys_table_arg)$/;"	f	file:
tags:efi_shutdown_init	drivers/firmware/efi/reboot.c	/^late_initcall(efi_shutdown_init);$/;"	v
tags:efi_shutdown_init	drivers/firmware/efi/reboot.c	/^static int __init efi_shutdown_init(void)$/;"	f	file:
tags:efx_ef10_mcdi_poll_reboot	drivers/net/ethernet/sfc/ef10.c	/^static int efx_ef10_mcdi_poll_reboot(struct efx_nic *efx)$/;"	f	file:
tags:efx_mcdi_poll_reboot	drivers/net/ethernet/sfc/mcdi.c	/^int efx_mcdi_poll_reboot(struct efx_nic *efx)$/;"	f
tags:ehea_reboot_nb	drivers/net/ethernet/ibm/ehea/ehea_main.c	/^static struct notifier_block ehea_reboot_nb = {$/;"	v	typeref:struct:notifier_block	file:
tags:ehea_reboot_notifier	drivers/net/ethernet/ibm/ehea/ehea_main.c	/^static int ehea_reboot_notifier(struct notifier_block *nb,$/;"	f	file:
tags:emergency_restart	arch/x86/include/asm/reboot.h	/^	void (*emergency_restart)(void);$/;"	m	struct:machine_ops
tags:emergency_restart	kernel/reboot.c	/^EXPORT_SYMBOL_GPL(emergency_restart);$/;"	v
tags:emergency_restart	kernel/reboot.c	/^void emergency_restart(void)$/;"	f
tags:emergency_vmx_disable_all	arch/x86/kernel/reboot.c	/^static void emergency_vmx_disable_all(void)$/;"	f	file:
tags:ep93xx_restart	arch/arm/mach-ep93xx/core.c	/^void ep93xx_restart(enum reboot_mode mode, const char *cmd)$/;"	f
tags:eva_restart	arch/arm/mach-shmobile/board-armadillo800eva.c	/^static void eva_restart(enum reboot_mode mode, const char *cmd)$/;"	f	file:
tags:fixups_table	arch/x86/kernel/reboot_fixups_32.c	/^static const struct device_fixup fixups_table[] = {$/;"	v	typeref:struct:device_fixup	file:
tags:fl2f_reboot	arch/mips/loongson/lemote-2f/reset.c	/^static void fl2f_reboot(void)$/;"	f	file:
tags:flags	include/linux/mfd/cros_ec_commands.h	/^	uint8_t flags;         \/* See EC_REBOOT_FLAG_* *\/$/;"	m	struct:ec_params_reboot_ec
tags:footbridge_restart	arch/arm/mach-footbridge/common.c	/^void footbridge_restart(enum reboot_mode mode, const char *cmd)$/;"	f
tags:gdb_cmd_reboot	kernel/debug/gdbstub.c	/^static int gdb_cmd_reboot(struct kgdb_state *ks)$/;"	f	file:
tags:gsmi_reboot_callback	drivers/firmware/google/gsmi.c	/^static int gsmi_reboot_callback(struct notifier_block *nb,$/;"	f	file:
tags:gsmi_reboot_notifier	drivers/firmware/google/gsmi.c	/^static struct notifier_block gsmi_reboot_notifier = {$/;"	v	typeref:struct:notifier_block	file:
tags:halt	arch/sh/include/asm/reboot.h	/^	void (*halt)(void);$/;"	m	struct:machine_ops
tags:halt	arch/x86/include/asm/reboot.h	/^	void (*halt)(void);$/;"	m	struct:machine_ops
tags:hangcheck_parse_reboot	drivers/char/hangcheck-timer.c	/^static int __init hangcheck_parse_reboot(char *str)$/;"	f	file:
tags:hangcheck_reboot	drivers/char/hangcheck-timer.c	/^static int hangcheck_reboot;  \/* Defaults to not reboot *\/$/;"	v	file:
tags:header	drivers/tty/ipwireless/hardware.c	/^	struct ipw_tx_packet header;$/;"	m	struct:ipw_setup_reboot_msg_ack	typeref:struct:ipw_setup_reboot_msg_ack::ipw_tx_packet	file:
tags:heartbeat_reboot_nb	drivers/leds/trigger/ledtrig-heartbeat.c	/^static struct notifier_block heartbeat_reboot_nb = {$/;"	v	typeref:struct:notifier_block	file:
tags:heartbeat_reboot_notifier	drivers/leds/trigger/ledtrig-heartbeat.c	/^static int heartbeat_reboot_notifier(struct notifier_block *nb,$/;"	f	file:
tags:highbank_restart	arch/arm/mach-highbank/system.c	/^void highbank_restart(enum reboot_mode mode, const char *cmd)$/;"	f
tags:hisi_reboot_driver	drivers/power/reset/hisi-reboot.c	/^module_platform_driver(hisi_reboot_driver);$/;"	v
tags:hisi_reboot_driver	drivers/power/reset/hisi-reboot.c	/^static struct platform_driver hisi_reboot_driver = {$/;"	v	typeref:struct:platform_driver	file:
tags:hisi_reboot_of_match	drivers/power/reset/hisi-reboot.c	/^static struct of_device_id hisi_reboot_of_match[] = {$/;"	v	typeref:struct:of_device_id	file:
tags:hisi_reboot_probe	drivers/power/reset/hisi-reboot.c	/^static int hisi_reboot_probe(struct platform_device *pdev)$/;"	f	file:
tags:hisi_restart_handler	drivers/power/reset/hisi-reboot.c	/^static int hisi_restart_handler(struct notifier_block *this,$/;"	f	file:
tags:hisi_restart_nb	drivers/power/reset/hisi-reboot.c	/^static struct notifier_block hisi_restart_nb = {$/;"	v	typeref:struct:notifier_block	file:
tags:hp300_reset	arch/m68k/hp300/reboot.S	/^hp300_reset:$/;"	l
tags:iTCO_vendor_check_noreboot_on	drivers/watchdog/iTCO_vendor.h	13;"	d
tags:iTCO_vendor_check_noreboot_on	drivers/watchdog/iTCO_vendor_support.c	/^EXPORT_SYMBOL(iTCO_vendor_check_noreboot_on);$/;"	v
tags:iTCO_vendor_check_noreboot_on	drivers/watchdog/iTCO_vendor_support.c	/^int iTCO_vendor_check_noreboot_on(void)$/;"	f
tags:ide_coldreboot_table	drivers/ide/ide-gd.c	/^static const struct dmi_system_id ide_coldreboot_table[] = {$/;"	v	typeref:struct:dmi_system_id	file:
tags:ifx_modem_reboot_callback	drivers/tty/serial/ifx6x60.c	/^static int ifx_modem_reboot_callback(struct notifier_block *nfb,$/;"	f	file:
tags:ifx_modem_reboot_notifier_block	drivers/tty/serial/ifx6x60.c	/^static struct notifier_block ifx_modem_reboot_notifier_block = {$/;"	v	typeref:struct:notifier_block	file:
tags:intel_mid_reboot	arch/x86/platform/intel-mid/intel-mid.c	/^static void intel_mid_reboot(void)$/;"	f	file:
tags:iop13xx_restart	arch/arm/mach-iop13xx/setup.c	/^void iop13xx_restart(enum reboot_mode mode, const char *cmd)$/;"	f
tags:iop3xx_restart	arch/arm/plat-iop/restart.c	/^void iop3xx_restart(enum reboot_mode mode, const char *cmd)$/;"	f
tags:ip27_reboot_setup	arch/mips/sgi-ip27/ip27-reset.c	/^void ip27_reboot_setup(void)$/;"	f
tags:ip32_reboot_setup	arch/mips/sgi-ip32/ip32-reset.c	/^static __init int ip32_reboot_setup(void)$/;"	f	file:
tags:ip32_reboot_setup	arch/mips/sgi-ip32/ip32-reset.c	/^subsys_initcall(ip32_reboot_setup);$/;"	v
tags:ipw_setup_reboot_msg_ack	drivers/tty/ipwireless/hardware.c	/^struct ipw_setup_reboot_msg_ack {$/;"	s	file:
tags:iucv_reboot_event	net/iucv/iucv.c	/^static int iucv_reboot_event(struct notifier_block *this,$/;"	f	file:
tags:iucv_reboot_notifier	net/iucv/iucv.c	/^static struct notifier_block iucv_reboot_notifier = {$/;"	v	typeref:struct:notifier_block	file:
tags:ixp4xx_restart	arch/arm/mach-ixp4xx/common.c	/^void ixp4xx_restart(enum reboot_mode mode, const char *cmd)$/;"	f
tags:kb_wait	arch/x86/kernel/reboot.c	/^static inline void kb_wait(void)$/;"	f	file:
tags:kdb_reboot	kernel/debug/kdb/kdb_main.c	/^static int kdb_reboot(int argc, const char **argv)$/;"	f	file:
tags:kernel_halt	kernel/reboot.c	/^EXPORT_SYMBOL_GPL(kernel_halt);$/;"	v
tags:kernel_halt	kernel/reboot.c	/^void kernel_halt(void)$/;"	f
tags:kernel_power_off	kernel/reboot.c	/^EXPORT_SYMBOL_GPL(kernel_power_off);$/;"	v
tags:kernel_power_off	kernel/reboot.c	/^void kernel_power_off(void)$/;"	f
tags:kernel_restart	kernel/reboot.c	/^EXPORT_SYMBOL_GPL(kernel_restart);$/;"	v
tags:kernel_restart	kernel/reboot.c	/^void kernel_restart(char *cmd)$/;"	f
tags:kernel_restart_prepare	kernel/reboot.c	/^void kernel_restart_prepare(char *cmd)$/;"	f
tags:kernel_shutdown_prepare	kernel/reboot.c	/^static void kernel_shutdown_prepare(enum system_states state)$/;"	f	file:
tags:kexec_ready_to_reboot	arch/mips/kernel/machine_kexec.c	/^atomic_t kexec_ready_to_reboot = ATOMIC_INIT(0);$/;"	v
tags:kgdbreboot	kernel/debug/debug_core.c	/^static int kgdbreboot;$/;"	v	file:
tags:kill_off_processes	arch/um/kernel/reboot.c	/^static void kill_off_processes(void)$/;"	f	file:
tags:ks8695_restart	arch/arm/mach-ks8695/time.c	/^void ks8695_restart(enum reboot_mode reboot_mode, const char *cmd)$/;"	f
tags:kvm_pv_guest_cpu_reboot	arch/x86/kernel/kvm.c	/^static void kvm_pv_guest_cpu_reboot(void *unused)$/;"	f	file:
tags:kvm_pv_reboot_nb	arch/x86/kernel/kvm.c	/^static struct notifier_block kvm_pv_reboot_nb = {$/;"	v	typeref:struct:notifier_block	file:
tags:kvm_pv_reboot_notify	arch/x86/kernel/kvm.c	/^static int kvm_pv_reboot_notify(struct notifier_block *nb,$/;"	f	file:
tags:kvm_reboot	virt/kvm/kvm_main.c	/^static int kvm_reboot(struct notifier_block *notifier, unsigned long val,$/;"	f	file:
tags:kvm_reboot_notifier	virt/kvm/kvm_main.c	/^static struct notifier_block kvm_reboot_notifier = {$/;"	v	typeref:struct:notifier_block	file:
tags:kvm_rebooting	virt/kvm/kvm_main.c	/^EXPORT_SYMBOL_GPL(kvm_rebooting);$/;"	v
tags:kvm_rebooting	virt/kvm/kvm_main.c	/^__visible bool kvm_rebooting;$/;"	v
tags:kzm9g_restart	arch/arm/mach-shmobile/board-kzm9g-reference.c	/^static void kzm9g_restart(enum reboot_mode mode, const char *cmd)$/;"	f	file:
tags:kzm9g_restart	arch/arm/mach-shmobile/board-kzm9g.c	/^static void kzm9g_restart(enum reboot_mode mode, const char *cmd)$/;"	f	file:
tags:lasat_reboot_setup	arch/mips/lasat/reset.c	/^void lasat_reboot_setup(void)$/;"	f
tags:ldom_reboot	arch/sparc/kernel/ds.c	/^void ldom_reboot(const char *boot_command)$/;"	f
tags:len	include/linux/lockd/xdr.h	/^	unsigned int		len;$/;"	m	struct:nlm_reboot
tags:loongson_reboot	arch/mips/loongson/common/reset.c	/^static inline void loongson_reboot(void)$/;"	f	file:
tags:lpc23xx_restart	arch/arm/mach-lpc32xx/common.c	/^void lpc23xx_restart(enum reboot_mode mode, const char *cmd)$/;"	f
tags:ls1x_reboot_setup	arch/mips/loongson1/common/reset.c	/^arch_initcall(ls1x_reboot_setup);$/;"	v
tags:ls1x_reboot_setup	arch/mips/loongson1/common/reset.c	/^static int __init ls1x_reboot_setup(void)$/;"	f	file:
tags:mach_prepare_reboot	arch/mips/loongson/fuloong-2e/reset.c	/^void mach_prepare_reboot(void)$/;"	f
tags:mach_prepare_reboot	arch/mips/loongson/lemote-2f/reset.c	/^void mach_prepare_reboot(void)$/;"	f
tags:mach_reboot_fixups	arch/x86/kernel/reboot.c	/^void __attribute__((weak)) mach_reboot_fixups(void)$/;"	f
tags:mach_reboot_fixups	arch/x86/kernel/reboot_fixups_32.c	/^void mach_reboot_fixups(void)$/;"	f
tags:machine_crash_shutdown	arch/sh/kernel/reboot.c	/^void machine_crash_shutdown(struct pt_regs *regs)$/;"	f
tags:machine_crash_shutdown	arch/x86/kernel/reboot.c	/^void machine_crash_shutdown(struct pt_regs *regs)$/;"	f
tags:machine_emergency_restart	arch/x86/kernel/reboot.c	/^void machine_emergency_restart(void)$/;"	f
tags:machine_halt	arch/blackfin/kernel/reboot.c	/^void machine_halt(void)$/;"	f
tags:machine_halt	arch/sh/kernel/reboot.c	/^void machine_halt(void)$/;"	f
tags:machine_halt	arch/sparc/kernel/reboot.c	/^void machine_halt(void)$/;"	f
tags:machine_halt	arch/tile/kernel/reboot.c	/^void machine_halt(void)$/;"	f
tags:machine_halt	arch/um/kernel/reboot.c	/^void machine_halt(void)$/;"	f
tags:machine_halt	arch/x86/kernel/reboot.c	/^void machine_halt(void)$/;"	f
tags:machine_ops	arch/sh/include/asm/reboot.h	/^struct machine_ops {$/;"	s
tags:machine_ops	arch/sh/kernel/reboot.c	/^struct machine_ops machine_ops = {$/;"	v	typeref:struct:machine_ops
tags:machine_ops	arch/x86/include/asm/reboot.h	/^struct machine_ops {$/;"	s
tags:machine_ops	arch/x86/kernel/reboot.c	/^struct machine_ops machine_ops = {$/;"	v	typeref:struct:machine_ops
tags:machine_power_off	arch/blackfin/kernel/reboot.c	/^void machine_power_off(void)$/;"	f
tags:machine_power_off	arch/sh/kernel/reboot.c	/^void machine_power_off(void)$/;"	f
tags:machine_power_off	arch/sparc/kernel/reboot.c	/^void machine_power_off(void)$/;"	f
tags:machine_power_off	arch/tile/kernel/reboot.c	/^void machine_power_off(void)$/;"	f
tags:machine_power_off	arch/um/kernel/reboot.c	/^void machine_power_off(void)$/;"	f
tags:machine_power_off	arch/x86/kernel/reboot.c	/^void machine_power_off(void)$/;"	f
tags:machine_real_restart	arch/x86/kernel/reboot.c	/^EXPORT_SYMBOL(machine_real_restart);$/;"	v
tags:machine_real_restart	arch/x86/kernel/reboot.c	/^void __noreturn machine_real_restart(unsigned int type)$/;"	f
tags:machine_real_restart_asm16	arch/x86/realmode/rm/reboot.S	/^machine_real_restart_asm16:$/;"	l
tags:machine_restart	arch/blackfin/kernel/reboot.c	/^void machine_restart(char *cmd)$/;"	f
tags:machine_restart	arch/sh/kernel/reboot.c	/^void machine_restart(char *cmd)$/;"	f
tags:machine_restart	arch/sparc/kernel/reboot.c	/^void machine_restart(char *cmd)$/;"	f
tags:machine_restart	arch/tile/kernel/reboot.c	/^void machine_restart(char *cmd)$/;"	f
tags:machine_restart	arch/um/kernel/reboot.c	/^void machine_restart(char * __unused)$/;"	f
tags:machine_restart	arch/x86/kernel/reboot.c	/^void machine_restart(char *cmd)$/;"	f
tags:machine_shutdown	arch/sh/kernel/reboot.c	/^void machine_shutdown(void)$/;"	f
tags:machine_shutdown	arch/x86/kernel/reboot.c	/^void machine_shutdown(void)$/;"	f
tags:map	drivers/power/reset/syscon-reboot.c	/^	struct regmap *map;$/;"	m	struct:syscon_reboot_context	typeref:struct:syscon_reboot_context::regmap	file:
tags:maple_use_rtas_reboot_and_halt_if_present	arch/powerpc/platforms/maple/setup.c	/^static void __init maple_use_rtas_reboot_and_halt_if_present(void)$/;"	f	file:
tags:mask	drivers/power/reset/syscon-reboot.c	/^	u32 mask;$/;"	m	struct:syscon_reboot_context	file:
tags:mask	drivers/power/reset/xgene-reboot.c	/^	u32 mask;$/;"	m	struct:xgene_reboot_context	file:
tags:mcdi_poll_reboot	drivers/net/ethernet/sfc/net_driver.h	/^	int (*mcdi_poll_reboot)(struct efx_nic *efx);$/;"	m	struct:efx_nic_type
tags:mconsole_reboot	arch/um/drivers/mconsole_kern.c	/^void mconsole_reboot(struct mc_request *req)$/;"	f
tags:md_notify_reboot	drivers/md/md.c	/^static int md_notify_reboot(struct notifier_block *this,$/;"	f	file:
tags:migrate_to_reboot_cpu	kernel/reboot.c	/^void migrate_to_reboot_cpu(void)$/;"	f
tags:mioa701_restart	arch/arm/mach-pxa/mioa701.c	/^static void mioa701_restart(enum reboot_mode c, const char *cmd)$/;"	f	file:
tags:mips_reboot_setup	arch/mips/lantiq/falcon/reset.c	/^arch_initcall(mips_reboot_setup);$/;"	v
tags:mips_reboot_setup	arch/mips/lantiq/falcon/reset.c	/^static int __init mips_reboot_setup(void)$/;"	f	file:
tags:mips_reboot_setup	arch/mips/lantiq/xway/reset.c	/^arch_initcall(mips_reboot_setup);$/;"	v
tags:mips_reboot_setup	arch/mips/lantiq/xway/reset.c	/^static int __init mips_reboot_setup(void)$/;"	f	file:
tags:mips_reboot_setup	arch/mips/loongson/common/reset.c	/^arch_initcall(mips_reboot_setup);$/;"	v
tags:mips_reboot_setup	arch/mips/loongson/common/reset.c	/^static int __init mips_reboot_setup(void)$/;"	f	file:
tags:mips_reboot_setup	arch/mips/mti-malta/malta-reset.c	/^arch_initcall(mips_reboot_setup);$/;"	v
tags:mips_reboot_setup	arch/mips/mti-malta/malta-reset.c	/^static int __init mips_reboot_setup(void)$/;"	f	file:
tags:mips_reboot_setup	arch/mips/mti-sead3/sead3-reset.c	/^arch_initcall(mips_reboot_setup);$/;"	v
tags:mips_reboot_setup	arch/mips/mti-sead3/sead3-reset.c	/^static int __init mips_reboot_setup(void)$/;"	f	file:
tags:mips_reboot_setup	arch/mips/ralink/reset.c	/^arch_initcall(mips_reboot_setup);$/;"	v
tags:mips_reboot_setup	arch/mips/ralink/reset.c	/^static int __init mips_reboot_setup(void)$/;"	f	file:
tags:ml2f_reboot	arch/mips/loongson/lemote-2f/reset.c	/^static void ml2f_reboot(void)$/;"	f	file:
tags:mmp_restart	arch/arm/mach-mmp/common.c	/^void mmp_restart(enum reboot_mode mode, const char *cmd)$/;"	f
tags:mon	include/linux/lockd/xdr.h	/^	char			*mon;$/;"	m	struct:nlm_reboot
tags:mtd_reboot_notifier	drivers/mtd/mtdcore.c	/^static int mtd_reboot_notifier(struct notifier_block *n, unsigned long state,$/;"	f	file:
tags:mv78xx0_restart	arch/arm/mach-mv78xx0/common.c	/^void mv78xx0_restart(enum reboot_mode mode, const char *cmd)$/;"	f
tags:mvebu_restart	arch/arm/mach-mvebu/system-controller.c	/^void mvebu_restart(enum reboot_mode mode, const char *cmd)$/;"	f
tags:mxc_restart	arch/arm/mach-imx/system.c	/^void mxc_restart(enum reboot_mode mode, const char *cmd)$/;"	f
tags:mxs_restart	arch/arm/mach-mxs/mach-mxs.c	/^static void mxs_restart(enum reboot_mode mode, const char *cmd)$/;"	f	file:
tags:myri10ge_read_reboot	drivers/net/ethernet/myricom/myri10ge/myri10ge.c	/^static u32 myri10ge_read_reboot(struct myri10ge_priv *mgp)$/;"	f	file:
tags:n2100_restart	arch/arm/mach-iop32x/n2100.c	/^static void n2100_restart(enum reboot_mode mode, const char *cmd)$/;"	f	file:
tags:native_machine_emergency_restart	arch/x86/kernel/reboot.c	/^static void native_machine_emergency_restart(void)$/;"	f	file:
tags:native_machine_halt	arch/blackfin/kernel/reboot.c	/^void native_machine_halt(void)$/;"	f
tags:native_machine_halt	arch/sh/kernel/reboot.c	/^static void native_machine_halt(void)$/;"	f	file:
tags:native_machine_halt	arch/x86/kernel/reboot.c	/^static void native_machine_halt(void)$/;"	f	file:
tags:native_machine_power_off	arch/blackfin/kernel/reboot.c	/^void native_machine_power_off(void)$/;"	f
tags:native_machine_power_off	arch/sh/kernel/reboot.c	/^static void native_machine_power_off(void)$/;"	f	file:
tags:native_machine_power_off	arch/x86/kernel/reboot.c	/^static void native_machine_power_off(void)$/;"	f	file:
tags:native_machine_restart	arch/blackfin/kernel/reboot.c	/^void native_machine_restart(char *cmd)$/;"	f
tags:native_machine_restart	arch/sh/kernel/reboot.c	/^static void native_machine_restart(char * __unused)$/;"	f	file:
tags:native_machine_restart	arch/x86/kernel/reboot.c	/^static void native_machine_restart(char *__unused)$/;"	f	file:
tags:native_machine_shutdown	arch/sh/kernel/reboot.c	/^static void native_machine_shutdown(void)$/;"	f	file:
tags:native_machine_shutdown	arch/x86/kernel/reboot.c	/^void native_machine_shutdown(void)$/;"	f
tags:nettel_reboot_notifier	drivers/mtd/maps/nettel.c	/^static int nettel_reboot_notifier(struct notifier_block *nb, unsigned long val, void *v)$/;"	f	file:
tags:netwinder_restart	arch/arm/mach-footbridge/netwinder-hw.c	/^static void netwinder_restart(enum reboot_mode mode, const char *cmd)$/;"	f	file:
tags:netx_restart	arch/arm/mach-netx/generic.c	/^void netx_restart(enum reboot_mode mode, const char *cmd)$/;"	f
tags:nfs40_reboot_recovery_ops	fs/nfs/nfs4proc.c	/^static const struct nfs4_state_recovery_ops nfs40_reboot_recovery_ops = {$/;"	v	typeref:struct:nfs4_state_recovery_ops	file:
tags:nfs41_handle_server_reboot	fs/nfs/nfs4state.c	/^static void nfs41_handle_server_reboot(struct nfs_client *clp)$/;"	f	file:
tags:nfs41_reboot_recovery_ops	fs/nfs/nfs4proc.c	/^static const struct nfs4_state_recovery_ops nfs41_reboot_recovery_ops = {$/;"	v	typeref:struct:nfs4_state_recovery_ops	file:
tags:nfs4_state_clear_reclaim_reboot	fs/nfs/nfs4state.c	/^static int nfs4_state_clear_reclaim_reboot(struct nfs_client *clp)$/;"	f	file:
tags:nfs4_state_end_reclaim_reboot	fs/nfs/nfs4state.c	/^static void nfs4_state_end_reclaim_reboot(struct nfs_client *clp)$/;"	f	file:
tags:nfs4_state_mark_reclaim_reboot	fs/nfs/nfs4state.c	/^static int nfs4_state_mark_reclaim_reboot(struct nfs_client *clp, struct nfs4_state *state)$/;"	f	file:
tags:nfs4_state_start_reclaim_reboot	fs/nfs/nfs4state.c	/^static void nfs4_state_start_reclaim_reboot(struct nfs_client *clp)$/;"	f	file:
tags:nfsd4_load_reboot_recovery_data	fs/nfsd/nfs4recover.c	/^nfsd4_load_reboot_recovery_data(struct net *net)$/;"	f	file:
tags:nlm4svc_decode_reboot	fs/lockd/xdr4.c	/^nlm4svc_decode_reboot(struct svc_rqst *rqstp, __be32 *p, struct nlm_reboot *argp)$/;"	f
tags:nlm4svc_proc_sm_notify	fs/lockd/svc4proc.c	/^nlm4svc_proc_sm_notify(struct svc_rqst *rqstp, struct nlm_reboot *argp,$/;"	f	file:
tags:nlm_host_rebooted	fs/lockd/host.c	/^void nlm_host_rebooted(const struct nlm_reboot *info)$/;"	f
tags:nlm_reboot	include/linux/lockd/xdr.h	/^struct nlm_reboot {$/;"	s
tags:nlmsvc_decode_reboot	fs/lockd/xdr.c	/^nlmsvc_decode_reboot(struct svc_rqst *rqstp, __be32 *p, struct nlm_reboot *argp)$/;"	f
tags:nlmsvc_proc_sm_notify	fs/lockd/svcproc.c	/^nlmsvc_proc_sm_notify(struct svc_rqst *rqstp, struct nlm_reboot *argp,$/;"	f	file:
tags:nmi_reboot_notifier	arch/sparc/kernel/nmi.c	/^static struct notifier_block nmi_reboot_notifier = {$/;"	v	typeref:struct:notifier_block	file:
tags:nmi_shootdown_cb	arch/x86/include/asm/reboot.h	/^typedef void (*nmi_shootdown_cb)(int, struct pt_regs*);$/;"	t
tags:nmi_shootdown_cpus	arch/x86/kernel/reboot.c	/^void nmi_shootdown_cpus(nmi_shootdown_cb callback)$/;"	f
tags:no_idt	arch/x86/kernel/reboot.c	/^static const struct desc_ptr no_idt = {};$/;"	v	typeref:struct:desc_ptr	file:
tags:nomadik_clk_reboot_handler	drivers/clk/clk-nomadik.c	/^static int nomadik_clk_reboot_handler(struct notifier_block *this,$/;"	f	file:
tags:nomadik_clk_reboot_notifier	drivers/clk/clk-nomadik.c	/^static struct notifier_block nomadik_clk_reboot_notifier = {$/;"	v	typeref:struct:notifier_block	file:
tags:nsm_reboot_lookup	fs/lockd/mon.c	/^struct nsm_handle *nsm_reboot_lookup(const struct nlm_reboot *info)$/;"	f
tags:nspire_restart	arch/arm/mach-nspire/nspire.c	/^static void nspire_restart(enum reboot_mode mode, const char *cmd)$/;"	f	file:
tags:nuc9xx_restart	arch/arm/mach-w90x900/cpu.c	/^void nuc9xx_restart(enum reboot_mode mode, const char *cmd)$/;"	f
tags:obj-y	arch/m68k/hp300/Makefile	/^obj-y		:= config.o time.o reboot.o$/;"	m
tags:of_match	drivers/power/reset/brcmstb-reboot.c	/^static const struct of_device_id of_match[] = {$/;"	v	typeref:struct:of_device_id	file:
tags:offset	drivers/power/reset/syscon-reboot.c	/^	u32 offset;$/;"	m	struct:syscon_reboot_context	file:
tags:omap1_restart	arch/arm/mach-omap1/reset.c	/^void omap1_restart(enum reboot_mode mode, const char *cmd)$/;"	f
tags:omap2xxx_restart	arch/arm/mach-omap2/common.h	/^static inline void omap2xxx_restart(enum reboot_mode mode, const char *cmd)$/;"	f
tags:omap2xxx_restart	arch/arm/mach-omap2/omap2-restart.c	/^void omap2xxx_restart(enum reboot_mode mode, const char *cmd)$/;"	f
tags:omap3xxx_restart	arch/arm/mach-omap2/common.h	/^static inline void omap3xxx_restart(enum reboot_mode mode, const char *cmd)$/;"	f
tags:omap3xxx_restart	arch/arm/mach-omap2/omap3-restart.c	/^void omap3xxx_restart(enum reboot_mode mode, const char *cmd)$/;"	f
tags:omap44xx_restart	arch/arm/mach-omap2/common.h	/^static inline void omap44xx_restart(enum reboot_mode mode, const char *cmd)$/;"	f
tags:omap44xx_restart	arch/arm/mach-omap2/omap4-restart.c	/^void omap44xx_restart(enum reboot_mode mode, const char *cmd)$/;"	f
tags:on_reboot_attr	arch/s390/kernel/ipl.c	/^static struct kobj_attribute on_reboot_attr =$/;"	v	typeref:struct:kobj_attribute	file:
tags:on_reboot_nb	drivers/s390/char/con3215.c	/^static struct notifier_block on_reboot_nb = {$/;"	v	typeref:struct:notifier_block	file:
tags:on_reboot_nb	drivers/s390/char/con3270.c	/^static struct notifier_block on_reboot_nb = {$/;"	v	typeref:struct:notifier_block	file:
tags:on_reboot_nb	drivers/s390/char/sclp_con.c	/^static struct notifier_block on_reboot_nb = {$/;"	v	typeref:struct:notifier_block	file:
tags:on_reboot_nb	drivers/s390/char/sclp_vt220.c	/^static struct notifier_block on_reboot_nb = {$/;"	v	typeref:struct:notifier_block	file:
tags:on_reboot_show	arch/s390/kernel/ipl.c	/^static ssize_t on_reboot_show(struct kobject *kobj,$/;"	f	file:
tags:on_reboot_store	arch/s390/kernel/ipl.c	/^static ssize_t on_reboot_store(struct kobject *kobj,$/;"	f	file:
tags:on_reboot_trigger	arch/s390/kernel/ipl.c	/^static struct shutdown_trigger on_reboot_trigger = {ON_REIPL_STR,$/;"	v	typeref:struct:shutdown_trigger	file:
tags:orderly_poweroff	kernel/reboot.c	/^EXPORT_SYMBOL_GPL(orderly_poweroff);$/;"	v
tags:orderly_poweroff	kernel/reboot.c	/^int orderly_poweroff(bool force)$/;"	f
tags:orion5x_restart	arch/arm/mach-orion5x/common.c	/^void orion5x_restart(enum reboot_mode mode, const char *cmd)$/;"	f
tags:patchcheck_reboot	tools/testing/ktest/ktest.pl	/^sub patchcheck_reboot {$/;"	s
tags:pdc_chassis_reboot_block	arch/parisc/kernel/pdc_chassis.c	/^static struct notifier_block pdc_chassis_reboot_block = {$/;"	v	typeref:struct:notifier_block	file:
tags:pdc_chassis_reboot_event	arch/parisc/kernel/pdc_chassis.c	/^static int pdc_chassis_reboot_event(struct notifier_block *this,$/;"	f	file:
tags:perf_reboot	kernel/events/core.c	/^perf_reboot(struct notifier_block *notifier, unsigned long val, void *v)$/;"	f	file:
tags:perf_reboot_notifier	kernel/events/core.c	/^static struct notifier_block perf_reboot_notifier = {$/;"	v	typeref:struct:notifier_block	file:
tags:picoxcell_wdt_restart	arch/arm/mach-picoxcell/common.c	/^static void picoxcell_wdt_restart(enum reboot_mode mode, const char *cmd)$/;"	f	file:
tags:pm_power_off	arch/sh/kernel/reboot.c	/^EXPORT_SYMBOL(pm_power_off);$/;"	v
tags:pm_power_off	arch/sh/kernel/reboot.c	/^void (*pm_power_off)(void);$/;"	v
tags:pm_power_off	arch/sparc/kernel/reboot.c	/^EXPORT_SYMBOL(pm_power_off);$/;"	v
tags:pm_power_off	arch/sparc/kernel/reboot.c	/^void (*pm_power_off)(void) = machine_power_off;$/;"	v
tags:pm_power_off	arch/tile/kernel/reboot.c	/^EXPORT_SYMBOL(pm_power_off);$/;"	v
tags:pm_power_off	arch/tile/kernel/reboot.c	/^void (*pm_power_off)(void) = NULL;$/;"	v
tags:pm_power_off	arch/um/kernel/reboot.c	/^void (*pm_power_off)(void);$/;"	v
tags:pm_power_off	arch/x86/kernel/reboot.c	/^EXPORT_SYMBOL(pm_power_off);$/;"	v
tags:pm_power_off	arch/x86/kernel/reboot.c	/^void (*pm_power_off)(void);$/;"	v
tags:pm_power_off_prepare	kernel/reboot.c	/^void (*pm_power_off_prepare)(void);$/;"	v
tags:port_cf9_safe	arch/x86/kernel/reboot.c	/^bool port_cf9_safe = false;$/;"	v
tags:power_off	arch/sh/include/asm/reboot.h	/^	void (*power_off)(void);$/;"	m	struct:machine_ops
tags:power_off	arch/x86/include/asm/reboot.h	/^	void (*power_off)(void);$/;"	m	struct:machine_ops
tags:powernv_cpufreq_reboot_nb	drivers/cpufreq/powernv-cpufreq.c	/^static struct notifier_block powernv_cpufreq_reboot_nb = {$/;"	v	typeref:struct:notifier_block	file:
tags:powernv_cpufreq_reboot_notifier	drivers/cpufreq/powernv-cpufreq.c	/^static int powernv_cpufreq_reboot_notifier(struct notifier_block *nb,$/;"	f	file:
tags:poweroff_cmd	kernel/reboot.c	/^char poweroff_cmd[POWEROFF_CMD_PATH_LEN] = "\/sbin\/poweroff";$/;"	v
tags:poweroff_force	kernel/reboot.c	/^static bool poweroff_force;$/;"	v	file:
tags:poweroff_work_func	kernel/reboot.c	/^static void poweroff_work_func(struct work_struct *work)$/;"	f	file:
tags:pr_fmt	arch/x86/kernel/reboot.c	1;"	d	file:
tags:pr_fmt	kernel/reboot.c	7;"	d	file:
tags:preboot_source	drivers/scsi/isci/probe_roms.h	/^	uint8_t preboot_source;$/;"	m	struct:sci_bios_oem_param_block_hdr
tags:preboot_vp	drivers/scsi/bfa/bfa_defs_fcs.h	/^	bfa_boolean_t   preboot_vp;  \/*  vport created from PBC *\/$/;"	m	struct:bfa_lport_cfg_s
tags:priv	include/linux/lockd/xdr.h	/^	struct nsm_private	priv;$/;"	m	struct:nlm_reboot	typeref:struct:nlm_reboot::nsm_private
tags:prom_reboot	arch/m68k/sun3/prom/misc.c	/^prom_reboot(char *bcommand)$/;"	f
tags:prom_reboot	arch/sparc/prom/misc_32.c	/^prom_reboot(char *bcommand)$/;"	f
tags:prom_reboot	arch/sparc/prom/misc_64.c	/^void prom_reboot(const char *bcommand)$/;"	f
tags:psci_sys_reset	arch/arm/kernel/psci.c	/^static void psci_sys_reset(enum reboot_mode reboot_mode, const char *cmd)$/;"	f	file:
tags:psci_sys_reset	arch/arm64/kernel/psci.c	/^static void psci_sys_reset(enum reboot_mode reboot_mode, const char *cmd)$/;"	f	file:
tags:pv_reboot	arch/m68k/include/asm/openprom.h	/^	void		(*pv_reboot)(char *bootstr);$/;"	m	struct:linux_romvec
tags:pv_reboot	arch/m68k/include/asm/openprom.h	/^	void (*pv_reboot)(char *bootstr);$/;"	m	struct:linux_romvec
tags:pv_reboot	arch/sparc/include/asm/openprom.h	/^	void (*pv_reboot)(char *bootstr);$/;"	m	struct:linux_romvec
tags:pxa168_restart	arch/arm/mach-mmp/pxa168.c	/^void pxa168_restart(enum reboot_mode mode, const char *cmd)$/;"	f
tags:pxa_restart	arch/arm/mach-pxa/reset.c	/^void pxa_restart(enum reboot_mode mode, const char *cmd)$/;"	f
tags:r8a7740_restart	arch/arm/mach-shmobile/setup-r8a7740.c	/^static void r8a7740_restart(enum reboot_mode mode, const char *cmd)$/;"	f	file:
tags:rdc321x_reset	arch/x86/kernel/reboot_fixups_32.c	/^static void rdc321x_reset(struct pci_dev *dev)$/;"	f	file:
tags:realview_eb_restart	arch/arm/mach-realview/realview_eb.c	/^static void realview_eb_restart(enum reboot_mode mode, const char *cmd)$/;"	f	file:
tags:realview_pb1176_restart	arch/arm/mach-realview/realview_pb1176.c	/^static void realview_pb1176_restart(enum reboot_mode mode, const char *cmd)$/;"	f	file:
tags:realview_pb11mp_restart	arch/arm/mach-realview/realview_pb11mp.c	/^static void realview_pb11mp_restart(enum reboot_mode mode, const char *cmd)$/;"	f	file:
tags:realview_pba8_restart	arch/arm/mach-realview/realview_pba8.c	/^static void realview_pba8_restart(enum reboot_mode mode, const char *cmd)$/;"	f	file:
tags:realview_pbx_restart	arch/arm/mach-realview/realview_pbx.c	/^static void realview_pbx_restart(enum reboot_mode mode, const char *cmd)$/;"	f	file:
tags:reboot	arch/mips/include/asm/sgiarcs.h	/^	LONG	reboot;			\/* Reboot the machine. *\/$/;"	m	struct:linux_romvec
tags:reboot	arch/mips/lantiq/clk.h	/^	void (*reboot) (struct clk *clk);$/;"	m	struct:clk
tags:reboot	drivers/md/bcache/super.c	/^static struct notifier_block reboot = {$/;"	v	typeref:struct:notifier_block	file:
tags:reboot	drivers/usb/atm/ueagle-atm.c	/^static ssize_t reboot(struct device *dev, struct device_attribute *attr,$/;"	f	file:
tags:reboot	drivers/watchdog/cpwd.c	/^	bool		reboot;$/;"	m	struct:cpwd	file:
tags:reboot	include/linux/pid_namespace.h	/^	int reboot;	\/* group exit code if this pidns was rebooted *\/$/;"	m	struct:pid_namespace
tags:reboot	tools/testing/ktest/ktest.pl	/^sub reboot {$/;"	s
tags:reboot_callback	drivers/tty/ipwireless/hardware.c	/^	void (*reboot_callback) (void *data);$/;"	m	struct:ipw_hardware	file:
tags:reboot_callback_data	drivers/tty/ipwireless/hardware.c	/^	void *reboot_callback_data;$/;"	m	struct:ipw_hardware	file:
tags:reboot_command	arch/sparc/kernel/setup_32.c	/^char reboot_command[COMMAND_LINE_SIZE];$/;"	v
tags:reboot_command	arch/sparc/kernel/setup_64.c	/^char reboot_command[COMMAND_LINE_SIZE];$/;"	v
tags:reboot_count	drivers/char/nwbutton.c	/^static int reboot_count = NUM_PRESSES_REBOOT; \/* Number of presses to reboot *\/$/;"	v	file:
tags:reboot_cpu	kernel/reboot.c	/^int reboot_cpu;$/;"	v
tags:reboot_data_supported	arch/sparc/kernel/ds.c	/^static int reboot_data_supported;$/;"	v	file:
tags:reboot_default	kernel/reboot.c	/^int reboot_default = 1;$/;"	v
tags:reboot_dmi_table	arch/x86/kernel/reboot.c	/^static struct dmi_system_id __initdata reboot_dmi_table[] = {$/;"	v	typeref:struct:__initdata	file:
tags:reboot_emergency	arch/x86/kernel/reboot.c	/^static int reboot_emergency;$/;"	v	file:
tags:reboot_fixup	arch/x86/kernel/reboot_fixups_32.c	/^	void (*reboot_fixup)(struct pci_dev *);$/;"	m	struct:device_fixup	file:
tags:reboot_force	kernel/reboot.c	/^int reboot_force;$/;"	v
tags:reboot_info	drivers/video/fbdev/aty/atyfb_base.c	/^static struct fb_info *reboot_info;$/;"	v	typeref:struct:fb_info	file:
tags:reboot_init	arch/x86/kernel/reboot.c	/^core_initcall(reboot_init);$/;"	v
tags:reboot_init	arch/x86/kernel/reboot.c	/^static int __init reboot_init(void)$/;"	f	file:
tags:reboot_mode	arch/arm/include/asm/mach/arch.h	/^	enum reboot_mode	reboot_mode;	\/* default restart mode	*\/$/;"	m	struct:machine_desc	typeref:enum:machine_desc::reboot_mode
tags:reboot_mode	include/linux/reboot.h	/^enum reboot_mode {$/;"	g
tags:reboot_nb	drivers/staging/olpc_dcon/olpc_dcon.h	/^	struct notifier_block reboot_nb;$/;"	m	struct:dcon_priv	typeref:struct:dcon_priv::notifier_block
tags:reboot_notifier	arch/um/drivers/mconsole_kern.c	/^static struct notifier_block reboot_notifier = {$/;"	v	typeref:struct:notifier_block	file:
tags:reboot_notifier	include/linux/mtd/mtd.h	/^	struct notifier_block reboot_notifier;  \/* default mode before reboot *\/$/;"	m	struct:mtd_info	typeref:struct:mtd_info::notifier_block
tags:reboot_notifier	sound/pci/hda/hda_priv.h	/^	struct notifier_block reboot_notifier;$/;"	m	struct:azx	typeref:struct:azx::notifier_block
tags:reboot_notifier_list	kernel/notifier.c	/^BLOCKING_NOTIFIER_HEAD(reboot_notifier_list);$/;"	v
tags:reboot_notify	sound/pci/hda/hda_codec.h	/^	void (*reboot_notify)(struct hda_codec *codec);$/;"	m	struct:hda_codec_ops
tags:reboot_offset	drivers/power/reset/hisi-reboot.c	/^static u32 reboot_offset;$/;"	v	file:
tags:reboot_pid_ns	include/linux/pid_namespace.h	/^static inline int reboot_pid_ns(struct pid_namespace *pid_ns, int cmd)$/;"	f
tags:reboot_pid_ns	kernel/pid_namespace.c	/^int reboot_pid_ns(struct pid_namespace *pid_ns, int cmd)$/;"	f
tags:reboot_reason_code	include/linux/mfd/abx500/ab8500-sysctrl.h	/^	u16 (*reboot_reason_code)(const char *cmd);$/;"	m	struct:ab8500_sysctrl_platform_data
tags:reboot_recovery_ops	fs/nfs/nfs4_fs.h	/^	const struct nfs4_state_recovery_ops *reboot_recovery_ops;$/;"	m	struct:nfs4_minor_version_ops	typeref:struct:nfs4_minor_version_ops::nfs4_state_recovery_ops
tags:reboot_setup	arch/mips/sgi-ip22/ip22-reset.c	/^static int __init reboot_setup(void)$/;"	f	file:
tags:reboot_setup	arch/mips/sgi-ip22/ip22-reset.c	/^subsys_initcall(reboot_setup);$/;"	v
tags:reboot_setup	kernel/reboot.c	/^static int __init reboot_setup(char *str)$/;"	f	file:
tags:reboot_skas	arch/um/os-Linux/skas/process.c	/^void reboot_skas(void)$/;"	f
tags:reboot_to	tools/testing/ktest/ktest.pl	/^sub reboot_to {$/;"	s
tags:reboot_to_good	tools/testing/ktest/ktest.pl	/^sub reboot_to_good {$/;"	s
tags:reboot_type	include/linux/reboot.h	/^enum reboot_type {$/;"	g
tags:reboot_type	kernel/reboot.c	/^enum reboot_type reboot_type = BOOT_ACPI;$/;"	v	typeref:enum:reboot_type
tags:rebooted	drivers/net/ethernet/myricom/myri10ge/myri10ge.c	/^	int rebooted;$/;"	m	struct:myri10ge_priv	file:
tags:rebooting	drivers/cpufreq/powernv-cpufreq.c	/^static bool rebooting;$/;"	v	file:
tags:rebooting_msg	arch/sparc/kernel/sstate.c	/^static const char rebooting_msg[32] __attribute__((aligned(32))) =$/;"	v	file:
tags:register_reboot_notifier	kernel/reboot.c	/^EXPORT_SYMBOL(register_reboot_notifier);$/;"	v
tags:register_reboot_notifier	kernel/reboot.c	/^int register_reboot_notifier(struct notifier_block *nb)$/;"	f
tags:register_restart_handler	kernel/reboot.c	/^EXPORT_SYMBOL(register_restart_handler);$/;"	v
tags:register_restart_handler	kernel/reboot.c	/^int register_restart_handler(struct notifier_block *nb)$/;"	f
tags:regmap	drivers/power/reset/brcmstb-reboot.c	/^static struct regmap *regmap;$/;"	v	typeref:struct:regmap	file:
tags:reset_bits_40nm	drivers/power/reset/brcmstb-reboot.c	/^static const struct reset_reg_mask reset_bits_40nm = {$/;"	v	typeref:struct:reset_reg_mask	file:
tags:reset_bits_65nm	drivers/power/reset/brcmstb-reboot.c	/^static const struct reset_reg_mask reset_bits_65nm = {$/;"	v	typeref:struct:reset_reg_mask	file:
tags:reset_masks	drivers/power/reset/brcmstb-reboot.c	/^static const struct reset_reg_mask *reset_masks;$/;"	v	typeref:struct:reset_reg_mask	file:
tags:reset_reg_mask	drivers/power/reset/brcmstb-reboot.c	/^struct reset_reg_mask {$/;"	s	file:
tags:restart	arch/arm/include/asm/mach/arch.h	/^	void			(*restart)(enum reboot_mode, const char *);$/;"	m	struct:machine_desc
tags:restart	arch/sh/include/asm/reboot.h	/^	void (*restart)(char *cmd);$/;"	m	struct:machine_ops
tags:restart	arch/x86/include/asm/reboot.h	/^	void (*restart)(char *cmd);$/;"	m	struct:machine_ops
tags:restart_handler	drivers/power/reset/syscon-reboot.c	/^	struct notifier_block restart_handler;$/;"	m	struct:syscon_reboot_context	typeref:struct:syscon_reboot_context::notifier_block	file:
tags:restart_handler	drivers/power/reset/xgene-reboot.c	/^	struct notifier_block restart_handler;$/;"	m	struct:xgene_reboot_context	typeref:struct:xgene_reboot_context::notifier_block	file:
tags:rpc_restart	arch/arm/mach-rpc/riscpc.c	/^static void rpc_restart(enum reboot_mode mode, const char *cmd)$/;"	f	file:
tags:rst_src_en	drivers/power/reset/brcmstb-reboot.c	/^static u32 rst_src_en;$/;"	v	file:
tags:rst_src_en_mask	drivers/power/reset/brcmstb-reboot.c	/^	u32 rst_src_en_mask;$/;"	m	struct:reset_reg_mask	file:
tags:rsvd	drivers/scsi/bfa/bfad_bsg.h	/^	u16		rsvd;$/;"	m	struct:bfa_bsg_preboot_s
tags:rtas_flash_firmware	arch/powerpc/kernel/rtas_flash.c	/^static void rtas_flash_firmware(int reboot_type)$/;"	f	file:
tags:s3c2416_cpufreq_reboot_notifier	drivers/cpufreq/s3c2416-cpufreq.c	/^static struct notifier_block s3c2416_cpufreq_reboot_notifier = {$/;"	v	typeref:struct:notifier_block	file:
tags:s3c2416_cpufreq_reboot_notifier_evt	drivers/cpufreq/s3c2416-cpufreq.c	/^static int s3c2416_cpufreq_reboot_notifier_evt(struct notifier_block *this,$/;"	f	file:
tags:s3c64xx_dt_restart	arch/arm/mach-s3c64xx/mach-s3c64xx-dt.c	/^static void s3c64xx_dt_restart(enum reboot_mode mode, const char *cmd)$/;"	f	file:
tags:s3c64xx_restart	arch/arm/mach-s3c64xx/common.c	/^void s3c64xx_restart(enum reboot_mode mode, const char *cmd)$/;"	f
tags:s5pv210_cpufreq_reboot_notifier	drivers/cpufreq/s5pv210-cpufreq.c	/^static struct notifier_block s5pv210_cpufreq_reboot_notifier = {$/;"	v	typeref:struct:notifier_block	file:
tags:s5pv210_cpufreq_reboot_notifier_event	drivers/cpufreq/s5pv210-cpufreq.c	/^static int s5pv210_cpufreq_reboot_notifier_event(struct notifier_block *this,$/;"	f	file:
tags:s5pv210_dt_restart	arch/arm/mach-s5pv210/s5pv210.c	/^static void s5pv210_dt_restart(enum reboot_mode mode, const char *cmd)$/;"	f	file:
tags:sa11x0_restart	arch/arm/mach-sa1100/generic.c	/^void sa11x0_restart(enum reboot_mode mode, const char *cmd)$/;"	f
tags:sclp_reboot_event	drivers/s390/char/sclp.c	/^sclp_reboot_event(struct notifier_block *this, unsigned long event, void *ptr)$/;"	f	file:
tags:sclp_reboot_notifier	drivers/s390/char/sclp.c	/^static struct notifier_block sclp_reboot_notifier = {$/;"	v	typeref:struct:notifier_block	file:
tags:scons_pwroff	arch/sparc/kernel/reboot.c	/^int scons_pwroff = 1;$/;"	v
tags:set_bios_reboot	arch/x86/kernel/reboot.c	/^static int __init set_bios_reboot(const struct dmi_system_id *d)$/;"	f	file:
tags:set_kbd_reboot	arch/x86/kernel/reboot.c	/^static int __init set_kbd_reboot(const struct dmi_system_id *d)$/;"	f	file:
tags:set_pci_reboot	arch/x86/kernel/reboot.c	/^static int __init set_pci_reboot(const struct dmi_system_id *d)$/;"	f	file:
tags:setup_mm_for_reboot	arch/arm/mm/idmap.c	/^void setup_mm_for_reboot(void)$/;"	f
tags:setup_mm_for_reboot	arch/arm/mm/nommu.c	/^void setup_mm_for_reboot(void)$/;"	f
tags:setup_mm_for_reboot	arch/arm64/mm/mmu.c	/^void setup_mm_for_reboot(void)$/;"	f
tags:setup_mm_for_reboot	arch/unicore32/mm/mmu.c	/^void setup_mm_for_reboot(void)$/;"	f
tags:sh73a0_restart	arch/arm/mach-shmobile/setup-sh73a0.c	/^static void sh73a0_restart(enum reboot_mode mode, const char *cmd)$/;"	f	file:
tags:shootdown_callback	arch/x86/kernel/reboot.c	/^static nmi_shootdown_cb shootdown_callback;$/;"	v	file:
tags:shutdown	arch/sh/include/asm/reboot.h	/^	void (*shutdown)(void);$/;"	m	struct:machine_ops
tags:shutdown	arch/x86/include/asm/reboot.h	/^	void (*shutdown)(void);$/;"	m	struct:machine_ops
tags:siena_mcdi_poll_reboot	drivers/net/ethernet/sfc/siena.c	/^static int siena_mcdi_poll_reboot(struct efx_nic *efx)$/;"	f	file:
tags:signalled_reboot_callback	drivers/tty/ipwireless/main.c	/^static void signalled_reboot_callback(void *callback_data)$/;"	f	file:
tags:signalled_reboot_work	drivers/tty/ipwireless/main.c	/^static void signalled_reboot_work(struct work_struct *work_reboot)$/;"	f	file:
tags:sirfsoc_restart	arch/arm/mach-prima2/rstc.c	/^static void sirfsoc_restart(enum reboot_mode mode, const char *cmd)$/;"	f	file:
tags:smp_reboot_interrupt	arch/x86/kernel/smp.c	/^asmlinkage __visible void smp_reboot_interrupt(void)$/;"	f
tags:smp_send_nmi_allbutself	arch/x86/kernel/reboot.c	/^static void smp_send_nmi_allbutself(void)$/;"	f	file:
tags:smp_send_stop	arch/tile/kernel/reboot.c	25;"	d	file:
tags:snd_hda_bus_reboot_notify	sound/pci/hda/hda_codec.c	/^EXPORT_SYMBOL_GPL(snd_hda_bus_reboot_notify);$/;"	v
tags:snd_hda_bus_reboot_notify	sound/pci/hda/hda_codec.c	/^void snd_hda_bus_reboot_notify(struct hda_bus *bus)$/;"	f
tags:socfpga_cyclone5_restart	arch/arm/mach-socfpga/socfpga.c	/^static void socfpga_cyclone5_restart(enum reboot_mode mode, const char *cmd)$/;"	f	file:
tags:spear_restart	arch/arm/mach-spear/restart.c	/^void spear_restart(enum reboot_mode mode, const char *cmd)$/;"	f
tags:spitz_restart	arch/arm/mach-pxa/spitz.c	/^static void spitz_restart(enum reboot_mode mode, const char *cmd)$/;"	f	file:
tags:sstate_reboot_call	arch/sparc/kernel/sstate.c	/^static int sstate_reboot_call(struct notifier_block *np, unsigned long type, void *_unused)$/;"	f	file:
tags:sstate_reboot_notifier	arch/sparc/kernel/sstate.c	/^static struct notifier_block sstate_reboot_notifier = {$/;"	v	typeref:struct:notifier_block	file:
tags:state	include/linux/lockd/xdr.h	/^	u32			state;$/;"	m	struct:nlm_reboot
tags:status	drivers/scsi/bfa/bfad_bsg.h	/^	bfa_status_t	status;$/;"	m	struct:bfa_bsg_preboot_s
tags:sun3_reboot	arch/m68k/sun3/config.c	/^static void sun3_reboot (void)$/;"	f	file:
tags:sun3x_prom_reboot	arch/m68k/sun3x/prom.c	/^void (*sun3x_prom_reboot)(void);$/;"	v
tags:sun3x_reboot	arch/m68k/sun3x/prom.c	/^void sun3x_reboot(void)$/;"	f
tags:sw_mstr_rst	drivers/power/reset/brcmstb-reboot.c	/^static u32 sw_mstr_rst;$/;"	v	file:
tags:sw_mstr_rst_mask	drivers/power/reset/brcmstb-reboot.c	/^	u32 sw_mstr_rst_mask;$/;"	m	struct:reset_reg_mask	file:
tags:syscon_reboot_context	drivers/power/reset/syscon-reboot.c	/^struct syscon_reboot_context {$/;"	s	file:
tags:syscon_reboot_driver	drivers/power/reset/syscon-reboot.c	/^module_platform_driver(syscon_reboot_driver);$/;"	v
tags:syscon_reboot_driver	drivers/power/reset/syscon-reboot.c	/^static struct platform_driver syscon_reboot_driver = {$/;"	v	typeref:struct:platform_driver	file:
tags:syscon_reboot_of_match	drivers/power/reset/syscon-reboot.c	/^static struct of_device_id syscon_reboot_of_match[] = {$/;"	v	typeref:struct:of_device_id	file:
tags:syscon_reboot_probe	drivers/power/reset/syscon-reboot.c	/^static int syscon_reboot_probe(struct platform_device *pdev)$/;"	f	file:
tags:syscon_regmap	drivers/power/reset/arm-versatile-reboot.c	/^static struct regmap *syscon_regmap;$/;"	v	typeref:struct:regmap	file:
tags:syscon_restart_handle	drivers/power/reset/syscon-reboot.c	/^static int syscon_restart_handle(struct notifier_block *this,$/;"	f	file:
tags:sysctl_reboot	arch/mips/lantiq/falcon/sysctrl.c	/^static void sysctl_reboot(struct clk *clk)$/;"	f	file:
tags:sysrq_handle_reboot	drivers/tty/sysrq.c	/^static void sysrq_handle_reboot(int key)$/;"	f	file:
tags:sysrq_reboot_op	drivers/tty/sysrq.c	/^static struct sysrq_key_op sysrq_reboot_op = {$/;"	v	typeref:struct:sysrq_key_op	file:
tags:tegra_pmc_restart	drivers/soc/tegra/pmc.c	/^void tegra_pmc_restart(enum reboot_mode mode, const char *cmd)$/;"	f
tags:ti81xx_restart	arch/arm/mach-omap2/common.h	/^static inline void ti81xx_restart(enum reboot_mode mode, const char *cmd)$/;"	f
tags:ti81xx_restart	arch/arm/mach-omap2/ti81xx-restart.c	/^void ti81xx_restart(enum reboot_mode mode, const char *cmd)$/;"	f
tags:tosa_restart	arch/arm/mach-pxa/tosa.c	/^static void tosa_restart(enum reboot_mode mode, const char *cmd)$/;"	f	file:
tags:trace_reboot_interrupt	arch/x86/include/asm/hw_irq.h	93;"	d
tags:tts_notify_reboot	drivers/acpi/sleep.c	/^static int tts_notify_reboot(struct notifier_block *this,$/;"	f	file:
tags:u300_restart	arch/arm/mach-u300/core.c	/^static void u300_restart(enum reboot_mode mode, const char *cmd)$/;"	f	file:
tags:uml_cleanup	arch/um/kernel/reboot.c	/^void uml_cleanup(void)$/;"	f
tags:unregister_reboot_notifier	kernel/reboot.c	/^EXPORT_SYMBOL(unregister_reboot_notifier);$/;"	v
tags:unregister_reboot_notifier	kernel/reboot.c	/^int unregister_reboot_notifier(struct notifier_block *nb)$/;"	f
tags:unregister_restart_handler	kernel/reboot.c	/^EXPORT_SYMBOL(unregister_restart_handler);$/;"	v
tags:unregister_restart_handler	kernel/reboot.c	/^int unregister_restart_handler(struct notifier_block *nb)$/;"	f
tags:ux500_restart	arch/arm/mach-ux500/cpu.c	/^void ux500_restart(enum reboot_mode mode, const char *cmd)$/;"	f
tags:vendor	arch/x86/kernel/reboot_fixups_32.c	/^	unsigned int vendor;$/;"	m	struct:device_fixup	file:
tags:versatile_reboot	drivers/power/reset/arm-versatile-reboot.c	/^enum versatile_reboot {$/;"	g	file:
tags:versatile_reboot	drivers/power/reset/arm-versatile-reboot.c	/^static int versatile_reboot(struct notifier_block *this, unsigned long mode,$/;"	f	file:
tags:versatile_reboot_nb	drivers/power/reset/arm-versatile-reboot.c	/^static struct notifier_block versatile_reboot_nb = {$/;"	v	typeref:struct:notifier_block	file:
tags:versatile_reboot_of_match	drivers/power/reset/arm-versatile-reboot.c	/^static const struct of_device_id versatile_reboot_of_match[] = {$/;"	v	typeref:struct:of_device_id	file:
tags:versatile_reboot_probe	drivers/power/reset/arm-versatile-reboot.c	/^device_initcall(versatile_reboot_probe);$/;"	v
tags:versatile_reboot_probe	drivers/power/reset/arm-versatile-reboot.c	/^static int __init versatile_reboot_probe(void)$/;"	f	file:
tags:versatile_reboot_type	drivers/power/reset/arm-versatile-reboot.c	/^static enum versatile_reboot versatile_reboot_type;$/;"	v	typeref:enum:versatile_reboot	file:
tags:versatile_restart	arch/arm/mach-versatile/core.c	/^void versatile_restart(enum reboot_mode mode, const char *cmd)$/;"	f
tags:vmcmd_on_reboot	arch/s390/kernel/ipl.c	/^static char vmcmd_on_reboot[128];$/;"	v	file:
tags:vmcmd_on_reboot_setup	arch/s390/kernel/ipl.c	/^static int __init vmcmd_on_reboot_setup(char *str)$/;"	f	file:
tags:vmxoff_nmi	arch/x86/kernel/reboot.c	/^static void vmxoff_nmi(int cpu, struct pt_regs *regs)$/;"	f	file:
tags:voiceblue_restart	arch/arm/mach-omap1/board-voiceblue.c	/^static void voiceblue_restart(enum reboot_mode mode, const char *cmd)$/;"	f	file:
tags:vt8500_restart	arch/arm/mach-vt8500/vt8500.c	/^static void vt8500_restart(enum reboot_mode mode, const char *cmd)$/;"	f	file:
tags:waiting_for_crash_ipi	arch/x86/kernel/reboot.c	/^static atomic_t waiting_for_crash_ipi;$/;"	v	file:
tags:warm_reboot_timeout_msec	include/linux/mfd/cros_ec_commands.h	/^	uint16_t warm_reboot_timeout_msec;$/;"	m	struct:ec_params_hang_detect
tags:watchdog_caused_reboot	drivers/hwmon/w83793.c	/^	unsigned int watchdog_caused_reboot;$/;"	m	struct:w83793_data	file:
tags:watchdog_trigger_immediate	arch/sh/kernel/reboot.c	/^static void watchdog_trigger_immediate(void)$/;"	f	file:
tags:wdog_reboot_handler	drivers/char/ipmi/ipmi_watchdog.c	/^static int wdog_reboot_handler(struct notifier_block *this,$/;"	f	file:
tags:wdog_reboot_notifier	drivers/char/ipmi/ipmi_watchdog.c	/^static struct notifier_block wdog_reboot_notifier = {$/;"	v	typeref:struct:notifier_block	file:
tags:wdrtas_reboot	drivers/watchdog/wdrtas.c	/^static int wdrtas_reboot(struct notifier_block *this,$/;"	f	file:
tags:work_reboot	drivers/tty/ipwireless/main.h	/^	struct work_struct work_reboot;$/;"	m	struct:ipw_dev	typeref:struct:ipw_dev::work_struct
tags:xen_reboot	arch/x86/xen/enlighten.c	/^static void xen_reboot(int reason)$/;"	f	file:
tags:xen_reboot_nb	drivers/xen/manage.c	/^static struct notifier_block xen_reboot_nb = {$/;"	v	typeref:struct:notifier_block	file:
tags:xen_restart	arch/arm/xen/enlighten.c	/^static void xen_restart(enum reboot_mode reboot_mode, const char *cmd)$/;"	f	file:
tags:xgene_reboot_context	drivers/power/reset/xgene-reboot.c	/^struct xgene_reboot_context {$/;"	s	file:
tags:xgene_reboot_driver	drivers/power/reset/xgene-reboot.c	/^static struct platform_driver xgene_reboot_driver = {$/;"	v	typeref:struct:platform_driver	file:
tags:xgene_reboot_init	drivers/power/reset/xgene-reboot.c	/^device_initcall(xgene_reboot_init);$/;"	v
tags:xgene_reboot_init	drivers/power/reset/xgene-reboot.c	/^static int __init xgene_reboot_init(void)$/;"	f	file:
tags:xgene_reboot_of_match	drivers/power/reset/xgene-reboot.c	/^static struct of_device_id xgene_reboot_of_match[] = {$/;"	v	typeref:struct:of_device_id	file:
tags:xgene_reboot_probe	drivers/power/reset/xgene-reboot.c	/^static int xgene_reboot_probe(struct platform_device *pdev)$/;"	f	file:
tags:xgene_restart_handler	drivers/power/reset/xgene-reboot.c	/^static int xgene_restart_handler(struct notifier_block *this,$/;"	f	file:
tags:xpSystemReboot	drivers/misc/sgi-xp/xp.h	/^	xpSystemReboot,		\/* 47: system is being rebooted *\/$/;"	e	enum:xp_retval
tags:xpc_reboot_notifier	drivers/misc/sgi-xp/xpc_main.c	/^static struct notifier_block xpc_reboot_notifier = {$/;"	v	typeref:struct:notifier_block	file:
tags:xpc_system_reboot	drivers/misc/sgi-xp/xpc_main.c	/^xpc_system_reboot(struct notifier_block *nb, unsigned long event, void *unused)$/;"	f	file:
tags:yl2f89_reboot	arch/mips/loongson/lemote-2f/reset.c	87;"	d	file:
tags:zynq_system_reset	arch/arm/mach-zynq/common.c	/^static void zynq_system_reset(enum reboot_mode mode, const char *cmd)$/;"	f	file:
block/partitions/Kconfig:	  rebooting.
 .git/index () 
scripts/checkpatch.pl:	reboot
net/ipv6/af_inet6.c:		pr_info("Loaded, but administratively disabled, reboot required to enable\n");
net/rds/threads.c: * a rebooted machine replace an existing stale connection before the transport
net/iucv/iucv.c:#include <linux/reboot.h>
net/iucv/iucv.c:static int iucv_reboot_event(struct notifier_block *this,
net/iucv/iucv.c:static struct notifier_block iucv_reboot_notifier = {
net/iucv/iucv.c:	.notifier_call = iucv_reboot_event,
net/iucv/iucv.c:	rc = register_reboot_notifier(&iucv_reboot_notifier);
net/iucv/iucv.c:		goto out_reboot;
net/iucv/iucv.c:out_reboot:
net/iucv/iucv.c:	unregister_reboot_notifier(&iucv_reboot_notifier);
net/iucv/iucv.c:	unregister_reboot_notifier(&iucv_reboot_notifier);
net/batman-adv/bat_iv_ogm.c: * @BATADV_PROTECTED: originator is currently protected (after reboot)
net/atm/lec.c: * there is non-reboot way to recover if something goes wrong.
net/sunrpc/svc.c: * rebooting or re-loading sunrpc.ko.
net/netfilter/nf_nat_core.c:	 * like this), even across reboots.
net/bluetooth/hidp/core.c:		/* Device requests a reboot, as this is the only way this error
net/tipc/discover.c:		/* Peer has changed i/f address without rebooting.
net/tipc/discover.c:		/* Peer link has changed i/f address without rebooting.
net/tipc/discover.c:		/* Peer node rebooted. Two possibilities:
net/tipc/discover.c:		/*  The peer node has rebooted.
net/tipc/discover.c:		/* Peer rebooted with new address, or a new/duplicate peer.
net/tipc/discover.c:		/* Peer rebooted with new address, or it is a new peer.
CREDITS:D: /proc/cpuinfo, reboot on panic , kernel pre-patch tester ;)
CREDITS:D: Arc monochrome LCD framebuffer driver, x86 reboot fixups
include/uapi/asm-generic/unistd.h:#define __NR_reboot 142
include/uapi/asm-generic/unistd.h:__SYSCALL(__NR_reboot, sys_reboot)
include/uapi/mtd/ubi-user.h: * erased. Note, the side effect of this is that if an unclean reboot happens
include/uapi/linux/reboot.h: * Magic values required to use _reboot() system call.
include/uapi/linux/reboot.h: * Commands accepted by the _reboot() system call.
include/uapi/linux/capability.h:/* Allow use of reboot() */
include/uapi/linux/Kbuild:header-y += reboot.h
include/uapi/linux/watchdog.h:					   other external alarm not a reboot */
include/uapi/linux/sysctl.h:	KERN_SPARC_REBOOT=21,	/* reboot command on Sparc */
include/uapi/linux/sysctl.h:	KERN_CTLALTDEL=22,	/* int: allow ctl-alt-del to reboot */
include/asm-generic/bug.h: * users don't need to reboot ASAP and can mostly shut down cleanly.
include/xen/interface/sched.h:#define SHUTDOWN_reboot     1  /* Clean up, kill, and then restart.          */
include/scsi/scsi_host.h:	 * the device is removed from the system (or * possibly at reboot
include/net/tcp.h:	   of this constraint to relax it: if peer reboots, clock may go
include/net/tcp.h:	   via reboots. Linux-2.2 DOES NOT!
include/linux/syscalls.h:asmlinkage long sys_reboot(int magic1, int magic2, unsigned int cmd,
include/linux/reboot.h:#include <uapi/linux/reboot.h>
include/linux/reboot.h:enum reboot_mode {
include/linux/reboot.h:extern enum reboot_mode reboot_mode;
include/linux/reboot.h:enum reboot_type {
include/linux/reboot.h:extern enum reboot_type reboot_type;
include/linux/reboot.h:extern int reboot_default;
include/linux/reboot.h:extern int reboot_cpu;
include/linux/reboot.h:extern int reboot_force;
include/linux/reboot.h:extern int register_reboot_notifier(struct notifier_block *);
include/linux/reboot.h:extern int unregister_reboot_notifier(struct notifier_block *);
include/linux/reboot.h: * Architecture-specific implementations of sys_reboot commands.
include/linux/reboot.h:extern void migrate_to_reboot_cpu(void);
include/linux/reboot.h: * Architecture independent implemenations of sys_reboot commands.
include/linux/kvm_host.h:extern bool kvm_rebooting;
include/linux/pid_namespace.h:	int reboot;	/* group exit code if this pidns was rebooted */
include/linux/pid_namespace.h:extern int reboot_pid_ns(struct pid_namespace *pid_ns, int cmd);
include/linux/pid_namespace.h:static inline int reboot_pid_ns(struct pid_namespace *pid_ns, int cmd)
include/linux/mtd/mtd.h:	void (*_reboot) (struct mtd_info *mtd);
include/linux/mtd/mtd.h:	struct notifier_block reboot_notifier;  /* default mode before reboot */
include/linux/notifier.h: *	over time (eg laptop power reset chains, reboot chain (to clean 
include/linux/notifier.h:/* reboot notifiers are defined in include/linux/reboot.h. */
include/linux/notifier.h:extern struct blocking_notifier_head reboot_notifier_list;
include/linux/efi.h:#include <linux/reboot.h>
include/linux/efi.h:extern int efi_reboot_quirk_mode;
include/linux/efi.h:extern void efi_reboot(enum reboot_mode reboot_mode, const char *__unused);
include/linux/efi.h:efi_reboot(enum reboot_mode reboot_mode, const char *__unused) {}
include/linux/kexec.h:/* flag to track if kexec reboot is in progress */
include/linux/usb.h: * neither does rebooting or re-enumerating.  These are more useful identifiers
include/linux/lockd/xdr4.h:int	nlm4svc_decode_reboot(struct svc_rqst *, __be32 *, struct nlm_reboot *);
include/linux/lockd/xdr.h: * statd callback when client has rebooted
include/linux/lockd/xdr.h:struct nlm_reboot {
include/linux/lockd/xdr.h: * Contents of statd callback when monitored host rebooted
include/linux/lockd/xdr.h:int	nlmsvc_decode_reboot(struct svc_rqst *, __be32 *, struct nlm_reboot *);
include/linux/lockd/lockd.h:void		  nlm_host_rebooted(const struct nlm_reboot *);
include/linux/lockd/lockd.h:struct nsm_handle *nsm_reboot_lookup(const struct nlm_reboot *info);
include/linux/lru_cache.h:  It should also be persistent, to allow for reboots (or crashes)
include/linux/mfd/abx500/ab8500-sysctrl.h:	u16 (*reboot_reason_code)(const char *cmd);
include/linux/mfd/cros_ec_commands.h: * This header file is used in coreboot both in C and ACPI code.  The ACPI code
include/linux/mfd/cros_ec_commands.h:	/* Hang detect logic detected a hang and warm rebooted the AP */
include/linux/mfd/cros_ec_commands.h:/* Entire flash code protected now, until reboot. */
include/linux/mfd/cros_ec_commands.h:	/* Timeout in msec before generating warm reboot, if enabled */
include/linux/mfd/cros_ec_commands.h:	uint16_t warm_reboot_timeout_msec;
include/linux/mfd/cros_ec_commands.h: * necessarily reboot the EC.  Rename to "image" or something similar?
include/linux/mfd/cros_ec_commands.h:enum ec_reboot_cmd {
include/linux/mfd/cros_ec_commands.h:	EC_REBOOT_CANCEL = 0,        /* Cancel a pending reboot */
include/linux/mfd/cros_ec_commands.h:	EC_REBOOT_JUMP_RO = 1,       /* Jump to RO without rebooting */
include/linux/mfd/cros_ec_commands.h:	EC_REBOOT_JUMP_RW = 2,       /* Jump to RW without rebooting */
include/linux/mfd/cros_ec_commands.h:	EC_REBOOT_COLD = 4,          /* Cold-reboot */
include/linux/mfd/cros_ec_commands.h:	EC_REBOOT_DISABLE_JUMP = 5,  /* Disable jump until next reboot */
include/linux/mfd/cros_ec_commands.h:/* Flags for ec_params_reboot_ec.reboot_flags */
include/linux/mfd/cros_ec_commands.h:struct ec_params_reboot_ec {
include/linux/mfd/cros_ec_commands.h:	uint8_t cmd;           /* enum ec_reboot_cmd */
include/linux/mfd/cros_ec_commands.h: * reboot command is processed at interrupt level.  Note that when the EC
include/linux/mfd/cros_ec_commands.h: * reboots, the host will reboot too, so there is no response to this command.
include/linux/mfd/cros_ec_commands.h: * Use EC_CMD_REBOOT_EC to reboot the EC more politely.
include/linux/xz.h: * with support for all operation modes, but the preboot code may
include/acpi/reboot.h:extern void acpi_reboot(void);
include/acpi/reboot.h:static inline void acpi_reboot(void) { }
include/soc/tegra/pmc.h:#include <linux/reboot.h>
include/soc/tegra/pmc.h:void tegra_pmc_restart(enum reboot_mode mode, const char *cmd);
virt/kvm/arm/vgic.c: * rebooting the guest - the interrupt would kick as soon as the CPU
virt/kvm/kvm_main.c:#include <linux/reboot.h>
virt/kvm/kvm_main.c:__visible bool kvm_rebooting;
virt/kvm/kvm_main.c:EXPORT_SYMBOL_GPL(kvm_rebooting);
virt/kvm/kvm_main.c:static int kvm_reboot(struct notifier_block *notifier, unsigned long val,
virt/kvm/kvm_main.c:	 * Some (well, at least mine) BIOSes hang on reboot if
virt/kvm/kvm_main.c:	kvm_rebooting = true;
virt/kvm/kvm_main.c:static struct notifier_block kvm_reboot_notifier = {
virt/kvm/kvm_main.c:	.notifier_call = kvm_reboot,
virt/kvm/kvm_main.c:	register_reboot_notifier(&kvm_reboot_notifier);
virt/kvm/kvm_main.c:	unregister_reboot_notifier(&kvm_reboot_notifier);
virt/kvm/kvm_main.c:	unregister_reboot_notifier(&kvm_reboot_notifier);
security/keys/Kconfig:	  have exited, not that they survive the machine being rebooted.
security/smack/smack_lsm.c:		 * getting recreated on every reboot.
security/selinux/selinuxfs.c:	SEL_DISABLE,	/* disable SELinux until next reboot */
kernel/kexec.c:#include <linux/reboot.h>
kernel/kexec.c:	/* We only trust the superuser with rebooting the system. */
kernel/kexec.c:			/* Loading another kernel to reboot into. */
kernel/kexec.c:	/* We only trust the superuser with rebooting the system. */
kernel/kexec.c:		migrate_to_reboot_cpu();
kernel/kexec.c:		 * migrate_to_reboot_cpu() disables CPU hotplug assuming that
kernel/kexec.c:		 * the reboot case). However, the kexec path depends on using
kernel/reboot.c: *  linux/kernel/reboot.c
kernel/reboot.c:#define pr_fmt(fmt)	"reboot: " fmt
kernel/reboot.c:#include <linux/reboot.h>
kernel/reboot.c: * this indicates whether you can reboot with ctrl-alt-del: the default is yes
kernel/reboot.c:enum reboot_mode reboot_mode DEFAULT_REBOOT_MODE;
kernel/reboot.c: * reboot_type is still set to its default value (i.e., reboot= hasn't
kernel/reboot.c: * suppress DMI scanning for reboot quirks.  Without it, it's
kernel/reboot.c: * impossible to override a faulty reboot quirk without recompiling.
kernel/reboot.c:int reboot_default = 1;
kernel/reboot.c:int reboot_cpu;
kernel/reboot.c:enum reboot_type reboot_type = BOOT_ACPI;
kernel/reboot.c:int reboot_force;
kernel/reboot.c: *	emergency_restart - reboot the system
kernel/reboot.c: *	reboot the system.  This is called when we know we are in
kernel/reboot.c: *	trouble so this is our best effort to reboot.  This is
kernel/reboot.c:	blocking_notifier_call_chain(&reboot_notifier_list, SYS_RESTART, cmd);
kernel/reboot.c: *	register_reboot_notifier - Register function to be called at reboot time
kernel/reboot.c: *	to be called at reboot time.
kernel/reboot.c:int register_reboot_notifier(struct notifier_block *nb)
kernel/reboot.c:	return blocking_notifier_chain_register(&reboot_notifier_list, nb);
kernel/reboot.c:EXPORT_SYMBOL(register_reboot_notifier);
kernel/reboot.c: *	unregister_reboot_notifier - Unregister previously registered reboot notifier
kernel/reboot.c: *	Unregisters a previously registered reboot
kernel/reboot.c:int unregister_reboot_notifier(struct notifier_block *nb)
kernel/reboot.c:	return blocking_notifier_chain_unregister(&reboot_notifier_list, nb);
kernel/reboot.c:EXPORT_SYMBOL(unregister_reboot_notifier);
kernel/reboot.c:	atomic_notifier_call_chain(&restart_handler_list, reboot_mode, cmd);
kernel/reboot.c:void migrate_to_reboot_cpu(void)
kernel/reboot.c:	int cpu = reboot_cpu;
kernel/reboot.c:	/* Make certain the cpu I'm about to reboot on is online */
kernel/reboot.c: *	kernel_restart - reboot the system
kernel/reboot.c: *	Shutdown everything and perform a clean reboot.
kernel/reboot.c:	migrate_to_reboot_cpu();
kernel/reboot.c:	blocking_notifier_call_chain(&reboot_notifier_list,
kernel/reboot.c:	migrate_to_reboot_cpu();
kernel/reboot.c:	migrate_to_reboot_cpu();
kernel/reboot.c:static DEFINE_MUTEX(reboot_mutex);
kernel/reboot.c: * so that some mistake won't make this reboot the whole machine.
kernel/reboot.c: * reboot doesn't sync: do that yourself before calling this.
kernel/reboot.c:SYSCALL_DEFINE4(reboot, int, magic1, int, magic2, unsigned int, cmd,
kernel/reboot.c:	/* We only trust the superuser with rebooting the system. */
kernel/reboot.c:	 * pid_namespace, the command is handled by reboot_pid_ns() which will
kernel/reboot.c:	ret = reboot_pid_ns(pid_ns, cmd);
kernel/reboot.c:	mutex_lock(&reboot_mutex);
kernel/reboot.c:	mutex_unlock(&reboot_mutex);
kernel/reboot.c: * is whether to reboot at once, or just ignore the ctrl-alt-del.
kernel/reboot.c:static int __init reboot_setup(char *str)
kernel/reboot.c:		 * reboot= will cause us to disable DMI checking
kernel/reboot.c:		reboot_default = 0;
kernel/reboot.c:			reboot_mode = REBOOT_WARM;
kernel/reboot.c:			reboot_mode = REBOOT_COLD;
kernel/reboot.c:			reboot_mode = REBOOT_HARD;
kernel/reboot.c:				rc = kstrtoint(str+1, 0, &reboot_cpu);
kernel/reboot.c:				rc = kstrtoint(str+3, 0, &reboot_cpu);
kernel/reboot.c:				reboot_mode = REBOOT_SOFT;
kernel/reboot.c:			reboot_mode = REBOOT_GPIO;
kernel/reboot.c:			reboot_type = *str;
kernel/reboot.c:			reboot_force = 1;
kernel/reboot.c:__setup("reboot=", reboot_setup);
kernel/events/core.c:#include <linux/reboot.h>
kernel/events/core.c:perf_reboot(struct notifier_block *notifier, unsigned long val, void *v)
kernel/events/core.c: * Run the perf reboot notifier at the very last possible moment so that
kernel/events/core.c:static struct notifier_block perf_reboot_notifier = {
kernel/events/core.c:	.notifier_call = perf_reboot,
kernel/events/core.c:	register_reboot_notifier(&perf_reboot_notifier);
kernel/sysctl_binary.c:	{ CTL_STR,	KERN_SPARC_REBOOT,		"reboot-cmd" },
kernel/rcu/rcutorture.c:#include <linux/reboot.h>
kernel/power/poweroff.c:#include <linux/reboot.h>
kernel/power/hibernate.c:#include <linux/reboot.h>
kernel/power/hibernate.c: * state corresponding to hibernation, or try to power it off or reboot,
kernel/power/hibernate.c:	[HIBERNATION_REBOOT]	= "reboot",
kernel/power/hibernate.c: * or other hibernation_ops), powering it off or rebooting it (for testing
kernel/power/hibernate.c: *	'reboot'
kernel/power/user.c:#include <linux/reboot.h>
kernel/power/Kconfig:	  system and powers it off; and restores that checkpoint on reboot.
kernel/power/Kconfig:	  reboot. The architecture needs to support this, x86 for
kernel/power/Kconfig:	RTC across reboots, so that you can debug a machine that just hangs
kernel/power/Kconfig:	machine, reboot it and then run
kernel/power/Kconfig:	  random kernel OOPSes or reboots that don't seem to be related to
kernel/panic.c:#include <linux/reboot.h>
kernel/panic.c:		 * Delay timeout seconds before rebooting the machine.
kernel/panic.c:		 * This will not be a clean reboot, with everything
kernel/panic.c:		 * rebooting the system it will be rebooted.
kernel/uid16.c:#include <linux/reboot.h>
kernel/hung_task.c: * Should we panic (and reboot, if panic_timeout= is set) when a
kernel/exit.c:	 * leave this task alone and wait for reboot.
kernel/exit.c:		pr_alert("Fixing recursive fault but reboot is needed!\n");
kernel/sys.c:#include <linux/reboot.h>
kernel/Makefile:	    notifier.o ksysfs.o cred.o reboot.o \
kernel/notifier.c:#include <linux/reboot.h>
kernel/notifier.c:BLOCKING_NOTIFIER_HEAD(reboot_notifier_list);
kernel/audit.c:		"enabled (after initialization)" : "disabled (until reboot)");
kernel/torture.c:#include <linux/reboot.h>
kernel/torture.c:	unregister_reboot_notifier(&torture_shutdown_nb);
kernel/torture.c:	register_reboot_notifier(&torture_shutdown_nb);
kernel/debug/debug_core.c:#include <linux/reboot.h>
kernel/debug/debug_core.c:/* Action for the reboot notifiter, a global allow kdb to change it */
kernel/debug/debug_core.c:static int kgdbreboot;
kernel/debug/debug_core.c:module_param(kgdbreboot, int, 0644);
kernel/debug/debug_core.c:	 * reboot on panic. We don't want to get stuck waiting for input
kernel/debug/debug_core.c:	 * reboot on panic.
kernel/debug/debug_core.c:dbg_notify_reboot(struct notifier_block *this, unsigned long code, void *x)
kernel/debug/debug_core.c:	 * Take the following action on reboot notify depending on value:
kernel/debug/debug_core.c:	switch (kgdbreboot) {
kernel/debug/debug_core.c:static struct notifier_block dbg_reboot_notifier = {
kernel/debug/debug_core.c:	.notifier_call		= dbg_notify_reboot,
kernel/debug/debug_core.c:		register_reboot_notifier(&dbg_reboot_notifier);
kernel/debug/debug_core.c:		unregister_reboot_notifier(&dbg_reboot_notifier);
kernel/debug/gdbstub.c:#include <linux/reboot.h>
kernel/debug/gdbstub.c:/* Handle the 'R' reboot packets */
kernel/debug/gdbstub.c:static int gdb_cmd_reboot(struct kgdb_state *ks)
kernel/debug/gdbstub.c:		printk(KERN_CRIT "Executing emergency reboot\n");
kernel/debug/gdbstub.c:			if (gdb_cmd_reboot(ks))
kernel/debug/kdb/kdb_main.c:#include <linux/reboot.h>
kernel/debug/kdb/kdb_main.c: * kdb_reboot - This function implements the 'reboot' command.  Reboot
kernel/debug/kdb/kdb_main.c:static int kdb_reboot(int argc, const char **argv)
kernel/debug/kdb/kdb_main.c:	kdb_printf("Hmm, kdb_reboot did not reboot, spinning here\n");
kernel/debug/kdb/kdb_main.c:			kdb_printf("forcing reboot\n");
kernel/debug/kdb/kdb_main.c:			kdb_reboot(0, NULL);
kernel/debug/kdb/kdb_main.c:	kdb_register_flags("reboot", kdb_reboot, "",
kernel/sysctl.c:#include <linux/reboot.h>
kernel/sysctl.c:		.procname	= "reboot-cmd",
kernel/sysctl.c:		.data		= reboot_command,
kernel/pid_namespace.c:#include <linux/reboot.h>
kernel/pid_namespace.c:	if (pid_ns->reboot)
kernel/pid_namespace.c:		current->signal->group_exit_code = pid_ns->reboot;
kernel/pid_namespace.c:int reboot_pid_ns(struct pid_namespace *pid_ns, int cmd)
kernel/pid_namespace.c:		pid_ns->reboot = SIGHUP;
kernel/pid_namespace.c:		pid_ns->reboot = SIGINT;
lib/Kconfig.kgdb:	    0x0100 - allow machine to be rebooted
lib/Kconfig.kgdb:	  CONFIG_KDB_CONTINUE_CATASTROPHIC == 2. KDB forces a reboot.
lib/Kconfig.debug:	  will be able to flush the buffer cache to disk, reboot the system
lib/Kconfig.debug:	  to cause the system to reboot automatically after a
lib/Kconfig.debug:	  to cause the system to reboot automatically after a
lib/Kconfig.debug:	  Set the timeout value (in seconds) until a reboot occurs when the
lib/Kconfig.debug:	  value n > 0 will wait n seconds before rebooting, while a timeout
lib/Kconfig.debug:	  value n < 0 will reboot immediately.
lib/Kconfig.debug:	 on a single reboot.
arch/mn10300/include/uapi/asm/unistd.h:#define __NR_reboot		 88
arch/mn10300/kernel/entry.S:	.long sys_reboot
arch/mn10300/kernel/process.c:#include <linux/reboot.h>
arch/mn10300/kernel/rtc.c: *      sets the minutes. Usually you'll only notice that after reboot!
arch/microblaze/include/uapi/asm/unistd.h:#define __NR_reboot		88 /* ok */
arch/microblaze/kernel/syscall_table.S:	.long sys_reboot
arch/powerpc/platforms/embedded6xx/linkstation.c:	/* Send reboot command */
arch/powerpc/platforms/pseries/ras.c:#include <linux/reboot.h>
arch/powerpc/platforms/pseries/setup.c:#include <linux/reboot.h>
arch/powerpc/platforms/pseries/cmm.c:#include <linux/reboot.h>
arch/powerpc/platforms/pseries/cmm.c: * cmm_reboot_notifier - Make sure pages are not still marked as "loaned"
arch/powerpc/platforms/pseries/cmm.c:static int cmm_reboot_notifier(struct notifier_block *nb,
arch/powerpc/platforms/pseries/cmm.c:static struct notifier_block cmm_reboot_nb = {
arch/powerpc/platforms/pseries/cmm.c:	.notifier_call = cmm_reboot_notifier,
arch/powerpc/platforms/pseries/cmm.c:	if ((rc = register_reboot_notifier(&cmm_reboot_nb)))
arch/powerpc/platforms/pseries/cmm.c:		goto out_reboot_notifier;
arch/powerpc/platforms/pseries/cmm.c:out_reboot_notifier:
arch/powerpc/platforms/pseries/cmm.c:	unregister_reboot_notifier(&cmm_reboot_nb);
arch/powerpc/platforms/pseries/cmm.c:	unregister_reboot_notifier(&cmm_reboot_nb);
arch/powerpc/platforms/pseries/scanlog.c: * of the system.  After a reboot the operating system can access a dump
arch/powerpc/platforms/maple/setup.c:static void __init maple_use_rtas_reboot_and_halt_if_present(void)
arch/powerpc/platforms/maple/setup.c:	if (rtas_service_present("system-reboot") &&
arch/powerpc/platforms/maple/setup.c:	maple_use_rtas_reboot_and_halt_if_present();
arch/powerpc/platforms/83xx/mpc836x_mds.c:#include <linux/reboot.h>
arch/powerpc/platforms/83xx/mpc834x_itx.c:#include <linux/reboot.h>
arch/powerpc/platforms/83xx/mcu_mpc8349emitx.c:#include <linux/reboot.h>
arch/powerpc/platforms/83xx/km83xx.c:#include <linux/reboot.h>
arch/powerpc/platforms/83xx/sbc834x.c:#include <linux/reboot.h>
arch/powerpc/platforms/83xx/mpc834x_mds.c:#include <linux/reboot.h>
arch/powerpc/platforms/83xx/mpc832x_mds.c:#include <linux/reboot.h>
arch/powerpc/platforms/chrp/setup.c:#include <linux/reboot.h>
arch/powerpc/platforms/52xx/mpc52xx_gpt.c: * this means that gpt0 is locked in wdt mode until the next reboot - this
arch/powerpc/platforms/powernv/opal-wrappers.S:OPAL_CALL(opal_cec_reboot,			OPAL_CEC_REBOOT);
arch/powerpc/platforms/powernv/opal-wrappers.S:OPAL_CALL(opal_sync_host_reboot,		OPAL_SYNC_HOST_REBOOT);
arch/powerpc/platforms/powernv/opal-flash.c:#include <linux/reboot.h>
arch/powerpc/platforms/powernv/opal-flash.c:#define FLASH_IMG_READY		0	/* Img ready for flash on reboot */
arch/powerpc/platforms/powernv/opal-flash.c:/* This gets called just before system reboots */
arch/powerpc/platforms/powernv/opal-flash.c:	pr_alert("FLASH: Performing flash and reboot/shutdown\n");
arch/powerpc/platforms/powernv/opal-power.c:#include <linux/reboot.h>
arch/powerpc/platforms/powernv/setup.c:#include <linux/reboot.h>
arch/powerpc/platforms/powernv/setup.c:		rc = opal_cec_reboot();
arch/powerpc/platforms/powernv/opal.c:		rc = opal_sync_host_reboot();
arch/powerpc/platforms/cell/spu_callbacks.c: *	reboot, init_module, mount, kexec_load
arch/powerpc/platforms/cell/ras.c:#include <linux/reboot.h>
arch/powerpc/platforms/cell/ras.c:static int cbe_ptcal_notify_reboot(struct notifier_block *nb,
arch/powerpc/platforms/cell/ras.c:static struct notifier_block cbe_ptcal_reboot_notifier = {
arch/powerpc/platforms/cell/ras.c:	.notifier_call = cbe_ptcal_notify_reboot
arch/powerpc/platforms/cell/ras.c:	ret = register_reboot_notifier(&cbe_ptcal_reboot_notifier);
arch/powerpc/platforms/cell/ras.c:	unregister_reboot_notifier(&cbe_ptcal_reboot_notifier);
arch/powerpc/platforms/cell/setup.c:#include <linux/reboot.h>
arch/powerpc/platforms/cell/beat.c:#include <linux/reboot.h>
arch/powerpc/platforms/cell/celleb_setup.c:#include <linux/reboot.h>
arch/powerpc/platforms/85xx/mpc85xx_cds.c:#include <linux/reboot.h>
arch/powerpc/platforms/85xx/mpc85xx_mds.c:#include <linux/reboot.h>
arch/powerpc/platforms/85xx/ppa8548.c:#include <linux/reboot.h>
arch/powerpc/platforms/85xx/sgy_cts1000.c:#include <linux/reboot.h>
arch/powerpc/platforms/85xx/sbc8548.c:#include <linux/reboot.h>
arch/powerpc/platforms/ps3/device-init.c:#include <linux/reboot.h>
arch/powerpc/platforms/ps3/device-init.c:	register_reboot_notifier(&nb);
arch/powerpc/platforms/ps3/setup.c:	printk("   System does not reboot automatically.\n");
arch/powerpc/sysdev/uic.c:#include <linux/reboot.h>
arch/powerpc/sysdev/qe_lib/qe_ic.c:#include <linux/reboot.h>
arch/powerpc/sysdev/fsl_soc.c:		printk(KERN_ERR "No RSTCR register, warm reboot won't work\n");
arch/powerpc/sysdev/ipic.c:#include <linux/reboot.h>
arch/powerpc/include/uapi/asm/unistd.h:#define __NR_reboot		 88
arch/powerpc/include/asm/opal.h:	OPAL_MSG_SHUTDOWN,		/* params[0] = 1 reboot, 0 shutdown */
arch/powerpc/include/asm/opal.h:int64_t opal_cec_reboot(void);
arch/powerpc/include/asm/opal.h:int64_t opal_sync_host_reboot(void);
arch/powerpc/include/asm/systbl.h:SYSCALL(reboot)
arch/powerpc/include/asm/fsl_hcalls.h: * fh_partition_restart - reboot the current partition
arch/powerpc/include/asm/fsl_hcalls.h: * Returns an error code if reboot failed.  Does not return if it succeeds.
arch/powerpc/include/asm/machdep.h:	 * reboot code buffer. Returns 0 on success.
arch/powerpc/include/asm/fadump.h:	/* Maximum time allowed to prevent an automatic dump-reboot. */
arch/powerpc/kernel/iommu.c:	 * reboot process at the time of system crash. Hence it's safe to
arch/powerpc/kernel/fadump.c:	 * if dump has been initiated on last reboot.
arch/powerpc/kernel/fadump.c:	/* set 0 to disable an automatic dump-reboot. */
arch/powerpc/kernel/setup_64.c:#include <linux/reboot.h>
arch/powerpc/kernel/machine_kexec_32.c:				unsigned long reboot_code_buffer,
arch/powerpc/kernel/machine_kexec_32.c:	unsigned long reboot_code_buffer, reboot_code_buffer_phys;
arch/powerpc/kernel/machine_kexec_32.c:	/* Interrupts aren't acceptable while we reboot */
arch/powerpc/kernel/machine_kexec_32.c:	reboot_code_buffer =
arch/powerpc/kernel/machine_kexec_32.c:	reboot_code_buffer_phys = virt_to_phys((void *)reboot_code_buffer);
arch/powerpc/kernel/machine_kexec_32.c:	memcpy((void *)reboot_code_buffer, relocate_new_kernel,
arch/powerpc/kernel/machine_kexec_32.c:	flush_icache_range(reboot_code_buffer,
arch/powerpc/kernel/machine_kexec_32.c:				reboot_code_buffer + KEXEC_CONTROL_PAGE_SIZE);
arch/powerpc/kernel/machine_kexec_32.c:	rnk = (relocate_new_kernel_t) reboot_code_buffer;
arch/powerpc/kernel/machine_kexec_32.c:	(*rnk)(page_list, reboot_code_buffer_phys, image->start);
arch/powerpc/kernel/setup_32.c:#include <linux/reboot.h>
arch/powerpc/kernel/rtas_flash.c: * image into the kernel.  At reboot time rtas_restart() will see the
arch/powerpc/kernel/rtas_flash.c: * firmware image and flash it as it reboots (see rtas.c).
arch/powerpc/kernel/rtas_flash.c:#include <linux/reboot.h>
arch/powerpc/kernel/rtas_flash.c:#define FLASH_IMG_READY      0     /* Firmware img ready for flash on reboot */
arch/powerpc/kernel/rtas_flash.c:	printk(KERN_INFO "FLASH: flash image with %ld bytes stored for hardware flash on reboot\n", image_size);
arch/powerpc/kernel/rtas_flash.c:		msg = "ready: firmware image ready for flash on reboot\n";
arch/powerpc/kernel/rtas_flash.c: * On-reboot flash update applicator.
arch/powerpc/kernel/rtas_flash.c:static void rtas_flash_firmware(int reboot_type)
arch/powerpc/kernel/rtas_flash.c:	if (reboot_type != SYS_RESTART) {
arch/powerpc/kernel/rtas_flash.c:		printk(KERN_ALERT "FLASH: firmware flash requires a reboot\n");
arch/powerpc/kernel/rtas_flash.c:	update_token = rtas_token("ibm,update-flash-64-and-reboot");
arch/powerpc/kernel/rtas_flash.c:		printk(KERN_ALERT "FLASH: ibm,update-flash-64-and-reboot "
arch/powerpc/kernel/rtas_flash.c:	printk(KERN_ALERT "FLASH: performing flash and reboot\n");
arch/powerpc/kernel/rtas_flash.c:		printk(KERN_ALERT "FLASH: flash failed when partially complete.  System may not reboot\n");
arch/powerpc/kernel/rtas_flash.c:		.rtas_call_name	= "ibm,update-flash-64-and-reboot",
arch/powerpc/kernel/rtas_flash.c:		.rtas_call_name	= "ibm,update-flash-64-and-reboot",
arch/powerpc/kernel/rtas_flash.c:	if (rtas_token("ibm,update-flash-64-and-reboot") ==
arch/powerpc/kernel/rtasd.c: * This will persist across reboots.
arch/powerpc/kernel/rtasd.c: * on the next reboot by rtasd.  If not fatal, run the
arch/powerpc/kernel/rtasd.c: * record will be created on next reboot.
arch/powerpc/kernel/machine_kexec.c:#include <linux/reboot.h>
arch/powerpc/kernel/machine_kexec.c: * reboot code buffer to allow us to avoid allocations
arch/powerpc/kernel/machine_kexec.c: * We are past the point of no return, committed to rebooting now.
arch/powerpc/kernel/rtas.c:#include <linux/reboot.h>
arch/powerpc/kernel/rtas.c:	printk("RTAS system-reboot returned %d\n",
arch/powerpc/kernel/rtas.c:	       rtas_call(rtas_token("system-reboot"), 0, 1, NULL));
arch/powerpc/kernel/misc_32.S:	/* r4 = reboot_code_buffer */
arch/powerpc/kernel/traps.c: * spins until a reboot occurs
arch/powerpc/kernel/setup-common.c:#include <linux/reboot.h>
arch/powerpc/kernel/eeh.c:#include <linux/reboot.h>
arch/powerpc/kernel/eeh.c:static int eeh_reboot_notifier(struct notifier_block *nb,
arch/powerpc/kernel/eeh.c:static struct notifier_block eeh_reboot_nb = {
arch/powerpc/kernel/eeh.c:	.notifier_call = eeh_reboot_notifier,
arch/powerpc/kernel/eeh.c:	/* Register reboot notifier */
arch/powerpc/kernel/eeh.c:	ret = register_reboot_notifier(&eeh_reboot_nb);
arch/powerpc/kernel/crash.c:#include <linux/reboot.h>
arch/powerpc/boot/ppcboot.h:	unsigned long	bi_bootflags;	/* boot / reboot flag (for LynxOS) */
arch/powerpc/boot/ppcboot-hotfoot.h:	unsigned long	bi_bootflags;	/* boot / reboot flag (for LynxOS) */
arch/powerpc/boot/ps3.c:	lv1_panic(0); /* zero = do not reboot */
arch/powerpc/Kconfig:	  current kernel, and to start another kernel.  It is like a reboot
arch/powerpc/Kconfig:	  but it is independent of the system firmware.   And like a reboot
arch/powerpc/xmon/xmon.c:#include <linux/reboot.h>
arch/powerpc/xmon/xmon.c:"  zr	reboot\n\
arch/sh/boards/mach-sdk7786/setup.c:#include <asm/reboot.h>
arch/sh/include/uapi/asm/unistd_64.h:#define __NR_reboot		 88
arch/sh/include/uapi/asm/unistd_32.h:#define __NR_reboot		 88
arch/sh/kernel/relocate_kernel.S:	/* r5 = reboot_code_buffer */
arch/sh/kernel/reboot.c:#include <linux/reboot.h>
arch/sh/kernel/reboot.c:#include <asm/reboot.h>
arch/sh/kernel/head_32.S: * can persist across reboots. The PMB could have been left in any state
arch/sh/kernel/head_32.S: * when the reboot occurred, so to be safe we clear all entries and start
arch/sh/kernel/machine_kexec.c:#include <linux/reboot.h>
arch/sh/kernel/machine_kexec.c:#include <asm/reboot.h>
arch/sh/kernel/machine_kexec.c:				      unsigned long reboot_code_buffer,
arch/sh/kernel/machine_kexec.c: * reboot code buffer to allow us to avoid allocations
arch/sh/kernel/machine_kexec.c: * We are past the point of no return, committed to rebooting now.
arch/sh/kernel/machine_kexec.c:	unsigned long reboot_code_buffer;
arch/sh/kernel/machine_kexec.c:	/* Interrupts aren't acceptable while we reboot */
arch/sh/kernel/machine_kexec.c:	reboot_code_buffer =
arch/sh/kernel/machine_kexec.c:	memcpy((void *)reboot_code_buffer, relocate_new_kernel,
arch/sh/kernel/machine_kexec.c:	rnk = (relocate_new_kernel_t) reboot_code_buffer;
arch/sh/kernel/machine_kexec.c:	(*rnk)(page_list, reboot_code_buffer,
arch/sh/kernel/syscalls_32.S:	.long sys_reboot
arch/sh/kernel/Makefile:	   reboot.o return_address.o					\
arch/sh/kernel/crash_dump.c: *	crash_dump.c - Memory preserving reboot related code.
arch/sh/kernel/syscalls_64.S:	.long sys_reboot
arch/sh/kernel/process_64.c:#include <linux/reboot.h>
arch/sh/Kconfig:	  current kernel, and to start another kernel.  It is like a reboot
arch/sh/Kconfig:	  but it is independent of the system firmware.  And like a reboot
arch/um/Kconfig.um:	  will be able to flush the buffer cache to disk, reboot the system
arch/um/drivers/mconsole.h:extern void mconsole_reboot(struct mc_request *req);
arch/um/drivers/mconsole_user.c:	{ "reboot", mconsole_reboot, MCONSOLE_PROC },
arch/um/drivers/harddog_kern.c:#include <linux/reboot.h>
arch/um/drivers/mconsole_kern.c:#include <linux/reboot.h>
arch/um/drivers/mconsole_kern.c:static struct notifier_block reboot_notifier = {
arch/um/drivers/mconsole_kern.c:    reboot - Reboot UML \n\
arch/um/drivers/mconsole_kern.c:void mconsole_reboot(struct mc_request *req)
arch/um/drivers/mconsole_kern.c:	register_reboot_notifier(&reboot_notifier);
arch/um/os-Linux/main.c:	 * This signal stuff used to be in the reboot case.  However,
arch/um/os-Linux/skas/process.c:void reboot_skas(void)
arch/um/include/shared/os.h:extern void reboot_skas(void);
arch/um/kernel/reboot.c:	reboot_skas();
arch/um/kernel/irq.c: * environment in case the system is rebooting.  No locking because
arch/um/kernel/Makefile:	physmem.o process.o ptrace.o reboot.o sigio.o \
arch/unicore32/mm/mmu.c:void setup_mm_for_reboot(void)
arch/unicore32/kernel/process.c:#include <linux/reboot.h>
arch/unicore32/kernel/process.c:	 * Tell the mm system that we are going to reboot -
arch/unicore32/kernel/process.c:	setup_mm_for_reboot();
arch/unicore32/kernel/process.c:	 * Now handle reboot code.
arch/unicore32/kernel/process.c:	if (reboot_mode == REBOOT_SOFT) {
arch/unicore32/kernel/process.c:	 * Whoops - the architecture was unable to reboot.
arch/unicore32/kernel/setup.h:extern void setup_mm_for_reboot(void);
arch/unicore32/kernel/puv3-nb0916.c:#include <linux/reboot.h>
arch/arm/mach-u300/core.c:static void u300_restart(enum reboot_mode mode, const char *cmd)
arch/arm/mach-dove/common.c:void dove_restart(enum reboot_mode mode, const char *cmd)
arch/arm/mach-dove/common.h:#include <linux/reboot.h>
arch/arm/mach-dove/common.h:void dove_restart(enum reboot_mode, const char *);
arch/arm/mach-ixp4xx/common.c:void ixp4xx_restart(enum reboot_mode mode, const char *cmd)
arch/arm/mach-ixp4xx/fsg-setup.c:#include <linux/reboot.h>
arch/arm/mach-ixp4xx/fsg-setup.c:	/* This is the paper-clip reset which does an emergency reboot. */
arch/arm/mach-ixp4xx/nas100d-setup.c:#include <linux/reboot.h>
arch/arm/mach-ixp4xx/include/mach/platform.h:#include <linux/reboot.h>
arch/arm/mach-ixp4xx/include/mach/platform.h:extern void ixp4xx_restart(enum reboot_mode, const char *);
arch/arm/mach-ixp4xx/dsmg600-setup.c:#include <linux/reboot.h>
arch/arm/mach-ixp4xx/nslu2-setup.c:#include <linux/reboot.h>
arch/arm/mach-ux500/cpu.c:void ux500_restart(enum reboot_mode mode, const char *cmd)
arch/arm/mach-ux500/setup.h:void ux500_restart(enum reboot_mode mode, const char *cmd);
arch/arm/mach-ux500/pm.c:	 * On watchdog reboot the GIC is in some cases decoupled.
arch/arm/mach-mxs/mach-mxs.c:#include <linux/reboot.h>
arch/arm/mach-mxs/mach-mxs.c:static void mxs_restart(enum reboot_mode mode, const char *cmd)
arch/arm/mach-orion5x/lsmini-setup.c: * Linkstation Mini specific power off method: reboot
arch/arm/mach-orion5x/lsmini-setup.c: * - The board reboots
arch/arm/mach-orion5x/common.c:void orion5x_restart(enum reboot_mode mode, const char *cmd)
arch/arm/mach-orion5x/ls-chl-setup.c: * LS-CHL specific power off method: reboot
arch/arm/mach-orion5x/ls-chl-setup.c: * - The board reboots
arch/arm/mach-orion5x/common.h:#include <linux/reboot.h>
arch/arm/mach-orion5x/common.h:void orion5x_restart(enum reboot_mode, const char *);
arch/arm/mach-orion5x/board-mss2.c: * - The board reboots
arch/arm/mach-orion5x/ls_hgl-setup.c: * Linkstation LS-HGL specific power off method: reboot
arch/arm/mach-orion5x/ls_hgl-setup.c: * - The board reboots
arch/arm/mach-exynos/pmu.c:#include <linux/reboot.h>
arch/arm/mach-picoxcell/common.c:#include <linux/reboot.h>
arch/arm/mach-picoxcell/common.c:static void picoxcell_wdt_restart(enum reboot_mode mode, const char *cmd)
arch/arm/mach-omap2/wd_timer.c: * during init. Otherwise the system would reboot as per the default
arch/arm/mach-omap2/clock2xxx.h:void omap2xxx_clk_prepare_for_reboot(void);
arch/arm/mach-omap2/am33xx-restart.c:#include <linux/reboot.h>
arch/arm/mach-omap2/am33xx-restart.c: * @mode: the "reboot mode", see arch/arm/kernel/{setup,process}.c
arch/arm/mach-omap2/am33xx-restart.c: * @cmd: passed from the userspace program rebooting the system (if provided)
arch/arm/mach-omap2/am33xx-restart.c: * Resets the SoC.  For @cmd, see the 'reboot' syscall in
arch/arm/mach-omap2/am33xx-restart.c:void am33xx_restart(enum reboot_mode mode, const char *cmd)
arch/arm/mach-omap2/prm33xx.c: * am33xx_prm_global_warm_sw_reset - reboot the device via warm reset
arch/arm/mach-omap2/prm33xx.c: * Immediately reboots the device through warm reset.
arch/arm/mach-omap2/prm2xxx.c: * omap2xxx_prm_dpll_reset - use DPLL reset to reboot the OMAP SoC
arch/arm/mach-omap2/prm2xxx.c: * Set the DPLL reset bit, which should reboot the SoC.  This is the
arch/arm/mach-omap2/omap4-common.c:#include <linux/reboot.h>
arch/arm/mach-omap2/ti81xx-restart.c:#include <linux/reboot.h>
arch/arm/mach-omap2/ti81xx-restart.c: * @mode: the "reboot mode", see arch/arm/kernel/{setup,process}.c
arch/arm/mach-omap2/ti81xx-restart.c: * @cmd: passed from the userspace program rebooting the system (if provided)
arch/arm/mach-omap2/ti81xx-restart.c: * Resets the SoC.  For @cmd, see the 'reboot' syscall in
arch/arm/mach-omap2/ti81xx-restart.c:void ti81xx_restart(enum reboot_mode mode, const char *cmd)
arch/arm/mach-omap2/omap-smp.c:		omap_modify_auxcoreboot0(0x200, 0xfffffdff);
arch/arm/mach-omap2/omap-smp.c:		omap_auxcoreboot_addr(virt_to_phys(startup_addr));
arch/arm/mach-omap2/common.h:#include <linux/reboot.h>
arch/arm/mach-omap2/common.h:void omap2xxx_restart(enum reboot_mode mode, const char *cmd);
arch/arm/mach-omap2/common.h:static inline void omap2xxx_restart(enum reboot_mode mode, const char *cmd)
arch/arm/mach-omap2/common.h:void am33xx_restart(enum reboot_mode mode, const char *cmd);
arch/arm/mach-omap2/common.h:static inline void am33xx_restart(enum reboot_mode mode, const char *cmd)
arch/arm/mach-omap2/common.h:void omap3xxx_restart(enum reboot_mode mode, const char *cmd);
arch/arm/mach-omap2/common.h:static inline void omap3xxx_restart(enum reboot_mode mode, const char *cmd)
arch/arm/mach-omap2/common.h:void ti81xx_restart(enum reboot_mode mode, const char *cmd);
arch/arm/mach-omap2/common.h:static inline void ti81xx_restart(enum reboot_mode mode, const char *cmd)
arch/arm/mach-omap2/common.h:void omap44xx_restart(enum reboot_mode mode, const char *cmd);
arch/arm/mach-omap2/common.h:static inline void omap44xx_restart(enum reboot_mode mode, const char *cmd)
arch/arm/mach-omap2/common.h:extern u32 omap_modify_auxcoreboot0(u32 set_mask, u32 clear_mask);
arch/arm/mach-omap2/common.h:extern void omap_auxcoreboot_addr(u32 cpu_addr);
arch/arm/mach-omap2/common.h:extern u32 omap_read_auxcoreboot0(void);
arch/arm/mach-omap2/omap2-restart.c: * omap2xxx_restart - Set DPLL to bypass mode for reboot to work
arch/arm/mach-omap2/omap2-restart.c: * Set the DPLL to bypass so that reboot completes successfully.  No
arch/arm/mach-omap2/omap2-restart.c:void omap2xxx_restart(enum reboot_mode mode, const char *cmd)
arch/arm/mach-omap2/omap2-restart.c:	/* XXX Should save the cmd argument for use after the reboot */
arch/arm/mach-omap2/prm_common.c: * Triggers SoC specific global warm reset to reboot the device.
arch/arm/mach-omap2/omap-hotplug.c:		if (omap_modify_auxcoreboot0(0x0, 0x200) != 0x0)
arch/arm/mach-omap2/omap-hotplug.c:			boot_cpu = omap_read_auxcoreboot0();
arch/arm/mach-omap2/omap4-restart.c:#include <linux/reboot.h>
arch/arm/mach-omap2/omap4-restart.c: * @mode: the "reboot mode", see arch/arm/kernel/{setup,process}.c
arch/arm/mach-omap2/omap4-restart.c: * @cmd: passed from the userspace program rebooting the system (if provided)
arch/arm/mach-omap2/omap4-restart.c: * Resets the SoC.  For @cmd, see the 'reboot' syscall in
arch/arm/mach-omap2/omap4-restart.c:void omap44xx_restart(enum reboot_mode mode, const char *cmd)
arch/arm/mach-omap2/omap4-restart.c:	/* XXX Should save 'cmd' into scratchpad for use after reboot */
arch/arm/mach-omap2/omap3-restart.c:#include <linux/reboot.h>
arch/arm/mach-omap2/omap3-restart.c: * @mode: the "reboot mode", see arch/arm/kernel/{setup,process}.c
arch/arm/mach-omap2/omap3-restart.c: * @cmd: passed from the userspace program rebooting the system (if provided)
arch/arm/mach-omap2/omap3-restart.c: * Resets the SoC.  For @cmd, see the 'reboot' syscall in
arch/arm/mach-omap2/omap3-restart.c:void omap3xxx_restart(enum reboot_mode mode, const char *cmd)
arch/arm/mach-omap2/omap-smc.S:ENTRY(omap_modify_auxcoreboot0)
arch/arm/mach-omap2/omap-smc.S:ENDPROC(omap_modify_auxcoreboot0)
arch/arm/mach-omap2/omap-smc.S:ENTRY(omap_auxcoreboot_addr)
arch/arm/mach-omap2/omap-smc.S:ENDPROC(omap_auxcoreboot_addr)
arch/arm/mach-omap2/omap-smc.S:ENTRY(omap_read_auxcoreboot0)
arch/arm/mach-omap2/omap-smc.S:ENDPROC(omap_read_auxcoreboot0)
arch/arm/mach-omap2/prm3xxx.c: * omap3xxx_prm_dpll3_reset - use DPLL3 reset to reboot the OMAP SoC
arch/arm/mach-omap2/prm3xxx.c: * Set the DPLL3 reset bit, which should reboot the SoC.  This is the
arch/arm/common/mcpm_entry.c:	setup_mm_for_reboot();
arch/arm/common/mcpm_entry.c:	setup_mm_for_reboot();
arch/arm/common/mcpm_entry.c:	setup_mm_for_reboot();
arch/arm/mach-ebsa110/core.c:static void ebsa110_restart(enum reboot_mode mode, const char *cmd)
arch/arm/mach-iop13xx/setup.c:#include <linux/reboot.h>
arch/arm/mach-iop13xx/setup.c:void iop13xx_restart(enum reboot_mode mode, const char *cmd)
arch/arm/mach-iop13xx/include/mach/iop13xx.h:enum reboot_mode;
arch/arm/mach-iop13xx/include/mach/iop13xx.h:void iop13xx_restart(enum reboot_mode, const char *);
arch/arm/plat-iop/restart.c:void iop3xx_restart(enum reboot_mode mode, const char *cmd)
arch/arm/mach-nomadik/cpu-8815.c:static void cpu8815_restart(enum reboot_mode mode, const char *cmd)
arch/arm/mach-nspire/nspire.c:static void nspire_restart(enum reboot_mode mode, const char *cmd)
arch/arm/mach-netx/generic.h:#include <linux/reboot.h>
arch/arm/mach-netx/generic.h:extern void netx_restart(enum reboot_mode, const char *);
arch/arm/mach-netx/generic.c:#include <linux/reboot.h>
arch/arm/mach-netx/generic.c:void netx_restart(enum reboot_mode mode, const char *cmd)
arch/arm/mach-realview/realview_eb.c:#include <linux/reboot.h>
arch/arm/mach-realview/realview_eb.c:static void realview_eb_restart(enum reboot_mode mode, const char *cmd)
arch/arm/mach-realview/realview_pba8.c:#include <linux/reboot.h>
arch/arm/mach-realview/realview_pba8.c:static void realview_pba8_restart(enum reboot_mode mode, const char *cmd)
arch/arm/mach-realview/realview_pbx.c:#include <linux/reboot.h>
arch/arm/mach-realview/realview_pbx.c:static void realview_pbx_restart(enum reboot_mode mode, const char *cmd)
arch/arm/mach-realview/realview_pb1176.c:#include <linux/reboot.h>
arch/arm/mach-realview/realview_pb1176.c:static void realview_pb1176_restart(enum reboot_mode mode, const char *cmd)
arch/arm/mach-realview/realview_pb11mp.c:#include <linux/reboot.h>
arch/arm/mach-realview/realview_pb11mp.c:static void realview_pb11mp_restart(enum reboot_mode mode, const char *cmd)
arch/arm/xen/enlighten.c:static void xen_restart(enum reboot_mode reboot_mode, const char *cmd)
arch/arm/xen/enlighten.c:	struct sched_shutdown r = { .reason = SHUTDOWN_reboot };
arch/arm/mm/idmap.c:void setup_mm_for_reboot(void)
arch/arm/mm/nommu.c:void setup_mm_for_reboot(void)
arch/arm/mach-cns3xxx/core.h:#include <linux/reboot.h>
arch/arm/mach-cns3xxx/core.h:void cns3xxx_restart(enum reboot_mode, const char *);
arch/arm/mach-cns3xxx/pm.c:void cns3xxx_restart(enum reboot_mode mode, const char *cmd)
arch/arm/mach-at91/generic.h:#include <linux/reboot.h>
arch/arm/mach-at91/at91rm9200.c:static void at91rm9200_restart(enum reboot_mode reboot_mode, const char *cmd)
arch/arm/mach-imx/common.h:#include <linux/reboot.h>
arch/arm/mach-imx/common.h:void mxc_restart(enum reboot_mode, const char *);
arch/arm/mach-imx/mach-imx6q.c:#include <linux/reboot.h>
arch/arm/mach-imx/system.c:void mxc_restart(enum reboot_mode mode, const char *cmd)
arch/arm/mach-hisi/core.h:#include <linux/reboot.h>
arch/arm/mach-lpc32xx/common.c:void lpc23xx_restart(enum reboot_mode mode, const char *cmd)
arch/arm/mach-lpc32xx/common.h:#include <linux/reboot.h>
arch/arm/mach-lpc32xx/common.h:extern void lpc23xx_restart(enum reboot_mode, const char *);
arch/arm/mach-ep93xx/core.c:#include <linux/reboot.h>
arch/arm/mach-ep93xx/core.c:void ep93xx_restart(enum reboot_mode mode, const char *cmd)
arch/arm/mach-ep93xx/include/mach/platform.h:#include <linux/reboot.h>
arch/arm/mach-ep93xx/include/mach/platform.h:void ep93xx_restart(enum reboot_mode, const char *);
arch/arm/mach-clps711x/common.c:void clps711x_restart(enum reboot_mode mode, const char *cmd)
arch/arm/mach-clps711x/common.h:#include <linux/reboot.h>
arch/arm/mach-clps711x/common.h:extern void clps711x_restart(enum reboot_mode mode, const char *cmd);
arch/arm/mach-footbridge/common.c:void footbridge_restart(enum reboot_mode mode, const char *cmd)
arch/arm/mach-footbridge/cats-hw.c: * CATS uses soft-reboot by default, since
arch/arm/mach-footbridge/cats-hw.c: * hard reboots fail on early boards.
arch/arm/mach-footbridge/cats-hw.c:	.reboot_mode	= REBOOT_SOFT,
arch/arm/mach-footbridge/common.h:#include <linux/reboot.h>
arch/arm/mach-footbridge/common.h:extern void footbridge_restart(enum reboot_mode, const char *);
arch/arm/mach-footbridge/netwinder-hw.c:static void netwinder_restart(enum reboot_mode mode, const char *cmd)
arch/arm/mach-footbridge/netwinder-hw.c:		/* set a RED LED and toggle WD_TIMER for rebooting */
arch/arm/mach-omap1/board-voiceblue.c:#include <linux/reboot.h>
arch/arm/mach-omap1/board-voiceblue.c:#include <linux/reboot.h>
arch/arm/mach-omap1/board-voiceblue.c:static void voiceblue_restart(enum reboot_mode mode, const char *cmd)
arch/arm/mach-omap1/reset.c:#include <linux/reboot.h>
arch/arm/mach-omap1/reset.c:void omap1_restart(enum reboot_mode mode, const char *cmd)
arch/arm/mach-omap1/common.h:#include <linux/reboot.h>
arch/arm/mach-omap1/common.h:void omap1_restart(enum reboot_mode, const char *);
arch/arm/mach-integrator/common.h:#include <linux/reboot.h>
arch/arm/mach-s3c64xx/common.c:#include <linux/reboot.h>
arch/arm/mach-s3c64xx/common.c:void s3c64xx_restart(enum reboot_mode mode, const char *cmd)
arch/arm/mach-s3c64xx/mach-s3c64xx-dt.c:static void s3c64xx_dt_restart(enum reboot_mode mode, const char *cmd)
arch/arm/mach-s3c64xx/common.h:#include <linux/reboot.h>
arch/arm/mach-s3c64xx/common.h:void s3c64xx_restart(enum reboot_mode mode, const char *cmd);
arch/arm/mach-prima2/rstc.c:#include <linux/reboot.h>
arch/arm/mach-prima2/rstc.c:static void sirfsoc_restart(enum reboot_mode mode, const char *cmd)
arch/arm/mach-prima2/common.h:#include <linux/reboot.h>
arch/arm/mach-pxa/reset.c:void pxa_restart(enum reboot_mode mode, const char *cmd)
arch/arm/mach-pxa/corgi.c:static void corgi_restart(enum reboot_mode mode, const char *cmd)
arch/arm/mach-pxa/corgi.c:		/* Green LED on tells the bootloader to reboot */
arch/arm/mach-pxa/spitz.c:#include <linux/reboot.h>
arch/arm/mach-pxa/spitz.c:static void spitz_restart(enum reboot_mode mode, const char *cmd)
arch/arm/mach-pxa/spitz.c:	/* Bootloader magic for a reboot */
arch/arm/mach-pxa/mioa701.c:#include <linux/reboot.h>
arch/arm/mach-pxa/mioa701.c: * MIO A701 reboot sequence is highly ROM dependent. From the one dissassembled,
arch/arm/mach-pxa/mioa701.c:static void mioa701_restart(enum reboot_mode c, const char *cmd)
arch/arm/mach-pxa/tosa.c:#include <linux/reboot.h>
arch/arm/mach-pxa/tosa.c:static void tosa_restart(enum reboot_mode mode, const char *cmd)
arch/arm/mach-pxa/tosa.c:	/* Bootloader magic for a reboot */
arch/arm/mach-pxa/generic.h:#include <linux/reboot.h>
arch/arm/mach-pxa/generic.h:void pxa_restart(enum reboot_mode, const char *);
arch/arm/mach-pxa/sharpsl_pm.c:	/* Clear the reset source indicators as they break the bootloader upon reboot */
arch/arm/mach-rpc/ecard.c:#include <linux/reboot.h>
arch/arm/mach-rpc/ecard.c: * Before rebooting, we must make sure that the expansion card is in a
arch/arm/mach-rpc/riscpc.c:#include <linux/reboot.h>
arch/arm/mach-rpc/riscpc.c:static void rpc_restart(enum reboot_mode mode, const char *cmd)
arch/arm/kvm/arm.c:	 * Ensure a rebooted VM will fault in RAM pages and detect if the
arch/arm/kvm/psci.c:	 * again and may perform shutdown/reboot at a later time that when the
arch/arm/kvm/psci.c:	 * caller of PSCI reboot and shutdown expects that the system shuts
arch/arm/kvm/psci.c:	 * down or reboots immediately, let's make sure that VCPUs are not run
arch/arm/mach-w90x900/cpu.c:void nuc9xx_restart(enum reboot_mode mode, const char *cmd)
arch/arm/mach-w90x900/nuc9xx.h:#include <linux/reboot.h>
arch/arm/mach-w90x900/nuc9xx.h:extern void nuc9xx_restart(enum reboot_mode, const char *);
arch/arm/mach-spear/generic.h:#include <linux/reboot.h>
arch/arm/mach-spear/generic.h:void spear_restart(enum reboot_mode, const char *);
arch/arm/mach-spear/restart.c:#include <linux/reboot.h>
arch/arm/mach-spear/restart.c:void spear_restart(enum reboot_mode mode, const char *cmd)
arch/arm/mach-mv78xx0/common.c:void mv78xx0_restart(enum reboot_mode mode, const char *cmd)
arch/arm/mach-mv78xx0/common.h:#include <linux/reboot.h>
arch/arm/mach-mv78xx0/common.h:void mv78xx0_restart(enum reboot_mode, const char *);
arch/arm/plat-omap/sram.c:	 * beginning of SRAM for jumping to flash for reboot to work...
arch/arm/mach-vt8500/vt8500.c:#include <linux/reboot.h>
arch/arm/mach-vt8500/vt8500.c:static void vt8500_restart(enum reboot_mode mode, const char *cmd)
arch/arm/mach-bcm/board_bcm2835.c:static void bcm2835_restart(enum reboot_mode mode, const char *cmd)
arch/arm/mach-bcm/board_bcm2835.c: * indicate to bootcode.bin not to reboot, then most of the chip will be
arch/arm/mach-bcm/board_bcm2835.c:	 * from the normal (full) reset. bootcode.bin will not reboot after a
arch/arm/mach-bcm/board_bcm281xx.c:static void bcm281xx_restart(enum reboot_mode mode, const char *cmd)
arch/arm/mach-bcm/board_bcm21664.c:static void bcm21664_restart(enum reboot_mode mode, const char *cmd)
arch/arm/mach-ks8695/time.c:void ks8695_restart(enum reboot_mode reboot_mode, const char *cmd)
arch/arm/mach-ks8695/time.c:	if (reboot_mode == REBOOT_SOFT)
arch/arm/mach-ks8695/generic.h:extern void ks8695_restart(enum reboot_mode, const char *);
arch/arm/mach-s5pv210/s5pv210.c:static void s5pv210_dt_restart(enum reboot_mode mode, const char *cmd)
arch/arm/mach-davinci/devices.c:#include <linux/reboot.h>
arch/arm/mach-davinci/devices.c:void davinci_restart(enum reboot_mode mode, const char *cmd)
arch/arm/mach-davinci/devices-da8xx.c:#include <linux/reboot.h>
arch/arm/mach-davinci/devices-da8xx.c:void da8xx_restart(enum reboot_mode mode, const char *cmd)
arch/arm/mach-davinci/include/mach/da8xx.h:#include <linux/reboot.h>
arch/arm/mach-davinci/include/mach/da8xx.h:void da8xx_restart(enum reboot_mode mode, const char *cmd);
arch/arm/mach-davinci/include/mach/common.h:#include <linux/reboot.h>
arch/arm/mach-davinci/include/mach/common.h:void davinci_restart(enum reboot_mode mode, const char *cmd);
arch/arm/include/uapi/asm/unistd.h:#define __NR_reboot			(__NR_SYSCALL_BASE+ 88)
arch/arm/include/asm/v7m.h:enum reboot_mode;
arch/arm/include/asm/v7m.h:void armv7m_restart(enum reboot_mode mode, const char *cmd);
arch/arm/include/asm/mach/arch.h:#include <linux/reboot.h>
arch/arm/include/asm/mach/arch.h:	enum reboot_mode	reboot_mode;	/* default restart mode	*/
arch/arm/include/asm/mach/arch.h:	void			(*restart)(enum reboot_mode, const char *);
arch/arm/include/asm/system_misc.h:#include <linux/reboot.h>
arch/arm/include/asm/system_misc.h:extern void (*arm_pm_restart)(enum reboot_mode reboot_mode, const char *cmd);
arch/arm/include/asm/hardware/iop3xx.h:#include <linux/reboot.h>
arch/arm/include/asm/hardware/iop3xx.h:void iop3xx_restart(enum reboot_mode, const char *);
arch/arm/include/asm/idmap.h:void setup_mm_for_reboot(void);
arch/arm/mach-mmp/common.c:void mmp_restart(enum reboot_mode mode, const char *cmd)
arch/arm/mach-mmp/pxa168.c:void pxa168_restart(enum reboot_mode mode, const char *cmd)
arch/arm/mach-mmp/common.h:#include <linux/reboot.h>
arch/arm/mach-mmp/common.h:extern void mmp_restart(enum reboot_mode, const char *);
arch/arm/mach-mmp/include/mach/pxa168.h:#include <linux/reboot.h>
arch/arm/mach-mmp/include/mach/pxa168.h:extern void pxa168_restart(enum reboot_mode, const char *);
arch/arm/kernel/process.c:#include <linux/reboot.h>
arch/arm/kernel/process.c:#include <linux/reboot.h>
arch/arm/kernel/process.c:	setup_mm_for_reboot();
arch/arm/kernel/process.c:void (*arm_pm_restart)(enum reboot_mode reboot_mode, const char *cmd);
arch/arm/kernel/process.c:		arm_pm_restart(reboot_mode, cmd);
arch/arm/kernel/process.c:	/* Whoops - the platform was unable to reboot. Tell the user! */
arch/arm/kernel/calls.S:		CALL(sys_reboot)
arch/arm/kernel/machine_kexec.c:#include <linux/reboot.h>
arch/arm/kernel/machine_kexec.c:	unsigned long reboot_code_buffer_phys;
arch/arm/kernel/machine_kexec.c:	unsigned long reboot_entry = (unsigned long)relocate_new_kernel;
arch/arm/kernel/machine_kexec.c:	unsigned long reboot_entry_phys;
arch/arm/kernel/machine_kexec.c:	void *reboot_code_buffer;
arch/arm/kernel/machine_kexec.c:	reboot_code_buffer_phys =
arch/arm/kernel/machine_kexec.c:	reboot_code_buffer = page_address(image->control_code_page);
arch/arm/kernel/machine_kexec.c:	/* Prepare parameters for reboot_code_buffer*/
arch/arm/kernel/machine_kexec.c:	reboot_entry = fncpy(reboot_code_buffer,
arch/arm/kernel/machine_kexec.c:			     reboot_entry,
arch/arm/kernel/machine_kexec.c:	reboot_entry_phys = (unsigned long)reboot_entry +
arch/arm/kernel/machine_kexec.c:		(reboot_code_buffer_phys - (unsigned long)reboot_code_buffer);
arch/arm/kernel/machine_kexec.c:	soft_restart(reboot_entry_phys);
arch/arm/kernel/setup.c:extern enum reboot_mode reboot_mode;
arch/arm/kernel/setup.c:	// reboot   ?
arch/arm/kernel/setup.c:	if (mdesc->reboot_mode != REBOOT_HARD)
arch/arm/kernel/setup.c:		reboot_mode = mdesc->reboot_mode;
arch/arm/kernel/hibernate.c: * When soft reboot completes, the hibernation snapshot is written out.
arch/arm/kernel/psci.c:#include <linux/reboot.h>
arch/arm/kernel/psci.c:static void psci_sys_reset(enum reboot_mode reboot_mode, const char *cmd)
arch/arm/kernel/v7m.c:#include <linux/reboot.h>
arch/arm/kernel/v7m.c:void armv7m_restart(enum reboot_mode mode, const char *cmd)
arch/arm/mach-shmobile/setup-r8a7740.c:static void r8a7740_restart(enum reboot_mode mode, const char *cmd)
arch/arm/mach-shmobile/board-kzm9g-reference.c:static void kzm9g_restart(enum reboot_mode mode, const char *cmd)
arch/arm/mach-shmobile/setup-sh73a0.c:static void sh73a0_restart(enum reboot_mode mode, const char *cmd)
arch/arm/mach-shmobile/board-kzm9g.c:#include <linux/reboot.h>
arch/arm/mach-shmobile/board-kzm9g.c:static void kzm9g_restart(enum reboot_mode mode, const char *cmd)
arch/arm/mach-shmobile/board-armadillo800eva.c:#include <linux/reboot.h>
arch/arm/mach-shmobile/board-armadillo800eva.c:static void eva_restart(enum reboot_mode mode, const char *cmd)
arch/arm/mach-msm/smd.c:	/* in this case the modem or watchdog should reboot us */
arch/arm/mach-tegra/pm.c:	setup_mm_for_reboot();
arch/arm/mach-tegra/pm.c:	setup_mm_for_reboot();
arch/arm/mach-tegra/board.h:#include <linux/reboot.h>
arch/arm/boot/dts/armada-xp-lenovo-ix4-300d.dts:	 * reboots
arch/arm/boot/dts/hip01.dtsi:			reboot-offset = <0x4>;
arch/arm/boot/dts/bcm7445.dtsi:	reboot {
arch/arm/boot/dts/bcm7445.dtsi:		compatible = "brcm,brcmstb-reboot";
arch/arm/boot/dts/hisi-x5hd2.dtsi:		reboot {
arch/arm/boot/dts/hisi-x5hd2.dtsi:			compatible = "syscon-reboot";
arch/arm/boot/dts/vexpress-v2m.dtsi:			reboot@0 {
arch/arm/boot/dts/vexpress-v2m.dtsi:				compatible = "arm,vexpress-reboot";
arch/arm/boot/dts/vexpress-v2m-rs1.dtsi:			reboot@0 {
arch/arm/boot/dts/vexpress-v2m-rs1.dtsi:				compatible = "arm,vexpress-reboot";
arch/arm/boot/dts/vfxxx.dtsi:	reboot: syscon-reboot {
arch/arm/boot/dts/vfxxx.dtsi:		compatible = "syscon-reboot";
arch/arm/boot/dts/hi3620.dtsi:			reboot-offset = <0x4>;
arch/arm/mach-iop32x/n2100.c:#include <linux/reboot.h>
arch/arm/mach-iop32x/n2100.c:static void n2100_restart(enum reboot_mode mode, const char *cmd)
arch/arm/mach-highbank/core.h:#include <linux/reboot.h>
arch/arm/mach-highbank/core.h:extern void highbank_restart(enum reboot_mode, const char *);
arch/arm/mach-highbank/system.c:#include <linux/reboot.h>
arch/arm/mach-highbank/system.c:void highbank_restart(enum reboot_mode mode, const char *cmd)
arch/arm/mach-highbank/highbank.c:#include <linux/reboot.h>
arch/arm/mach-versatile/core.c:#include <linux/reboot.h>
arch/arm/mach-versatile/core.c:void versatile_restart(enum reboot_mode mode, const char *cmd)
arch/arm/mach-versatile/core.h:#include <linux/reboot.h>
arch/arm/mach-versatile/core.h:extern void versatile_restart(enum reboot_mode, const char *);
arch/arm/mach-socfpga/socfpga.c:#include <linux/reboot.h>
arch/arm/mach-socfpga/socfpga.c:static void socfpga_cyclone5_restart(enum reboot_mode mode, const char *cmd)
arch/arm/Kconfig:	  look like a DTB header after a reboot if no actual DTB is appended
arch/arm/Kconfig:	  current kernel, and to start another kernel.  It is like a reboot
arch/arm/Kconfig:	  but it is independent of the system firmware.   And like a reboot
arch/arm/mach-zynq/common.c:static void zynq_system_reset(enum reboot_mode mode, const char *cmd)
arch/arm/mach-zynq/slcr.c:	u32 reboot;
arch/arm/mach-zynq/slcr.c:	 * Clear 0x0F000000 bits of reboot status register to workaround
arch/arm/mach-zynq/slcr.c:	 * the FSBL not loading the bitstream after soft-reboot
arch/arm/mach-zynq/slcr.c:	zynq_slcr_read(&reboot, SLCR_REBOOT_STATUS_OFFSET);
arch/arm/mach-zynq/slcr.c:	zynq_slcr_write(reboot & 0xF0FFFFFF, SLCR_REBOOT_STATUS_OFFSET);
arch/arm/mach-mvebu/system-controller.c:#include <linux/reboot.h>
arch/arm/mach-mvebu/system-controller.c:void mvebu_restart(enum reboot_mode mode, const char *cmd)
arch/arm/mach-mvebu/common.h:#include <linux/reboot.h>
arch/arm/mach-mvebu/common.h:void mvebu_restart(enum reboot_mode mode, const char *cmd);
arch/arm/mach-sa1100/generic.h:#include <linux/reboot.h>
arch/arm/mach-sa1100/generic.h:extern void sa11x0_restart(enum reboot_mode, const char *);
arch/arm/mach-sa1100/generic.c:#include <linux/reboot.h>
arch/arm/mach-sa1100/generic.c:void sa11x0_restart(enum reboot_mode mode, const char *cmd)
arch/arm/mach-s3c24xx/s3c2412.c:#include <linux/reboot.h>
arch/arm/mach-s3c24xx/s3c2443.c:#include <linux/reboot.h>
arch/arm/mach-s3c24xx/s3c2410.c:#include <linux/reboot.h>
arch/arm/mach-s3c24xx/s3c2416.c:#include <linux/reboot.h>
arch/arm/mach-s3c24xx/common.h:#include <linux/reboot.h>
arch/arm/mach-s3c24xx/s3c244x.c:#include <linux/reboot.h>
arch/blackfin/mach-bf548/include/mach/anomaly.h:/* Preboot Routine Incorrectly Alters Reset Value of USB Register */
arch/blackfin/mach-bf548/include/mach/anomaly.h:/* Programmable Preboot Settings Not Functional */
arch/blackfin/mach-bf527/boards/ezbrd.c:#include <asm/reboot.h>
arch/blackfin/mach-bf527/boards/ezbrd.c:	/* workaround reboot hang when booting from SPI */
arch/blackfin/mach-bf527/boards/cm_bf527.c:#include <asm/reboot.h>
arch/blackfin/mach-bf527/boards/cm_bf527.c:	/* workaround reboot hang when booting from SPI */
arch/blackfin/mach-bf527/boards/tll6527m.c:#include <asm/reboot.h>
arch/blackfin/mach-bf527/boards/tll6527m.c:	/* workaround reboot hang when booting from SPI */
arch/blackfin/mach-bf527/boards/ad7160eval.c:#include <asm/reboot.h>
arch/blackfin/mach-bf527/boards/ad7160eval.c:	/* workaround reboot hang when booting from SPI */
arch/blackfin/mach-bf527/boards/ezkit.c:#include <asm/reboot.h>
arch/blackfin/mach-bf527/boards/ezkit.c:	/* workaround reboot hang when booting from SPI */
arch/blackfin/mach-bf527/include/mach/anomaly.h:/* Preboot Routine Incorrectly Alters Reset Value of USB Register */
arch/blackfin/mach-bf527/include/mach/anomaly.h:/* Programmable Preboot Settings Not Functional */
arch/blackfin/mach-bf527/include/mach/anomaly.h:/* Preboot Cannot be Used to Alter the PLL_DIV Register */
arch/blackfin/mach-bf537/boards/dnp5370.c:#include <asm/reboot.h>
arch/blackfin/mach-bf537/boards/minotaur.c:#include <asm/reboot.h>
arch/blackfin/mach-bf537/boards/minotaur.c:	/* workaround reboot hang when booting from SPI */
arch/blackfin/mach-bf537/boards/stamp.c:#include <asm/reboot.h>
arch/blackfin/mach-bf537/boards/stamp.c:	/* workaround reboot hang when booting from SPI */
arch/blackfin/mach-bf533/boards/H8606.c:#include <asm/reboot.h>
arch/blackfin/mach-bf533/boards/stamp.c:#include <asm/reboot.h>
arch/blackfin/include/uapi/asm/unistd.h:#define __NR_reboot		 88
arch/blackfin/include/asm/reboot.h: * reboot.h - shutdown/reboot header
arch/blackfin/include/asm/reboot.h:/* common reboot workarounds */
arch/blackfin/mach-bf518/boards/ezbrd.c:#include <asm/reboot.h>
arch/blackfin/mach-bf518/boards/ezbrd.c:	/* workaround reboot hang when booting from SPI */
arch/blackfin/mach-bf518/boards/tcm-bf518.c:#include <asm/reboot.h>
arch/blackfin/mach-bf518/boards/tcm-bf518.c:	/* workaround reboot hang when booting from SPI */
arch/blackfin/mach-bf518/include/mach/anomaly.h:/* Preboot Cannot be Used to Alter the PLL_DIV Register */
arch/blackfin/kernel/reboot.c: * arch/blackfin/kernel/reboot.c - handle shutdown/reboot
arch/blackfin/kernel/reboot.c:#include <asm/reboot.h>
arch/blackfin/kernel/fixed_code.S:	 * a dump of the trace buffer so we can tell were we are, and a reboot
arch/blackfin/kernel/early_printk.c:#include <linux/reboot.h>
arch/blackfin/kernel/early_printk.c:		 * we want to reboot, but if the machine type is different,
arch/blackfin/kernel/early_printk.c:		 * can't due to machine specific reboot sequences
arch/blackfin/kernel/traps.c:	 * we will kernel panic, so the system reboots.
arch/blackfin/kernel/Makefile:	fixed_code.o reboot.o bfin_dma.o \
arch/blackfin/mach-common/entry.S:	.long _sys_reboot
arch/parisc/include/uapi/asm/pdc.h:#define PDC_FIRM_TEST_MAGIC	0xab9ec36fUL    /* for this reboot only	*/
arch/parisc/include/uapi/asm/unistd.h:#define __NR_reboot              (__NR_Linux + 88)
arch/parisc/include/asm/pdc_chassis.h:/* System crashed and rebooted itself successfully */
arch/parisc/include/asm/pdc_chassis.h:/* System running and unexpected reboot or non-critical error detected */
arch/parisc/include/asm/pdc_chassis.h:/* Unexpected reboot occurred - Executing non-OS code */
arch/parisc/include/asm/pdc_chassis.h:/* Unexpected reboot/recovering - Executing non-OS code - Non-critical error detected */
arch/parisc/include/asm/pdc.h: * are hversion dependent. Do a "ser pim 0 hpmc" after rebooting, since
arch/parisc/kernel/process.c:	 ** system is rebooted w/PDC_DO_RESET.
arch/parisc/kernel/process.c:	** function, called by the reboot notifier chain.
arch/parisc/kernel/process.c: * This routine is called from sys_reboot to actually turn off the
arch/parisc/kernel/syscall_table.S:	ENTRY_SAME(reboot)
arch/parisc/kernel/traps.c:	/* Call kernel panic() so reboot timeouts work properly 
arch/parisc/kernel/traps.c:	 * and it enables reboot timers!
arch/parisc/kernel/pdc_chassis.c:#include <linux/reboot.h>
arch/parisc/kernel/pdc_chassis.c: * parisc_reboot_event() - Called by the reboot handler.
arch/parisc/kernel/pdc_chassis.c: * As soon as a reboot occurs, we should inform the PDC.
arch/parisc/kernel/pdc_chassis.c:static int pdc_chassis_reboot_event(struct notifier_block *this,
arch/parisc/kernel/pdc_chassis.c:static struct notifier_block pdc_chassis_reboot_block = {
arch/parisc/kernel/pdc_chassis.c:	.notifier_call = pdc_chassis_reboot_event,
arch/parisc/kernel/pdc_chassis.c:		/* initialize reboot notifier chain */
arch/parisc/kernel/pdc_chassis.c:		register_reboot_notifier(&pdc_chassis_reboot_block);
arch/ia64/mm/init.c:#include <linux/reboot.h>
arch/ia64/hp/sim/boot/bootloader.c:		cons_write(": file not found, reboot now\n");
arch/ia64/include/uapi/asm/unistd.h:#define __NR_reboot			1096
arch/ia64/include/asm/pal.h:	 * informational value should be printed (e.g., "reboot for
arch/ia64/include/asm/sal.h:	 * informational value should be printed (e.g., "reboot for
arch/ia64/kernel/entry.S:	data8 sys_reboot
arch/ia64/kernel/process.c:	efi_reboot(REBOOT_WARM, NULL);
arch/ia64/kernel/fsys.S:	data8 0				// reboot
arch/ia64/kernel/machine_kexec.c: * reboot code buffer to allow us to avoid allocations
arch/ia64/kernel/machine_kexec.c: * We are past the point of no return, committed to rebooting now.
arch/ia64/kernel/machine_kexec.c:	/* Interrupts aren't acceptable while we reboot */
arch/ia64/kernel/setup.c:#include <linux/reboot.h>
arch/ia64/kernel/crash_dump.c: *	kernel/crash_dump.c - Memory preserving reboot related code.
arch/ia64/Kconfig:	  current kernel, and to start another kernel.  It is like a reboot
arch/ia64/Kconfig:	  but it is independent of the system firmware.   And like a reboot
arch/x86/lguest/boot.c:#include <asm/reboot.h>		/* for struct machine_ops */
arch/x86/lguest/boot.c: * an argument which says whether this to restart (reboot) the Guest or not.
arch/x86/lguest/boot.c: * Launcher to reboot us.
arch/x86/lguest/boot.c:	 * the Guest routine to power off, and the reboot hook to our restart
arch/x86/xen/enlighten.c:#include <asm/reboot.h>
arch/x86/xen/enlighten.c:static void xen_reboot(int reason)
arch/x86/xen/enlighten.c:	xen_reboot(SHUTDOWN_reboot);
arch/x86/xen/enlighten.c:	xen_reboot(SHUTDOWN_reboot);
arch/x86/xen/enlighten.c:	xen_reboot(SHUTDOWN_poweroff);
arch/x86/xen/enlighten.c:	xen_reboot(SHUTDOWN_poweroff);
arch/x86/xen/enlighten.c:	xen_reboot(SHUTDOWN_crash);
arch/x86/xen/enlighten.c:	xen_reboot(SHUTDOWN_crash);
arch/x86/syscalls/syscall_32.tbl:88	i386	reboot			sys_reboot
arch/x86/syscalls/syscall_64.tbl:169	common	reboot			sys_reboot
arch/x86/Kconfig.debug:	  would otherwise cause a system to silently reboot. Disabling this
arch/x86/realmode/rm/reboot.S: * The following code and data reboots the machine by switching to real
arch/x86/realmode/rm/header.S:	/* APM/BIOS reboot */
arch/x86/realmode/rm/Makefile:realmode-y			+= reboot.o
arch/x86/kvm/vmx.c:#define __ex(x) __kvm_handle_fault_on_reboot(x)
arch/x86/kvm/vmx.c:	____kvm_handle_fault_on_reboot(x, "xor " reg " , " reg)
arch/x86/kvm/vmx.c:/* Just like cpu_vmxoff(), but with the __kvm_handle_fault_on_reboot()
arch/x86/kvm/x86.c:	/* Fault while not rebooting.  We want the trace. */
arch/x86/kvm/svm.c:#define __ex(x) __kvm_handle_fault_on_reboot(x)
arch/x86/kvm/svm.c:	 * reboot
arch/x86/platform/intel-mid/intel-mid.c:#include <asm/reboot.h>
arch/x86/platform/intel-mid/intel-mid.c:static void intel_mid_reboot(void)
arch/x86/platform/intel-mid/intel-mid.c:	machine_ops.emergency_restart  = intel_mid_reboot;
arch/x86/platform/intel-mid/sfi.c:#include <asm/reboot.h>
arch/x86/platform/ce4100/ce4100.c:#include <linux/reboot.h>
arch/x86/platform/ce4100/ce4100.c:#include <linux/reboot.h>
arch/x86/platform/ce4100/ce4100.c: * intention to reset, reboot or power off the system. This 8051 device has
arch/x86/platform/ce4100/ce4100.c:	 * By default, the reboot method is ACPI which is supported by the
arch/x86/platform/ce4100/ce4100.c:	 * reboot. By using BOOT_KBD we ensure proper system reboot as
arch/x86/platform/ce4100/ce4100.c:	reboot_type = BOOT_KBD;
arch/x86/platform/efi/quirks.c:bool efi_reboot_required(void)
arch/x86/platform/efi/quirks.c:	efi_reboot_quirk_mode = EFI_RESET_WARM;
arch/x86/platform/efi/efi.c:#include <linux/reboot.h>
arch/x86/platform/efi/efi_64.c:#include <linux/reboot.h>
arch/x86/platform/geode/alix.c:	const char coreboot_sig[] = "PC Engines\0ALIX.";
arch/x86/platform/geode/alix.c:	    alix_present(BIOS_SIGNATURE_COREBOOT, coreboot_sig, sizeof(coreboot_sig) - 1) ||
arch/x86/include/asm/reboot.h:/* These must match dispatch in arch/x86/realmore/rm/reboot.S */
arch/x86/include/asm/kvm_host.h: * reboot turns off virtualization while processes are running.
arch/x86/include/asm/kvm_host.h:#define ____kvm_handle_fault_on_reboot(insn, cleanup_insn)	\
arch/x86/include/asm/kvm_host.h:	"cmpb $0, kvm_rebooting \n\t"	      \
arch/x86/include/asm/kvm_host.h:#define __kvm_handle_fault_on_reboot(insn)		\
arch/x86/include/asm/kvm_host.h:	____kvm_handle_fault_on_reboot(insn, "")
arch/x86/include/asm/efi.h:extern bool efi_reboot_required(void);
arch/x86/include/asm/efi.h:static inline bool efi_reboot_required(void)
arch/x86/include/asm/entry_arch.h:BUILD_INTERRUPT3(reboot_interrupt, REBOOT_VECTOR, smp_reboot_interrupt)
arch/x86/include/asm/proto.h:extern int reboot_force;
arch/x86/include/asm/reboot_fixups.h:extern void mach_reboot_fixups(void);
arch/x86/include/asm/realmode.h:	/* APM/BIOS reboot */
arch/x86/include/asm/hw_irq.h:extern asmlinkage void reboot_interrupt(void);
arch/x86/include/asm/hw_irq.h:#define trace_reboot_interrupt  reboot_interrupt
arch/x86/kernel/smp.c:asmlinkage __visible void smp_reboot_interrupt(void)
arch/x86/kernel/smp.c:	if (reboot_force)
arch/x86/kernel/cpu/mcheck/mce-apei.c: * that the MCE record can be logged after reboot via ERST.
arch/x86/kernel/module.c:		 * reboot.
arch/x86/kernel/reboot.c:#include <linux/reboot.h>
arch/x86/kernel/reboot.c:#include <acpi/reboot.h>
arch/x86/kernel/reboot.c:#include <asm/reboot_fixups.h>
arch/x86/kernel/reboot.c:#include <asm/reboot.h>
arch/x86/kernel/reboot.c:static int reboot_emergency;
arch/x86/kernel/reboot.c: * Some machines require the "reboot=b" or "reboot=k"  commandline options,
arch/x86/kernel/reboot.c:static int __init set_bios_reboot(const struct dmi_system_id *d)
arch/x86/kernel/reboot.c:	if (reboot_type != BOOT_BIOS) {
arch/x86/kernel/reboot.c:		reboot_type = BOOT_BIOS;
arch/x86/kernel/reboot.c:		pr_info("%s series board detected. Selecting %s-method for reboots.\n",
arch/x86/kernel/reboot.c:	 * routine will recognize as telling it to do a proper reboot.  (Well
arch/x86/kernel/reboot.c: * Some Apple MacBook and MacBookPro's needs reboot=p to be able to reboot
arch/x86/kernel/reboot.c:static int __init set_pci_reboot(const struct dmi_system_id *d)
arch/x86/kernel/reboot.c:	if (reboot_type != BOOT_CF9_FORCE) {
arch/x86/kernel/reboot.c:		reboot_type = BOOT_CF9_FORCE;
arch/x86/kernel/reboot.c:		pr_info("%s series board detected. Selecting %s-method for reboots.\n",
arch/x86/kernel/reboot.c:static int __init set_kbd_reboot(const struct dmi_system_id *d)
arch/x86/kernel/reboot.c:	if (reboot_type != BOOT_KBD) {
arch/x86/kernel/reboot.c:		reboot_type = BOOT_KBD;
arch/x86/kernel/reboot.c:		pr_info("%s series board detected. Selecting %s-method for reboot.\n",
arch/x86/kernel/reboot.c: * This is a single dmi_table handling all reboot quirks.
arch/x86/kernel/reboot.c:static struct dmi_system_id __initdata reboot_dmi_table[] = {
arch/x86/kernel/reboot.c:	{	/* Handle reboot issue on Acer Aspire one */
arch/x86/kernel/reboot.c:		.callback = set_kbd_reboot,
arch/x86/kernel/reboot.c:	{	/* Handle problems with rebooting on Apple MacBook5 */
arch/x86/kernel/reboot.c:		.callback = set_pci_reboot,
arch/x86/kernel/reboot.c:	{	/* Handle problems with rebooting on Apple MacBookPro5 */
arch/x86/kernel/reboot.c:		.callback = set_pci_reboot,
arch/x86/kernel/reboot.c:	{	/* Handle problems with rebooting on Apple Macmini3,1 */
arch/x86/kernel/reboot.c:		.callback = set_pci_reboot,
arch/x86/kernel/reboot.c:	{	/* Handle problems with rebooting on the iMac9,1. */
arch/x86/kernel/reboot.c:		.callback = set_pci_reboot,
arch/x86/kernel/reboot.c:	{	/* Handle problems with rebooting on ASRock Q1900DC-ITX */
arch/x86/kernel/reboot.c:		.callback = set_pci_reboot,
arch/x86/kernel/reboot.c:	{	/* Handle problems with rebooting on ASUS P4S800 */
arch/x86/kernel/reboot.c:		.callback = set_bios_reboot,
arch/x86/kernel/reboot.c:	{       /* Handle problems with rebooting on Certec BPC600 */
arch/x86/kernel/reboot.c:		.callback = set_pci_reboot,
arch/x86/kernel/reboot.c:	{	/* Handle problems with rebooting on Dell DXP061 */
arch/x86/kernel/reboot.c:		.callback = set_bios_reboot,
arch/x86/kernel/reboot.c:	{	/* Handle problems with rebooting on Dell E520's */
arch/x86/kernel/reboot.c:		.callback = set_bios_reboot,
arch/x86/kernel/reboot.c:	{	/* Handle problems with rebooting on the Latitude E5410. */
arch/x86/kernel/reboot.c:		.callback = set_pci_reboot,
arch/x86/kernel/reboot.c:	{	/* Handle problems with rebooting on the Latitude E5420. */
arch/x86/kernel/reboot.c:		.callback = set_pci_reboot,
arch/x86/kernel/reboot.c:	{	/* Handle problems with rebooting on the Latitude E6320. */
arch/x86/kernel/reboot.c:		.callback = set_pci_reboot,
arch/x86/kernel/reboot.c:	{	/* Handle problems with rebooting on the Latitude E6420. */
arch/x86/kernel/reboot.c:		.callback = set_pci_reboot,
arch/x86/kernel/reboot.c:	{	/* Handle problems with rebooting on Dell Optiplex 330 with 0KP561 */
arch/x86/kernel/reboot.c:		.callback = set_bios_reboot,
arch/x86/kernel/reboot.c:	{	/* Handle problems with rebooting on Dell Optiplex 360 with 0T656F */
arch/x86/kernel/reboot.c:		.callback = set_bios_reboot,
arch/x86/kernel/reboot.c:	{	/* Handle problems with rebooting on Dell Optiplex 745's SFF */
arch/x86/kernel/reboot.c:		.callback = set_bios_reboot,
arch/x86/kernel/reboot.c:	{	/* Handle problems with rebooting on Dell Optiplex 745's DFF */
arch/x86/kernel/reboot.c:		.callback = set_bios_reboot,
arch/x86/kernel/reboot.c:	{	/* Handle problems with rebooting on Dell Optiplex 745 with 0KW626 */
arch/x86/kernel/reboot.c:		.callback = set_bios_reboot,
arch/x86/kernel/reboot.c:	{	/* Handle problems with rebooting on Dell OptiPlex 760 with 0G919G */
arch/x86/kernel/reboot.c:		.callback = set_bios_reboot,
arch/x86/kernel/reboot.c:	{	/* Handle problems with rebooting on the OptiPlex 990. */
arch/x86/kernel/reboot.c:		.callback = set_pci_reboot,
arch/x86/kernel/reboot.c:	{	/* Handle problems with rebooting on Dell 300's */
arch/x86/kernel/reboot.c:		.callback = set_bios_reboot,
arch/x86/kernel/reboot.c:	{	/* Handle problems with rebooting on Dell 1300's */
arch/x86/kernel/reboot.c:		.callback = set_bios_reboot,
arch/x86/kernel/reboot.c:	{	/* Handle problems with rebooting on Dell 2400's */
arch/x86/kernel/reboot.c:		.callback = set_bios_reboot,
arch/x86/kernel/reboot.c:	{	/* Handle problems with rebooting on the Dell PowerEdge C6100. */
arch/x86/kernel/reboot.c:		.callback = set_pci_reboot,
arch/x86/kernel/reboot.c:	{	/* Handle problems with rebooting on the Precision M6600. */
arch/x86/kernel/reboot.c:		.callback = set_pci_reboot,
arch/x86/kernel/reboot.c:	{	/* Handle problems with rebooting on Dell T5400's */
arch/x86/kernel/reboot.c:		.callback = set_bios_reboot,
arch/x86/kernel/reboot.c:	{	/* Handle problems with rebooting on Dell T7400's */
arch/x86/kernel/reboot.c:		.callback = set_bios_reboot,
arch/x86/kernel/reboot.c:	{	/* Handle problems with rebooting on Dell XPS710 */
arch/x86/kernel/reboot.c:		.callback = set_bios_reboot,
arch/x86/kernel/reboot.c:	{	/* Handle problems with rebooting on HP laptops */
arch/x86/kernel/reboot.c:		.callback = set_bios_reboot,
arch/x86/kernel/reboot.c:	{	/* Handle problems with rebooting on Sony VGN-Z540N */
arch/x86/kernel/reboot.c:		.callback = set_bios_reboot,
arch/x86/kernel/reboot.c:static int __init reboot_init(void)
arch/x86/kernel/reboot.c:	 * Only do the DMI check if reboot_type hasn't been overridden
arch/x86/kernel/reboot.c:	if (!reboot_default)
arch/x86/kernel/reboot.c:	 * reboot.
arch/x86/kernel/reboot.c:	rv = dmi_check_system(reboot_dmi_table);
arch/x86/kernel/reboot.c:	if (!rv && efi_reboot_required())
arch/x86/kernel/reboot.c:		reboot_type = BOOT_EFI;
arch/x86/kernel/reboot.c:core_initcall(reboot_init);
arch/x86/kernel/reboot.c:	 * We need to disable VMX on all CPUs before rebooting, otherwise
arch/x86/kernel/reboot.c:void __attribute__((weak)) mach_reboot_fixups(void)
arch/x86/kernel/reboot.c: * the following on reboot:
arch/x86/kernel/reboot.c: * 1) If the FADT has the ACPI reboot register flag set, try it
arch/x86/kernel/reboot.c: * 3) If still alive, write to the ACPI reboot register again
arch/x86/kernel/reboot.c: * 5) If still alive, call the EFI runtime service to reboot
arch/x86/kernel/reboot.c: * 6) If no EFI runtime service, call the BIOS to do a reboot
arch/x86/kernel/reboot.c: * two other reboot methods: 'triple fault' and 'PCI', which
arch/x86/kernel/reboot.c: * can be triggered via the reboot= kernel boot option or
arch/x86/kernel/reboot.c: * by not rebooting properly and hanging.
arch/x86/kernel/reboot.c:	int orig_reboot_type = reboot_type;
arch/x86/kernel/reboot.c:	if (reboot_emergency)
arch/x86/kernel/reboot.c:	/* Tell the BIOS if we want cold or warm reboot */
arch/x86/kernel/reboot.c:	mode = reboot_mode == REBOOT_WARM ? 0x1234 : 0;
arch/x86/kernel/reboot.c:		switch (reboot_type) {
arch/x86/kernel/reboot.c:			acpi_reboot();
arch/x86/kernel/reboot.c:			reboot_type = BOOT_KBD;
arch/x86/kernel/reboot.c:			mach_reboot_fixups(); /* For board specific fixups */
arch/x86/kernel/reboot.c:			if (attempt == 0 && orig_reboot_type == BOOT_ACPI) {
arch/x86/kernel/reboot.c:				reboot_type = BOOT_ACPI;
arch/x86/kernel/reboot.c:				reboot_type = BOOT_EFI;
arch/x86/kernel/reboot.c:			efi_reboot(reboot_mode, NULL);
arch/x86/kernel/reboot.c:			reboot_type = BOOT_BIOS;
arch/x86/kernel/reboot.c:			reboot_type = BOOT_CF9_SAFE;
arch/x86/kernel/reboot.c:				u8 reboot_code = reboot_mode == REBOOT_WARM ?  0x06 : 0x0E;
arch/x86/kernel/reboot.c:				u8 cf9 = inb(0xcf9) & ~reboot_code;
arch/x86/kernel/reboot.c:				outb(cf9|reboot_code, 0xcf9);
arch/x86/kernel/reboot.c:			reboot_type = BOOT_TRIPLE;
arch/x86/kernel/reboot.c:			reboot_type = BOOT_KBD;
arch/x86/kernel/reboot.c:	reboot_emergency = emergency;
arch/x86/kernel/reboot.c:	if (!reboot_force)
arch/x86/kernel/reboot.c:		if (!reboot_force)
arch/x86/kernel/reboot.c: * or emergency reboot time. The function passed as parameter
arch/x86/kernel/crash_dump_64.c: *	Memory preserving reboot related code.
arch/x86/kernel/machine_kexec_32.c: * reboot code buffer to allow us to avoid allocations
arch/x86/kernel/machine_kexec_32.c: * We are past the point of no return, committed to rebooting now.
arch/x86/kernel/machine_kexec_32.c:	/* Interrupts aren't acceptable while we reboot */
arch/x86/kernel/entry_64.S:	reboot_interrupt smp_reboot_interrupt
arch/x86/kernel/machine_kexec_64.c:#include <linux/reboot.h>
arch/x86/kernel/machine_kexec_64.c: * We are past the point of no return, committed to rebooting now.
arch/x86/kernel/machine_kexec_64.c:	/* Interrupts aren't acceptable while we reboot */
arch/x86/kernel/reboot_fixups_32.c: * This is a good place to put board specific reboot fixups.
arch/x86/kernel/reboot_fixups_32.c:#include <asm/reboot_fixups.h>
arch/x86/kernel/reboot_fixups_32.c:	void (*reboot_fixup)(struct pci_dev *);
arch/x86/kernel/reboot_fixups_32.c: * standard mach_reboot on return.
arch/x86/kernel/reboot_fixups_32.c:void mach_reboot_fixups(void)
arch/x86/kernel/reboot_fixups_32.c:		cur->reboot_fixup(dev);
arch/x86/kernel/apic/io_apic.c: * Not an __init, needed by the reboot code
arch/x86/kernel/apic/io_apic.c:	 * Clear the IO-APIC before rebooting:
arch/x86/kernel/apic/apic.c: * This is called, when a CPU is disabled and before rebooting, so the state of
arch/x86/kernel/apic/x2apic_uv_x.c:#include <linux/reboot.h>
arch/x86/kernel/apic/x2apic_uv_x.c:		reboot_type = BOOT_ACPI;
arch/x86/kernel/apm_32.c:#include <asm/reboot.h>
arch/x86/kernel/irqinit.c:	/* IPI used for rebooting/stopping */
arch/x86/kernel/irqinit.c:	alloc_intr_gate(REBOOT_VECTOR, reboot_interrupt);
arch/x86/kernel/crash_dump_32.c: *	Memory preserving reboot related code.
arch/x86/kernel/process_32.c:#include <linux/reboot.h>
arch/x86/kernel/Makefile:obj-y				+= reboot.o
arch/x86/kernel/Makefile:obj-$(CONFIG_X86_REBOOTFIXUPS)	+= reboot_fixups_32.o
arch/x86/kernel/kvm.c:#include <linux/reboot.h>
arch/x86/kernel/kvm.c:static void kvm_pv_guest_cpu_reboot(void *unused)
arch/x86/kernel/kvm.c:static int kvm_pv_reboot_notify(struct notifier_block *nb,
arch/x86/kernel/kvm.c:		on_each_cpu(kvm_pv_guest_cpu_reboot, NULL, 1);
arch/x86/kernel/kvm.c:static struct notifier_block kvm_pv_reboot_nb = {
arch/x86/kernel/kvm.c:	.notifier_call = kvm_pv_reboot_notify,
arch/x86/kernel/kvm.c:	register_reboot_notifier(&kvm_pv_reboot_nb);
arch/x86/kernel/kvmclock.c:#include <asm/reboot.h>
arch/x86/kernel/crash.c:#include <linux/reboot.h>
arch/x86/kernel/crash.c:#include <asm/reboot.h>
arch/x86/kernel/crash.c:	 * Having VMX or SVM enabled on any CPU may break rebooting
arch/x86/lib/memcpy_64.S:	 * so it is silly to overwrite itself with nops - reboot is the
arch/x86/boot/header.S:	# Allow the user to press a key, then reboot
arch/x86/boot/header.S:	.ascii	"Remove disk and press any key to reboot...\r\n"
arch/x86/Kconfig:	bool "Enable X86 board specific fixups for reboot"
arch/x86/Kconfig:	  in order to get reboot to work correctly. This is only needed on
arch/x86/Kconfig:	  this config is intended, is when reboot ends with a stalled/hung
arch/x86/Kconfig:	  spontaneous reboots) or a non-working video driver.
arch/x86/Kconfig:	  current kernel, and to start another kernel.  It is like a reboot
arch/x86/Kconfig:	  but it is independent of the system firmware.   And like a reboot
arch/x86/Kconfig:	  random kernel OOPSes or reboots that don't seem to be related to
arch/arc/kernel/smp.c:#include <linux/reboot.h>
arch/arc/kernel/reset.c:#include <linux/reboot.h>
arch/arc/kernel/devtree.c:#include <linux/reboot.h>
arch/score/kernel/process.c:#include <linux/reboot.h>
arch/sparc/prom/misc_32.c:/* Reset and reboot the machine with the command 'bcommand'. */
arch/sparc/prom/misc_32.c:prom_reboot(char *bcommand)
arch/sparc/prom/misc_32.c:	(*(romvec->pv_reboot))(bcommand);
arch/sparc/prom/misc_64.c:/* Reset and reboot the machine with the command 'bcommand'. */
arch/sparc/prom/misc_64.c:void prom_reboot(const char *bcommand)
arch/sparc/prom/misc_64.c:		ldom_reboot(bcommand);
arch/sparc/include/uapi/asm/unistd.h:#define __NR_reboot              55 /* Common                                      */
arch/sparc/include/asm/ldc.h:void ldom_reboot(const char *boot_command);
arch/sparc/include/asm/oplib_64.h:void prom_reboot(const char *boot_command);
arch/sparc/include/asm/hypervisor.h:unsigned long sun4v_reboot_data_set(unsigned long ra,
arch/sparc/include/asm/setup.h:extern char reboot_command[];
arch/sparc/include/asm/openprom.h:	void (*pv_reboot)(char *bootstr);
arch/sparc/include/asm/oplib_32.h:void prom_reboot(char *boot_command);
arch/sparc/kernel/setup_64.c:char reboot_command[COMMAND_LINE_SIZE];
arch/sparc/kernel/reboot.c:/* reboot.c: reboot/shutdown/halt/poweroff handling
arch/sparc/kernel/reboot.c:#include <linux/reboot.h>
arch/sparc/kernel/reboot.c:	p = strchr(reboot_command, '\n');
arch/sparc/kernel/reboot.c:		prom_reboot(cmd);
arch/sparc/kernel/reboot.c:	if (*reboot_command)
arch/sparc/kernel/reboot.c:		prom_reboot(reboot_command);
arch/sparc/kernel/reboot.c:	prom_reboot("");
arch/sparc/kernel/traps_64.c:#include <linux/reboot.h>
arch/sparc/kernel/setup_32.c:char reboot_command[COMMAND_LINE_SIZE];
arch/sparc/kernel/head_32.S:	.word	reboot_command
arch/sparc/kernel/systbls_64.S:	.word sys_reboot, sys32_mmap2, sys_symlink, sys_readlink, sys32_execve
arch/sparc/kernel/systbls_64.S:	.word sys_reboot, sys_nis_syscall, sys_symlink, sys_readlink, sys64_execve
arch/sparc/kernel/hvcalls.S:ENTRY(sun4v_reboot_data_set)
arch/sparc/kernel/hvcalls.S:ENDPROC(sun4v_reboot_data_set)
arch/sparc/kernel/ds.c:#include <linux/reboot.h>
arch/sparc/kernel/ds.c:static int reboot_data_supported;
arch/sparc/kernel/ds.c:void ldom_reboot(const char *boot_command)
arch/sparc/kernel/ds.c:		if (reboot_data_supported) {
arch/sparc/kernel/ds.c:			hv_ret = sun4v_reboot_data_set(ra, len);
arch/sparc/kernel/ds.c:				pr_err("SUN4V: Unable to set reboot data "
arch/sparc/kernel/ds.c:			ldom_set_var("reboot-command", full_boot_str);
arch/sparc/kernel/ds.c:			reboot_data_supported = 1;
arch/sparc/kernel/nmi.c:#include <linux/reboot.h>
arch/sparc/kernel/nmi.c:static struct notifier_block nmi_reboot_notifier = {
arch/sparc/kernel/nmi.c:		err = register_reboot_notifier(&nmi_reboot_notifier);
arch/sparc/kernel/process_32.c:#include <linux/reboot.h>
arch/sparc/kernel/process_32.c:	p = strchr (reboot_command, '\n');
arch/sparc/kernel/process_32.c:		prom_reboot(cmd);
arch/sparc/kernel/process_32.c:	if (*reboot_command)
arch/sparc/kernel/process_32.c:		prom_reboot(reboot_command);
arch/sparc/kernel/systbls_32.S:/*55*/	.long sys_reboot, sys_mmap2, sys_symlink, sys_readlink, sys_execve
arch/sparc/kernel/power.c:#include <linux/reboot.h>
arch/sparc/kernel/sstate.c:#include <linux/reboot.h>
arch/sparc/kernel/sstate.c:static const char rebooting_msg[32] __attribute__((aligned(32))) =
arch/sparc/kernel/sstate.c:	"Linux rebooting";
arch/sparc/kernel/sstate.c:static int sstate_reboot_call(struct notifier_block *np, unsigned long type, void *_unused)
arch/sparc/kernel/sstate.c:		msg = rebooting_msg;
arch/sparc/kernel/sstate.c:static struct notifier_block sstate_reboot_notifier = {
arch/sparc/kernel/sstate.c:	.notifier_call = sstate_reboot_call,
arch/sparc/kernel/sstate.c:	register_reboot_notifier(&sstate_reboot_notifier);
arch/sparc/kernel/Makefile:obj-$(CONFIG_SPARC64)   += reboot.o
arch/sparc/kernel/head_64.S:	 * 0x0201 : Supports reboot_command
arch/sparc/kernel/head_64.S:        .xword  reboot_command
arch/xtensa/platforms/xt2000/setup.c:#include <linux/reboot.h>
arch/xtensa/platforms/iss/setup.c:#include <linux/reboot.h>
arch/xtensa/platforms/xtfpga/setup.c:#include <linux/reboot.h>
arch/xtensa/include/uapi/asm/unistd.h:#define __NR_reboot 				203
arch/xtensa/include/uapi/asm/unistd.h:__SYSCALL(203, sys_reboot, 3)
arch/xtensa/kernel/smp.c:#include <linux/reboot.h>
arch/avr32/include/uapi/asm/unistd.h:#define __NR_reboot		 89
arch/avr32/kernel/process.c:#include <linux/reboot.h>
arch/avr32/kernel/syscall_table.S:	.long	sys_reboot
arch/frv/include/uapi/asm/unistd.h:#define __NR_reboot		 88
arch/frv/kernel/entry.S:	.long sys_reboot
arch/frv/kernel/process.c:#include <linux/reboot.h>
arch/c6x/kernel/process.c:#include <linux/reboot.h>
arch/mips/alchemy/board-xxs1500.c:#include <asm/reboot.h>
arch/mips/alchemy/devboards/db1000.c:#include <asm/reboot.h>
arch/mips/alchemy/devboards/platform.c:#include <asm/reboot.h>
arch/mips/alchemy/board-mtx1.c:#include <asm/reboot.h>
arch/mips/alchemy/board-gpr.c:#include <asm/reboot.h>
arch/mips/mti-sead3/sead3-reset.c:#include <asm/reboot.h>
arch/mips/mti-sead3/sead3-reset.c:static int __init mips_reboot_setup(void)
arch/mips/mti-sead3/sead3-reset.c:arch_initcall(mips_reboot_setup);
arch/mips/ath25/ar2315.c:#include <linux/reboot.h>
arch/mips/ath25/ar2315.c:#include <asm/reboot.h>
arch/mips/ath25/ar5312.c:#include <linux/reboot.h>
arch/mips/ath25/ar5312.c:#include <asm/reboot.h>
arch/mips/ath25/board.c:#include <asm/reboot.h>
arch/mips/paravirt/setup.c:#include <asm/reboot.h>
arch/mips/sni/reset.c:#include <asm/reboot.h>
arch/mips/sni/reset.c: * This routine reboots the machine by asking the keyboard
arch/mips/sni/setup.c:#include <asm/reboot.h>
arch/mips/sibyte/bcm1480/setup.c:#include <linux/reboot.h>
arch/mips/sibyte/common/cfe.c:#include <asm/reboot.h>
arch/mips/sibyte/common/cfe.c:		static int reboot_smp;
arch/mips/sibyte/common/cfe.c:		if (!reboot_smp) {
arch/mips/sibyte/common/cfe.c:			reboot_smp = 1;
arch/mips/sibyte/sb1250/setup.c:#include <linux/reboot.h>
arch/mips/sibyte/swarm/setup.c:#include <asm/reboot.h>
arch/mips/lasat/reset.c:#include <asm/reboot.h>
arch/mips/lasat/reset.c:void lasat_reboot_setup(void)
arch/mips/lasat/setup.c:extern void lasat_reboot_setup(void);
arch/mips/lasat/setup.c:	lasat_reboot_setup();
arch/mips/pnx833x/common/reset.c:#include <linux/reboot.h>
arch/mips/pnx833x/common/setup.c:#include <asm/reboot.h>
arch/mips/sgi-ip32/ip32-reset.c:#include <asm/reboot.h>
arch/mips/sgi-ip32/ip32-reset.c: * Blink frequency during reboot grace period and when panicked.
arch/mips/sgi-ip32/ip32-reset.c:static __init int ip32_reboot_setup(void)
arch/mips/sgi-ip32/ip32-reset.c:subsys_initcall(ip32_reboot_setup);
arch/mips/pmcs-msp71xx/msp_setup.c:#include <asm/reboot.h>
arch/mips/pmcs-msp71xx/msp_setup.c:	printk(KERN_WARNING "Now rebooting .......\n");
arch/mips/jazz/setup.c:#include <asm/reboot.h>
arch/mips/ar7/setup.c:#include <asm/reboot.h>
arch/mips/bcm63xx/setup.c:#include <asm/reboot.h>
arch/mips/bcm63xx/setup.c:static void bcm6348_a1_reboot(void)
arch/mips/bcm63xx/setup.c:void bcm63xx_machine_reboot(void)
arch/mips/bcm63xx/setup.c:		bcm6348_a1_reboot();
arch/mips/bcm63xx/setup.c:static void __bcm63xx_machine_reboot(char *p)
arch/mips/bcm63xx/setup.c:	bcm63xx_machine_reboot();
arch/mips/bcm63xx/setup.c:	_machine_restart = __bcm63xx_machine_reboot;
arch/mips/jz4740/reset.c:#include <asm/reboot.h>
arch/mips/mti-malta/malta-reset.c:#include <asm/reboot.h>
arch/mips/mti-malta/malta-reset.c:static int __init mips_reboot_setup(void)
arch/mips/mti-malta/malta-reset.c:arch_initcall(mips_reboot_setup);
arch/mips/cavium-octeon/setup.c:#include <asm/reboot.h>
arch/mips/cavium-octeon/setup.c:	while (!atomic_read(&kexec_ready_to_reboot))
arch/mips/emma/markeins/setup.c:#include <asm/reboot.h>
arch/mips/emma/markeins/platform.c:#include <asm/reboot.h>
arch/mips/vr41xx/common/pmu.c:#include <asm/reboot.h>
arch/mips/netlogic/xlp/setup.c:#include <asm/reboot.h>
arch/mips/netlogic/common/smpboot.S:NESTED(nlm_rmiboot_preboot, 16, sp)
arch/mips/netlogic/common/smpboot.S:END(nlm_rmiboot_preboot)
arch/mips/netlogic/xlr/wakeup.c:	nlm_set_nmi_handler(nlm_rmiboot_preboot);
arch/mips/netlogic/xlr/setup.c:#include <asm/reboot.h>
arch/mips/fw/arc/misc.c:	ARC_CALL0(reboot);
arch/mips/fw/arc/init.c:	pr_info("Press a key to reboot\n");
arch/mips/rb532/setup.c:#include <asm/reboot.h>
arch/mips/loongson1/common/reset.c:#include <asm/reboot.h>
arch/mips/loongson1/common/reset.c:static int __init ls1x_reboot_setup(void)
arch/mips/loongson1/common/reset.c:arch_initcall(ls1x_reboot_setup);
arch/mips/sgi-ip27/ip27-init.c:extern void ip27_reboot_setup(void);
arch/mips/sgi-ip27/ip27-init.c:	ip27_reboot_setup();
arch/mips/sgi-ip27/ip27-reset.c:#include <asm/reboot.h>
arch/mips/sgi-ip27/ip27-reset.c:/* XXX How to pass the reboot command to the firmware??? */
arch/mips/sgi-ip27/ip27-reset.c:void ip27_reboot_setup(void)
arch/mips/ralink/reset.c:#include <asm/reboot.h>
arch/mips/ralink/reset.c:static int __init mips_reboot_setup(void)
arch/mips/ralink/reset.c:arch_initcall(mips_reboot_setup);
arch/mips/ralink/of.c:#include <asm/reboot.h>
arch/mips/include/uapi/asm/unistd.h:#define __NR_reboot			(__NR_Linux +  88)
arch/mips/include/uapi/asm/unistd.h:#define __NR_reboot			(__NR_Linux + 164)
arch/mips/include/uapi/asm/unistd.h:#define __NR_reboot			(__NR_Linux + 164)
arch/mips/include/asm/kexec.h:extern atomic_t kexec_ready_to_reboot;
arch/mips/include/asm/mach-bcm63xx/bcm63xx_cpu.h:void bcm63xx_machine_reboot(void);
arch/mips/include/asm/netlogic/common.h:void nlm_rmiboot_preboot(void);
arch/mips/include/asm/mach-loongson/loongson.h:/* machine-specific reboot/halt operation */
arch/mips/include/asm/mach-loongson/loongson.h:extern void mach_prepare_reboot(void);
arch/mips/include/asm/mc146818-time.h: *	sets the minutes. Usually you'll only notice that after reboot!
arch/mips/include/asm/sgiarcs.h:	LONG	reboot;			/* Reboot the machine. */
arch/mips/kernel/scall64-n32.S:	PTR	sys_reboot
arch/mips/kernel/reset.c:#include <linux/reboot.h>
arch/mips/kernel/reset.c:#include <asm/reboot.h>
arch/mips/kernel/smp-bmips.c:#include <linux/reboot.h>
arch/mips/kernel/scall64-64.S:	PTR	sys_reboot
arch/mips/kernel/scall64-o32.S:	PTR	sys_reboot
arch/mips/kernel/machine_kexec.c:atomic_t kexec_ready_to_reboot = ATOMIC_INIT(0);
arch/mips/kernel/machine_kexec.c:	unsigned long reboot_code_buffer;
arch/mips/kernel/machine_kexec.c:	reboot_code_buffer =
arch/mips/kernel/machine_kexec.c:	memcpy((void*)reboot_code_buffer, relocate_new_kernel,
arch/mips/kernel/machine_kexec.c:	relocated_kexec_smp_wait = reboot_code_buffer +
arch/mips/kernel/machine_kexec.c:	atomic_set(&kexec_ready_to_reboot, 1);
arch/mips/kernel/machine_kexec.c:	((noretfun_t) reboot_code_buffer)();
arch/mips/kernel/scall32-o32.S:	PTR	sys_reboot
arch/mips/kernel/crash.c:#include <linux/reboot.h>
arch/mips/kernel/crash.c:	while (!atomic_read(&kexec_ready_to_reboot))
arch/mips/sgi-ip22/ip22-reset.c:#include <asm/reboot.h>
arch/mips/sgi-ip22/ip22-reset.c: * Blink frequency during reboot grace period and when panicked.
arch/mips/sgi-ip22/ip22-reset.c:static int __init reboot_setup(void)
arch/mips/sgi-ip22/ip22-reset.c:subsys_initcall(reboot_setup);
arch/mips/sgi-ip22/ip22-mc.c:	 *	   soft reboot).
arch/mips/sgi-ip22/ip22-setup.c:#include <asm/reboot.h>
arch/mips/bcm47xx/setup.c:#include <asm/reboot.h>
arch/mips/bcm47xx/setup.c:	printk(KERN_ALERT "Please stand by while rebooting the system...\n");
arch/mips/txx9/jmr3927/setup.c:#include <asm/reboot.h>
arch/mips/txx9/rbtx4939/setup.c:#include <asm/reboot.h>
arch/mips/txx9/generic/setup_tx4927.c:#include <asm/reboot.h>
arch/mips/txx9/generic/setup.c:#include <asm/reboot.h>
arch/mips/txx9/generic/setup_tx4938.c:#include <asm/reboot.h>
arch/mips/txx9/generic/setup_tx4939.c:#include <asm/reboot.h>
arch/mips/txx9/rbtx4938/setup.c:#include <asm/reboot.h>
arch/mips/txx9/rbtx4927/setup.c:#include <asm/reboot.h>
arch/mips/ath79/setup.c:#include <asm/reboot.h>		/* for _machine_{restart,halt} */
arch/mips/lantiq/clk.h:	void (*reboot) (struct clk *clk);
arch/mips/lantiq/xway/reset.c:#include <asm/reboot.h>
arch/mips/lantiq/xway/reset.c:/* reboot bit */
arch/mips/lantiq/xway/reset.c:static int __init mips_reboot_setup(void)
arch/mips/lantiq/xway/reset.c:arch_initcall(mips_reboot_setup);
arch/mips/lantiq/falcon/reset.c:#include <asm/reboot.h>
arch/mips/lantiq/falcon/reset.c:	/* reboot magic */
arch/mips/lantiq/falcon/reset.c:static int __init mips_reboot_setup(void)
arch/mips/lantiq/falcon/reset.c:arch_initcall(mips_reboot_setup);
arch/mips/lantiq/falcon/sysctrl.c:/* reboot Register */
arch/mips/lantiq/falcon/sysctrl.c:static void sysctl_reboot(struct clk *clk)
arch/mips/lantiq/falcon/sysctrl.c:	clk->reboot = sysctl_reboot;
arch/mips/loongson/common/reset.c:#include <asm/reboot.h>
arch/mips/loongson/common/reset.c:static inline void loongson_reboot(void)
arch/mips/loongson/common/reset.c:	/* do preparation for reboot */
arch/mips/loongson/common/reset.c:	mach_prepare_reboot();
arch/mips/loongson/common/reset.c:	/* reboot via jumping to boot base address */
arch/mips/loongson/common/reset.c:	loongson_reboot();
arch/mips/loongson/common/reset.c:static int __init mips_reboot_setup(void)
arch/mips/loongson/common/reset.c:arch_initcall(mips_reboot_setup);
arch/mips/loongson/lemote-2f/reset.c:/* Board-specific reboot/shutdown routines
arch/mips/loongson/lemote-2f/reset.c:static void fl2f_reboot(void)
arch/mips/loongson/lemote-2f/reset.c:	 * you can type halt command and then reboot, seems the hardware reset
arch/mips/loongson/lemote-2f/reset.c:static void ml2f_reboot(void)
arch/mips/loongson/lemote-2f/reset.c:#define yl2f89_reboot ml2f_reboot
arch/mips/loongson/lemote-2f/reset.c:void mach_prepare_reboot(void)
arch/mips/loongson/lemote-2f/reset.c:		fl2f_reboot();
arch/mips/loongson/lemote-2f/reset.c:		ml2f_reboot();
arch/mips/loongson/lemote-2f/reset.c:		yl2f89_reboot();
arch/mips/loongson/fuloong-2e/reset.c:/* Board-specific reboot/shutdown routines
arch/mips/loongson/fuloong-2e/reset.c:void mach_prepare_reboot(void)
arch/mips/cobalt/setup.c:#include <asm/reboot.h>
arch/mips/Kconfig:	  current kernel, and to start another kernel.  It is like a reboot
arch/mips/Kconfig:	  but it is independent of the system firmware.   And like a reboot
arch/mips/dec/setup.c:#include <asm/reboot.h>
arch/m68k/sun3x/config.c:	mach_reset           = sun3x_reboot;
arch/m68k/sun3x/prom.c:void (*sun3x_prom_reboot)(void);
arch/m68k/sun3x/prom.c:void sun3x_reboot(void)
arch/m68k/sun3x/prom.c:	(*romvec->pv_reboot)("vmlinux");
arch/m68k/sun3x/prom.c:	sun3x_prom_reboot = *(void (**)(void)) (SUN3X_P_REBOOT);
arch/m68k/atari/config.c:			 * Afterburner040 to successfully reboot. Other machines shouldn't
arch/m68k/hp300/reboot.S: *  linux/arch/m68k/hp300/reboot.S
arch/m68k/hp300/reboot.S: *  Do the dirty work of rebooting the machine.  Basically we need to undo all the
arch/m68k/hp300/Makefile:obj-y		:= config.o time.o reboot.o
arch/m68k/sun3/config.c:static void sun3_reboot (void)
arch/m68k/sun3/config.c:	prom_reboot ("vmlinux");
arch/m68k/sun3/config.c:        mach_reset           =  sun3_reboot;
arch/m68k/sun3/prom/misc.c:/* Reset and reboot the machine with the command 'bcommand'. */
arch/m68k/sun3/prom/misc.c:prom_reboot(char *bcommand)
arch/m68k/sun3/prom/misc.c:	(*(romvec->pv_reboot))(bcommand);
arch/m68k/include/uapi/asm/unistd.h:#define __NR_reboot		 88
arch/m68k/include/asm/oplib.h:extern void prom_reboot(char *boot_command);
arch/m68k/include/asm/sun3xprom.h:void sun3x_reboot(void);
arch/m68k/include/asm/openprom.h:	void		(*pv_reboot)(char *bootstr);
arch/m68k/include/asm/openprom.h:	void (*pv_reboot)(char *bootstr);
arch/m68k/kernel/process.c:#include <linux/reboot.h>
arch/m68k/kernel/machine_kexec.c:	void *reboot_code_buffer;
arch/m68k/kernel/machine_kexec.c:	reboot_code_buffer = page_address(image->control_code_page);
arch/m68k/kernel/machine_kexec.c:	memcpy(reboot_code_buffer, relocate_new_kernel,
arch/m68k/kernel/machine_kexec.c:	((relocate_kernel_t) reboot_code_buffer)(image->head & PAGE_MASK,
arch/m68k/kernel/setup_no.c:/* machine dependent reboot functions */
arch/m68k/kernel/syscalltable.S:	.long sys_reboot
arch/m68k/Kconfig:	  current kernel, and to start another kernel.  It is like a reboot
arch/m68k/Kconfig:	  but it is independent of the system firmware.   And like a reboot
arch/cris/arch-v32/kernel/entry.S:	.long sys_reboot
arch/cris/arch-v32/kernel/kgdb.c:#include <linux/reboot.h>
arch/cris/include/uapi/asm/unistd.h:#define __NR_reboot		 88
arch/cris/kernel/process.c:#include <linux/reboot.h>
arch/cris/kernel/traps.c: * doggy, then halt instead of reboot.
arch/cris/arch-v10/kernel/entry.S:	.long sys_reboot
arch/cris/arch-v10/kernel/kgdb.c:#include <linux/reboot.h>
arch/metag/kernel/process.c:#include <linux/reboot.h>
arch/tile/include/asm/kexec.h: * reboot with a single type of kernel image anyway.
arch/tile/kernel/reboot.c:#include <linux/reboot.h>
arch/tile/kernel/machine_kexec.c:#include <linux/reboot.h>
arch/tile/kernel/machine_kexec.c:	void *reboot_code_buffer;
arch/tile/kernel/machine_kexec.c:	/* Mask all interrupts before starting to reboot. */
arch/tile/kernel/machine_kexec.c:	reboot_code_buffer = page_address(image->control_code_page);
arch/tile/kernel/machine_kexec.c:	BUG_ON(reboot_code_buffer == NULL);
arch/tile/kernel/machine_kexec.c:	ptep = virt_to_pte(NULL, (unsigned long)reboot_code_buffer);
arch/tile/kernel/machine_kexec.c:	memcpy(reboot_code_buffer, relocate_new_kernel,
arch/tile/kernel/machine_kexec.c:		(unsigned long) reboot_code_buffer,
arch/tile/kernel/machine_kexec.c:		(unsigned long) reboot_code_buffer + relocate_new_kernel_size);
arch/tile/kernel/machine_kexec.c:	rnk = reboot_code_buffer;
arch/tile/kernel/machine_kexec.c:	(*rnk)(image->head, reboot_code_buffer, image->start);
arch/tile/kernel/traps.c:#include <linux/reboot.h>
arch/tile/kernel/Makefile:	pci-dma.o proc.o process.o ptrace.o reboot.o \
arch/tile/Kconfig:	  current kernel, and to start another kernel.  It is like a reboot
arch/alpha/mm/init.c:	   restore the original console's page tables for a clean reboot.
arch/alpha/include/uapi/asm/unistd.h:#define __NR_osf_reboot		 55	/* not implemented */
arch/alpha/include/uapi/asm/unistd.h:#define __NR_reboot		311
arch/alpha/kernel/sys_alcor.c:#include <linux/reboot.h>
arch/alpha/kernel/process.c:#include <linux/reboot.h>
arch/alpha/kernel/systbls.S:	.quad sys_reboot
arch/alpha/kernel/setup.c:#include <linux/reboot.h>
arch/alpha/kernel/setup.c:	   not auto-reboot.  */
arch/alpha/kernel/core_tsunami.c:	 * need them when we go to reboot.
arch/alpha/kernel/sys_nautilus.c:#include <linux/reboot.h>
arch/alpha/kernel/sys_miata.c:#include <linux/reboot.h>
arch/alpha/kernel/core_titan.c:	 * need them when we go to reboot.
arch/alpha/Kconfig:	  the printing mode to be 0. Then, upon reboot, one could add
arch/s390/include/uapi/asm/unistd.h:#define __NR_reboot              88
arch/s390/kernel/machine_kexec.c:#include <linux/reboot.h>
arch/s390/kernel/machine_kexec.c:	void *reboot_code_buffer;
arch/s390/kernel/machine_kexec.c:	reboot_code_buffer = (void *) page_to_phys(image->control_code_page);
arch/s390/kernel/machine_kexec.c:	memcpy(reboot_code_buffer, relocate_kernel, relocate_kernel_len);
arch/s390/kernel/setup.c:#include <linux/reboot.h>
arch/s390/kernel/dis.c:#include <linux/reboot.h>
arch/s390/kernel/syscalls.S:SYSCALL(sys_reboot,sys_reboot,compat_sys_reboot)
arch/s390/kernel/compat_wrapper.c:COMPAT_SYSCALL_WRAP4(reboot, int, magic1, int, magic2, unsigned int, cmd, void __user *, arg);
arch/s390/kernel/ipl.c:#include <linux/reboot.h>
arch/s390/kernel/ipl.c:#define ON_REIPL_STR		"on_reboot"
arch/s390/kernel/ipl.c:static char vmcmd_on_reboot[128];
arch/s390/kernel/ipl.c:DEFINE_IPL_ATTR_STR_RW(vmcmd, on_reboot, "%s\n", "%s\n", vmcmd_on_reboot);
arch/s390/kernel/ipl.c:	&sys_vmcmd_on_reboot_attr.attr,
arch/s390/kernel/ipl.c:		cmd = vmcmd_on_reboot;
arch/s390/kernel/ipl.c:static struct shutdown_trigger on_reboot_trigger = {ON_REIPL_STR,
arch/s390/kernel/ipl.c:static ssize_t on_reboot_show(struct kobject *kobj,
arch/s390/kernel/ipl.c:	return sprintf(page, "%s\n", on_reboot_trigger.action->name);
arch/s390/kernel/ipl.c:static ssize_t on_reboot_store(struct kobject *kobj,
arch/s390/kernel/ipl.c:	return set_trigger(buf, &on_reboot_trigger, len);
arch/s390/kernel/ipl.c:static struct kobj_attribute on_reboot_attr =
arch/s390/kernel/ipl.c:	__ATTR(on_reboot, 0644, on_reboot_show, on_reboot_store);
arch/s390/kernel/ipl.c:	on_reboot_trigger.action->fn(&on_reboot_trigger);
arch/s390/kernel/ipl.c:			      &on_reboot_attr.attr))
arch/s390/kernel/ipl.c:static int __init vmcmd_on_reboot_setup(char *str)
arch/s390/kernel/ipl.c:	strncpy_skip_quote(vmcmd_on_reboot, str, 127);
arch/s390/kernel/ipl.c:	vmcmd_on_reboot[127] = 0;
arch/s390/kernel/ipl.c:	on_reboot_trigger.action = &vmcmd_action;
arch/s390/kernel/ipl.c:__setup("vmreboot=", vmcmd_on_reboot_setup);
arch/s390/lib/delay.c: * Simple udelay variant. To be used on startup and reboot
arch/arm64/mm/mmu.c:void setup_mm_for_reboot(void)
arch/arm64/include/asm/system_misc.h:#include <linux/reboot.h>
arch/arm64/include/asm/system_misc.h:extern void (*arm_pm_restart)(enum reboot_mode reboot_mode, const char *cmd);
arch/arm64/include/asm/mmu.h:extern void setup_mm_for_reboot(void);
arch/arm64/include/asm/unistd32.h:#define __NR_reboot 88
arch/arm64/include/asm/unistd32.h:__SYSCALL(__NR_reboot, sys_reboot)
arch/arm64/kernel/sleep.S: * soft/hard reboot from the reset vector.
arch/arm64/kernel/process.c:#include <linux/reboot.h>
arch/arm64/kernel/process.c:	setup_mm_for_reboot();
arch/arm64/kernel/process.c:void (*arm_pm_restart)(enum reboot_mode reboot_mode, const char *cmd);
arch/arm64/kernel/process.c:		efi_reboot(reboot_mode, NULL);
arch/arm64/kernel/process.c:	/* Now call the architecture specific reboot code. */
arch/arm64/kernel/process.c:		arm_pm_restart(reboot_mode, cmd);
arch/arm64/kernel/process.c:	 * Whoops - the architecture was unable to reboot.
arch/arm64/kernel/psci.c:#include <linux/reboot.h>
arch/arm64/kernel/psci.c:static void psci_sys_reset(enum reboot_mode reboot_mode, const char *cmd)
arch/arm64/boot/dts/arm/rtsm_ve-motherboard.dtsi:			reboot@0 {
arch/arm64/boot/dts/arm/rtsm_ve-motherboard.dtsi:				compatible = "arm,vexpress-reboot";
arch/m32r/include/uapi/asm/unistd.h:#define __NR_reboot		 88
arch/m32r/kernel/syscall_table.S:	.long sys_reboot
arch/m32r/kernel/setup.c:	 * enabling clean reboots, SMP operation, laptop functions.
